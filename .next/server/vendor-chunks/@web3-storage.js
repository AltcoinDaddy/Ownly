"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@web3-storage";
exports.ids = ["vendor-chunks/@web3-storage"];
exports.modules = {

/***/ "(rsc)/./node_modules/@web3-storage/multipart-parser/esm/src/index.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@web3-storage/multipart-parser/esm/src/index.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   iterateMultipart: () => (/* binding */ iterateMultipart),\n/* harmony export */   streamMultipart: () => (/* binding */ streamMultipart)\n/* harmony export */ });\n/* harmony import */ var _search_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./search.js */ \"(rsc)/./node_modules/@web3-storage/multipart-parser/esm/src/search.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils.js */ \"(rsc)/./node_modules/@web3-storage/multipart-parser/esm/src/utils.js\");\n\n\nconst mergeArrays2 = Function.prototype.apply.bind(_utils_js__WEBPACK_IMPORTED_MODULE_1__.mergeArrays, undefined);\nconst dash = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.stringToArray)('--');\nconst CRLF = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.stringToArray)('\\r\\n');\nfunction parseContentDisposition(header) {\n  const parts = header.split(';').map(part => part.trim());\n  if (parts.shift() !== 'form-data') {\n    throw new Error('malformed content-disposition header: missing \"form-data\" in `' + JSON.stringify(parts) + '`');\n  }\n  const out = {};\n  for (const part of parts) {\n    const kv = part.split('=', 2);\n    if (kv.length !== 2) {\n      throw new Error('malformed content-disposition header: key-value pair not found - ' + part + ' in `' + header + '`');\n    }\n    const [name, value] = kv;\n    if (value[0] === '\"' && value[value.length - 1] === '\"') {\n      out[name] = value.slice(1, -1).replace(/\\\\\"/g, '\"');\n    } else if (value[0] !== '\"' && value[value.length - 1] !== '\"') {\n      out[name] = value;\n    } else if (value[0] === '\"' && value[value.length - 1] !== '\"' || value[0] !== '\"' && value[value.length - 1] === '\"') {\n      throw new Error('malformed content-disposition header: mismatched quotations in `' + header + '`');\n    }\n  }\n  if (!out.name) {\n    throw new Error('malformed content-disposition header: missing field name in `' + header + '`');\n  }\n  return out;\n}\nfunction parsePartHeaders(lines) {\n  const entries = [];\n  let disposition = false;\n  let line;\n  while (typeof (line = lines.shift()) !== 'undefined') {\n    const colon = line.indexOf(':');\n    if (colon === -1) {\n      throw new Error('malformed multipart-form header: missing colon');\n    }\n    const header = line.slice(0, colon).trim().toLowerCase();\n    const value = line.slice(colon + 1).trim();\n    switch (header) {\n    case 'content-disposition':\n      disposition = true;\n      entries.push(...Object.entries(parseContentDisposition(value)));\n      break;\n    case 'content-type':\n      entries.push([\n        'contentType',\n        value\n      ]);\n    }\n  }\n  if (!disposition) {\n    throw new Error('malformed multipart-form header: missing content-disposition');\n  }\n  return Object.fromEntries(entries);\n}\nasync function readHeaderLines(it, needle) {\n  let firstChunk = true;\n  let lastTokenWasMatch = false;\n  const headerLines = [[]];\n  const crlfSearch = new _search_js__WEBPACK_IMPORTED_MODULE_0__.StreamSearch(CRLF);\n  for (;;) {\n    const result = await it.next();\n    if (result.done) {\n      throw new Error('malformed multipart-form data: unexpected end of stream');\n    }\n    if (firstChunk && result.value !== _search_js__WEBPACK_IMPORTED_MODULE_0__.MATCH && (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.arraysEqual)(result.value.slice(0, 2), dash)) {\n      return [\n        undefined,\n        new Uint8Array()\n      ];\n    }\n    let chunk;\n    if (result.value !== _search_js__WEBPACK_IMPORTED_MODULE_0__.MATCH) {\n      chunk = result.value;\n    } else if (!lastTokenWasMatch) {\n      chunk = needle;\n    } else {\n      throw new Error('malformed multipart-form data: unexpected boundary');\n    }\n    if (!chunk.length) {\n      continue;\n    }\n    if (firstChunk) {\n      firstChunk = false;\n    }\n    const tokens = crlfSearch.feed(chunk);\n    for (const [i, token] of tokens.entries()) {\n      const isMatch = token === _search_js__WEBPACK_IMPORTED_MODULE_0__.MATCH;\n      if (!isMatch && !token.length) {\n        continue;\n      }\n      if (lastTokenWasMatch && isMatch) {\n        tokens.push(crlfSearch.end());\n        return [\n          headerLines.filter(chunks => chunks.length).map(mergeArrays2).map(_utils_js__WEBPACK_IMPORTED_MODULE_1__.arrayToString),\n          (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.mergeArrays)(...tokens.slice(i + 1).map(token => token === _search_js__WEBPACK_IMPORTED_MODULE_0__.MATCH ? CRLF : token))\n        ];\n      }\n      if (lastTokenWasMatch = isMatch) {\n        headerLines.push([]);\n      } else {\n        headerLines[headerLines.length - 1].push(token);\n      }\n    }\n  }\n}\nasync function* streamMultipart(body, boundary) {\n  const needle = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.mergeArrays)(dash, (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.stringToArray)(boundary));\n  const it = new _search_js__WEBPACK_IMPORTED_MODULE_0__.ReadableStreamSearch(needle, body)[Symbol.asyncIterator]();\n  for (;;) {\n    const result = await it.next();\n    if (result.done) {\n      return;\n    }\n    if (result.value === _search_js__WEBPACK_IMPORTED_MODULE_0__.MATCH) {\n      break;\n    }\n  }\n  const crlfSearch = new _search_js__WEBPACK_IMPORTED_MODULE_0__.StreamSearch(CRLF);\n  for (;;) {\n    const [headerLines, tail] = await readHeaderLines(it, needle);\n    if (!headerLines) {\n      return;\n    }\n    async function nextToken() {\n      const result = await it.next();\n      if (result.done) {\n        throw new Error('malformed multipart-form data: unexpected end of stream');\n      }\n      return result;\n    }\n    let trailingCRLF = false;\n    function feedChunk(chunk) {\n      const chunks = [];\n      for (const token of crlfSearch.feed(chunk)) {\n        if (trailingCRLF) {\n          chunks.push(CRLF);\n        }\n        if (!(trailingCRLF = token === _search_js__WEBPACK_IMPORTED_MODULE_0__.MATCH)) {\n          chunks.push(token);\n        }\n      }\n      return (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.mergeArrays)(...chunks);\n    }\n    let done = false;\n    async function nextChunk() {\n      const result = await nextToken();\n      let chunk;\n      if (result.value !== _search_js__WEBPACK_IMPORTED_MODULE_0__.MATCH) {\n        chunk = result.value;\n      } else if (!trailingCRLF) {\n        chunk = CRLF;\n      } else {\n        done = true;\n        return { value: crlfSearch.end() };\n      }\n      return { value: feedChunk(chunk) };\n    }\n    const bufferedChunks = [{ value: feedChunk(tail) }];\n    yield {\n      ...parsePartHeaders(headerLines),\n      data: {\n        [Symbol.asyncIterator]() {\n          return this;\n        },\n        async next() {\n          for (;;) {\n            const result = bufferedChunks.shift();\n            if (!result) {\n              break;\n            }\n            if (result.value.length > 0) {\n              return result;\n            }\n          }\n          for (;;) {\n            if (done) {\n              return {\n                done,\n                value: undefined\n              };\n            }\n            const result = await nextChunk();\n            if (result.value.length > 0) {\n              return result;\n            }\n          }\n        }\n      }\n    };\n    while (!done) {\n      bufferedChunks.push(await nextChunk());\n    }\n  }\n}\nasync function* iterateMultipart(body, boundary) {\n  for await (const part of streamMultipart(body, boundary)) {\n    const chunks = [];\n    for await (const chunk of part.data) {\n      chunks.push(chunk);\n    }\n    yield {\n      ...part,\n      data: (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.mergeArrays)(...chunks)\n    };\n  }\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQHdlYjMtc3RvcmFnZS9tdWx0aXBhcnQtcGFyc2VyL2VzbS9zcmMvaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUlxQjtBQU1EO0FBQ3BCLG1EQUFtRCxrREFBVztBQUM5RCxhQUFhLHdEQUFhO0FBQzFCLGFBQWEsd0RBQWE7QUFDMUI7QUFDQSwrQkFBK0I7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLG9EQUFZO0FBQ3JDLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1Qyw2Q0FBSyxJQUFJLHNEQUFXO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5Qiw2Q0FBSztBQUM5QjtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyw2Q0FBSztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0RUFBNEUsb0RBQWE7QUFDekYsVUFBVSxzREFBVywrQ0FBK0MsNkNBQUs7QUFDekU7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1AsaUJBQWlCLHNEQUFXLE9BQU8sd0RBQWE7QUFDaEQsaUJBQWlCLDREQUFvQjtBQUNyQyxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsNkNBQUs7QUFDOUI7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLG9EQUFZO0FBQ3JDLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsNkNBQUs7QUFDNUM7QUFDQTtBQUNBO0FBQ0EsYUFBYSxzREFBVztBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLDZDQUFLO0FBQ2hDO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0EsZUFBZTtBQUNmO0FBQ0EsOEJBQThCLHdCQUF3QjtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxzREFBVztBQUN2QjtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIi9ob21lL2FsdGNvaW4tZGFkZHkvRG93bmxvYWRzL293bmx5L25vZGVfbW9kdWxlcy9Ad2ViMy1zdG9yYWdlL211bHRpcGFydC1wYXJzZXIvZXNtL3NyYy9pbmRleC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge1xuICBSZWFkYWJsZVN0cmVhbVNlYXJjaCxcbiAgU3RyZWFtU2VhcmNoLFxuICBNQVRDSFxufSBmcm9tICcuL3NlYXJjaC5qcyc7XG5pbXBvcnQge1xuICBhcnJheXNFcXVhbCxcbiAgc3RyaW5nVG9BcnJheSxcbiAgYXJyYXlUb1N0cmluZyxcbiAgbWVyZ2VBcnJheXNcbn0gZnJvbSAnLi91dGlscy5qcyc7XG5jb25zdCBtZXJnZUFycmF5czIgPSBGdW5jdGlvbi5wcm90b3R5cGUuYXBwbHkuYmluZChtZXJnZUFycmF5cywgdW5kZWZpbmVkKTtcbmNvbnN0IGRhc2ggPSBzdHJpbmdUb0FycmF5KCctLScpO1xuY29uc3QgQ1JMRiA9IHN0cmluZ1RvQXJyYXkoJ1xcclxcbicpO1xuZnVuY3Rpb24gcGFyc2VDb250ZW50RGlzcG9zaXRpb24oaGVhZGVyKSB7XG4gIGNvbnN0IHBhcnRzID0gaGVhZGVyLnNwbGl0KCc7JykubWFwKHBhcnQgPT4gcGFydC50cmltKCkpO1xuICBpZiAocGFydHMuc2hpZnQoKSAhPT0gJ2Zvcm0tZGF0YScpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ21hbGZvcm1lZCBjb250ZW50LWRpc3Bvc2l0aW9uIGhlYWRlcjogbWlzc2luZyBcImZvcm0tZGF0YVwiIGluIGAnICsgSlNPTi5zdHJpbmdpZnkocGFydHMpICsgJ2AnKTtcbiAgfVxuICBjb25zdCBvdXQgPSB7fTtcbiAgZm9yIChjb25zdCBwYXJ0IG9mIHBhcnRzKSB7XG4gICAgY29uc3Qga3YgPSBwYXJ0LnNwbGl0KCc9JywgMik7XG4gICAgaWYgKGt2Lmxlbmd0aCAhPT0gMikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdtYWxmb3JtZWQgY29udGVudC1kaXNwb3NpdGlvbiBoZWFkZXI6IGtleS12YWx1ZSBwYWlyIG5vdCBmb3VuZCAtICcgKyBwYXJ0ICsgJyBpbiBgJyArIGhlYWRlciArICdgJyk7XG4gICAgfVxuICAgIGNvbnN0IFtuYW1lLCB2YWx1ZV0gPSBrdjtcbiAgICBpZiAodmFsdWVbMF0gPT09ICdcIicgJiYgdmFsdWVbdmFsdWUubGVuZ3RoIC0gMV0gPT09ICdcIicpIHtcbiAgICAgIG91dFtuYW1lXSA9IHZhbHVlLnNsaWNlKDEsIC0xKS5yZXBsYWNlKC9cXFxcXCIvZywgJ1wiJyk7XG4gICAgfSBlbHNlIGlmICh2YWx1ZVswXSAhPT0gJ1wiJyAmJiB2YWx1ZVt2YWx1ZS5sZW5ndGggLSAxXSAhPT0gJ1wiJykge1xuICAgICAgb3V0W25hbWVdID0gdmFsdWU7XG4gICAgfSBlbHNlIGlmICh2YWx1ZVswXSA9PT0gJ1wiJyAmJiB2YWx1ZVt2YWx1ZS5sZW5ndGggLSAxXSAhPT0gJ1wiJyB8fCB2YWx1ZVswXSAhPT0gJ1wiJyAmJiB2YWx1ZVt2YWx1ZS5sZW5ndGggLSAxXSA9PT0gJ1wiJykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdtYWxmb3JtZWQgY29udGVudC1kaXNwb3NpdGlvbiBoZWFkZXI6IG1pc21hdGNoZWQgcXVvdGF0aW9ucyBpbiBgJyArIGhlYWRlciArICdgJyk7XG4gICAgfVxuICB9XG4gIGlmICghb3V0Lm5hbWUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ21hbGZvcm1lZCBjb250ZW50LWRpc3Bvc2l0aW9uIGhlYWRlcjogbWlzc2luZyBmaWVsZCBuYW1lIGluIGAnICsgaGVhZGVyICsgJ2AnKTtcbiAgfVxuICByZXR1cm4gb3V0O1xufVxuZnVuY3Rpb24gcGFyc2VQYXJ0SGVhZGVycyhsaW5lcykge1xuICBjb25zdCBlbnRyaWVzID0gW107XG4gIGxldCBkaXNwb3NpdGlvbiA9IGZhbHNlO1xuICBsZXQgbGluZTtcbiAgd2hpbGUgKHR5cGVvZiAobGluZSA9IGxpbmVzLnNoaWZ0KCkpICE9PSAndW5kZWZpbmVkJykge1xuICAgIGNvbnN0IGNvbG9uID0gbGluZS5pbmRleE9mKCc6Jyk7XG4gICAgaWYgKGNvbG9uID09PSAtMSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdtYWxmb3JtZWQgbXVsdGlwYXJ0LWZvcm0gaGVhZGVyOiBtaXNzaW5nIGNvbG9uJyk7XG4gICAgfVxuICAgIGNvbnN0IGhlYWRlciA9IGxpbmUuc2xpY2UoMCwgY29sb24pLnRyaW0oKS50b0xvd2VyQ2FzZSgpO1xuICAgIGNvbnN0IHZhbHVlID0gbGluZS5zbGljZShjb2xvbiArIDEpLnRyaW0oKTtcbiAgICBzd2l0Y2ggKGhlYWRlcikge1xuICAgIGNhc2UgJ2NvbnRlbnQtZGlzcG9zaXRpb24nOlxuICAgICAgZGlzcG9zaXRpb24gPSB0cnVlO1xuICAgICAgZW50cmllcy5wdXNoKC4uLk9iamVjdC5lbnRyaWVzKHBhcnNlQ29udGVudERpc3Bvc2l0aW9uKHZhbHVlKSkpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnY29udGVudC10eXBlJzpcbiAgICAgIGVudHJpZXMucHVzaChbXG4gICAgICAgICdjb250ZW50VHlwZScsXG4gICAgICAgIHZhbHVlXG4gICAgICBdKTtcbiAgICB9XG4gIH1cbiAgaWYgKCFkaXNwb3NpdGlvbikge1xuICAgIHRocm93IG5ldyBFcnJvcignbWFsZm9ybWVkIG11bHRpcGFydC1mb3JtIGhlYWRlcjogbWlzc2luZyBjb250ZW50LWRpc3Bvc2l0aW9uJyk7XG4gIH1cbiAgcmV0dXJuIE9iamVjdC5mcm9tRW50cmllcyhlbnRyaWVzKTtcbn1cbmFzeW5jIGZ1bmN0aW9uIHJlYWRIZWFkZXJMaW5lcyhpdCwgbmVlZGxlKSB7XG4gIGxldCBmaXJzdENodW5rID0gdHJ1ZTtcbiAgbGV0IGxhc3RUb2tlbldhc01hdGNoID0gZmFsc2U7XG4gIGNvbnN0IGhlYWRlckxpbmVzID0gW1tdXTtcbiAgY29uc3QgY3JsZlNlYXJjaCA9IG5ldyBTdHJlYW1TZWFyY2goQ1JMRik7XG4gIGZvciAoOzspIHtcbiAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBpdC5uZXh0KCk7XG4gICAgaWYgKHJlc3VsdC5kb25lKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ21hbGZvcm1lZCBtdWx0aXBhcnQtZm9ybSBkYXRhOiB1bmV4cGVjdGVkIGVuZCBvZiBzdHJlYW0nKTtcbiAgICB9XG4gICAgaWYgKGZpcnN0Q2h1bmsgJiYgcmVzdWx0LnZhbHVlICE9PSBNQVRDSCAmJiBhcnJheXNFcXVhbChyZXN1bHQudmFsdWUuc2xpY2UoMCwgMiksIGRhc2gpKSB7XG4gICAgICByZXR1cm4gW1xuICAgICAgICB1bmRlZmluZWQsXG4gICAgICAgIG5ldyBVaW50OEFycmF5KClcbiAgICAgIF07XG4gICAgfVxuICAgIGxldCBjaHVuaztcbiAgICBpZiAocmVzdWx0LnZhbHVlICE9PSBNQVRDSCkge1xuICAgICAgY2h1bmsgPSByZXN1bHQudmFsdWU7XG4gICAgfSBlbHNlIGlmICghbGFzdFRva2VuV2FzTWF0Y2gpIHtcbiAgICAgIGNodW5rID0gbmVlZGxlO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ21hbGZvcm1lZCBtdWx0aXBhcnQtZm9ybSBkYXRhOiB1bmV4cGVjdGVkIGJvdW5kYXJ5Jyk7XG4gICAgfVxuICAgIGlmICghY2h1bmsubGVuZ3RoKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgaWYgKGZpcnN0Q2h1bmspIHtcbiAgICAgIGZpcnN0Q2h1bmsgPSBmYWxzZTtcbiAgICB9XG4gICAgY29uc3QgdG9rZW5zID0gY3JsZlNlYXJjaC5mZWVkKGNodW5rKTtcbiAgICBmb3IgKGNvbnN0IFtpLCB0b2tlbl0gb2YgdG9rZW5zLmVudHJpZXMoKSkge1xuICAgICAgY29uc3QgaXNNYXRjaCA9IHRva2VuID09PSBNQVRDSDtcbiAgICAgIGlmICghaXNNYXRjaCAmJiAhdG9rZW4ubGVuZ3RoKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgaWYgKGxhc3RUb2tlbldhc01hdGNoICYmIGlzTWF0Y2gpIHtcbiAgICAgICAgdG9rZW5zLnB1c2goY3JsZlNlYXJjaC5lbmQoKSk7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgaGVhZGVyTGluZXMuZmlsdGVyKGNodW5rcyA9PiBjaHVua3MubGVuZ3RoKS5tYXAobWVyZ2VBcnJheXMyKS5tYXAoYXJyYXlUb1N0cmluZyksXG4gICAgICAgICAgbWVyZ2VBcnJheXMoLi4udG9rZW5zLnNsaWNlKGkgKyAxKS5tYXAodG9rZW4gPT4gdG9rZW4gPT09IE1BVENIID8gQ1JMRiA6IHRva2VuKSlcbiAgICAgICAgXTtcbiAgICAgIH1cbiAgICAgIGlmIChsYXN0VG9rZW5XYXNNYXRjaCA9IGlzTWF0Y2gpIHtcbiAgICAgICAgaGVhZGVyTGluZXMucHVzaChbXSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBoZWFkZXJMaW5lc1toZWFkZXJMaW5lcy5sZW5ndGggLSAxXS5wdXNoKHRva2VuKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiogc3RyZWFtTXVsdGlwYXJ0KGJvZHksIGJvdW5kYXJ5KSB7XG4gIGNvbnN0IG5lZWRsZSA9IG1lcmdlQXJyYXlzKGRhc2gsIHN0cmluZ1RvQXJyYXkoYm91bmRhcnkpKTtcbiAgY29uc3QgaXQgPSBuZXcgUmVhZGFibGVTdHJlYW1TZWFyY2gobmVlZGxlLCBib2R5KVtTeW1ib2wuYXN5bmNJdGVyYXRvcl0oKTtcbiAgZm9yICg7Oykge1xuICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGl0Lm5leHQoKTtcbiAgICBpZiAocmVzdWx0LmRvbmUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHJlc3VsdC52YWx1ZSA9PT0gTUFUQ0gpIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuICBjb25zdCBjcmxmU2VhcmNoID0gbmV3IFN0cmVhbVNlYXJjaChDUkxGKTtcbiAgZm9yICg7Oykge1xuICAgIGNvbnN0IFtoZWFkZXJMaW5lcywgdGFpbF0gPSBhd2FpdCByZWFkSGVhZGVyTGluZXMoaXQsIG5lZWRsZSk7XG4gICAgaWYgKCFoZWFkZXJMaW5lcykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBhc3luYyBmdW5jdGlvbiBuZXh0VG9rZW4oKSB7XG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBpdC5uZXh0KCk7XG4gICAgICBpZiAocmVzdWx0LmRvbmUpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdtYWxmb3JtZWQgbXVsdGlwYXJ0LWZvcm0gZGF0YTogdW5leHBlY3RlZCBlbmQgb2Ygc3RyZWFtJyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICBsZXQgdHJhaWxpbmdDUkxGID0gZmFsc2U7XG4gICAgZnVuY3Rpb24gZmVlZENodW5rKGNodW5rKSB7XG4gICAgICBjb25zdCBjaHVua3MgPSBbXTtcbiAgICAgIGZvciAoY29uc3QgdG9rZW4gb2YgY3JsZlNlYXJjaC5mZWVkKGNodW5rKSkge1xuICAgICAgICBpZiAodHJhaWxpbmdDUkxGKSB7XG4gICAgICAgICAgY2h1bmtzLnB1c2goQ1JMRik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCEodHJhaWxpbmdDUkxGID0gdG9rZW4gPT09IE1BVENIKSkge1xuICAgICAgICAgIGNodW5rcy5wdXNoKHRva2VuKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIG1lcmdlQXJyYXlzKC4uLmNodW5rcyk7XG4gICAgfVxuICAgIGxldCBkb25lID0gZmFsc2U7XG4gICAgYXN5bmMgZnVuY3Rpb24gbmV4dENodW5rKCkge1xuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgbmV4dFRva2VuKCk7XG4gICAgICBsZXQgY2h1bms7XG4gICAgICBpZiAocmVzdWx0LnZhbHVlICE9PSBNQVRDSCkge1xuICAgICAgICBjaHVuayA9IHJlc3VsdC52YWx1ZTtcbiAgICAgIH0gZWxzZSBpZiAoIXRyYWlsaW5nQ1JMRikge1xuICAgICAgICBjaHVuayA9IENSTEY7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkb25lID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIHsgdmFsdWU6IGNybGZTZWFyY2guZW5kKCkgfTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB7IHZhbHVlOiBmZWVkQ2h1bmsoY2h1bmspIH07XG4gICAgfVxuICAgIGNvbnN0IGJ1ZmZlcmVkQ2h1bmtzID0gW3sgdmFsdWU6IGZlZWRDaHVuayh0YWlsKSB9XTtcbiAgICB5aWVsZCB7XG4gICAgICAuLi5wYXJzZVBhcnRIZWFkZXJzKGhlYWRlckxpbmVzKSxcbiAgICAgIGRhdGE6IHtcbiAgICAgICAgW1N5bWJvbC5hc3luY0l0ZXJhdG9yXSgpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSxcbiAgICAgICAgYXN5bmMgbmV4dCgpIHtcbiAgICAgICAgICBmb3IgKDs7KSB7XG4gICAgICAgICAgICBjb25zdCByZXN1bHQgPSBidWZmZXJlZENodW5rcy5zaGlmdCgpO1xuICAgICAgICAgICAgaWYgKCFyZXN1bHQpIHtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocmVzdWx0LnZhbHVlLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgZm9yICg7Oykge1xuICAgICAgICAgICAgaWYgKGRvbmUpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBkb25lLFxuICAgICAgICAgICAgICAgIHZhbHVlOiB1bmRlZmluZWRcbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IG5leHRDaHVuaygpO1xuICAgICAgICAgICAgaWYgKHJlc3VsdC52YWx1ZS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcbiAgICB3aGlsZSAoIWRvbmUpIHtcbiAgICAgIGJ1ZmZlcmVkQ2h1bmtzLnB1c2goYXdhaXQgbmV4dENodW5rKCkpO1xuICAgIH1cbiAgfVxufVxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uKiBpdGVyYXRlTXVsdGlwYXJ0KGJvZHksIGJvdW5kYXJ5KSB7XG4gIGZvciBhd2FpdCAoY29uc3QgcGFydCBvZiBzdHJlYW1NdWx0aXBhcnQoYm9keSwgYm91bmRhcnkpKSB7XG4gICAgY29uc3QgY2h1bmtzID0gW107XG4gICAgZm9yIGF3YWl0IChjb25zdCBjaHVuayBvZiBwYXJ0LmRhdGEpIHtcbiAgICAgIGNodW5rcy5wdXNoKGNodW5rKTtcbiAgICB9XG4gICAgeWllbGQge1xuICAgICAgLi4ucGFydCxcbiAgICAgIGRhdGE6IG1lcmdlQXJyYXlzKC4uLmNodW5rcylcbiAgICB9O1xuICB9XG59Il0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@web3-storage/multipart-parser/esm/src/index.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@web3-storage/multipart-parser/esm/src/search.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@web3-storage/multipart-parser/esm/src/search.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   MATCH: () => (/* binding */ MATCH),\n/* harmony export */   QueueableStreamSearch: () => (/* binding */ QueueableStreamSearch),\n/* harmony export */   ReadableStreamSearch: () => (/* binding */ ReadableStreamSearch),\n/* harmony export */   StreamSearch: () => (/* binding */ StreamSearch),\n/* harmony export */   allStrings: () => (/* binding */ allStrings),\n/* harmony export */   arrayIterator: () => (/* binding */ arrayIterator),\n/* harmony export */   chunksIterator: () => (/* binding */ chunksIterator),\n/* harmony export */   split: () => (/* binding */ split),\n/* harmony export */   splitChunks: () => (/* binding */ splitChunks),\n/* harmony export */   stringIterator: () => (/* binding */ stringIterator)\n/* harmony export */ });\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils.js */ \"(rsc)/./node_modules/@web3-storage/multipart-parser/esm/src/utils.js\");\n\nfunction coerce(a) {\n  if (a instanceof Uint8Array) {\n    return index => a[index];\n  }\n  return a;\n}\nfunction jsmemcmp(buf1, pos1, buf2, pos2, len) {\n  const fn1 = coerce(buf1);\n  const fn2 = coerce(buf2);\n  for (let i = 0; i < len; ++i) {\n    if (fn1(pos1 + i) !== fn2(pos2 + i)) {\n      return false;\n    }\n  }\n  return true;\n}\nfunction createOccurenceTable(s) {\n  const table = new Array(256).fill(s.length);\n  if (s.length > 1) {\n    for (let i = 0; i < s.length - 1; i++) {\n      table[s[i]] = s.length - 1 - i;\n    }\n  }\n  return table;\n}\nconst MATCH = Symbol('Match');\nclass StreamSearch {\n  constructor(needle) {\n    this._lookbehind = new Uint8Array();\n    if (typeof needle === 'string') {\n      this._needle = needle = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.stringToArray)(needle);\n    } else {\n      this._needle = needle;\n    }\n    this._lastChar = needle[needle.length - 1];\n    this._occ = createOccurenceTable(needle);\n  }\n  feed(chunk) {\n    let pos = 0;\n    let tokens;\n    const allTokens = [];\n    while (pos !== chunk.length) {\n      ;\n      [pos, ...tokens] = this._feed(chunk, pos);\n      allTokens.push(...tokens);\n    }\n    return allTokens;\n  }\n  end() {\n    const tail = this._lookbehind;\n    this._lookbehind = new Uint8Array();\n    return tail;\n  }\n  _feed(data, bufPos) {\n    const tokens = [];\n    let pos = -this._lookbehind.length;\n    if (pos < 0) {\n      while (pos < 0 && pos <= data.length - this._needle.length) {\n        const ch = this._charAt(data, pos + this._needle.length - 1);\n        if (ch === this._lastChar && this._memcmp(data, pos, this._needle.length - 1)) {\n          if (pos > -this._lookbehind.length) {\n            tokens.push(this._lookbehind.slice(0, this._lookbehind.length + pos));\n          }\n          tokens.push(MATCH);\n          this._lookbehind = new Uint8Array();\n          return [\n            pos + this._needle.length,\n            ...tokens\n          ];\n        } else {\n          pos += this._occ[ch];\n        }\n      }\n      if (pos < 0) {\n        while (pos < 0 && !this._memcmp(data, pos, data.length - pos)) {\n          pos++;\n        }\n      }\n      if (pos >= 0) {\n        tokens.push(this._lookbehind);\n        this._lookbehind = new Uint8Array();\n      } else {\n        const bytesToCutOff = this._lookbehind.length + pos;\n        if (bytesToCutOff > 0) {\n          tokens.push(this._lookbehind.slice(0, bytesToCutOff));\n          this._lookbehind = this._lookbehind.slice(bytesToCutOff);\n        }\n        this._lookbehind = Uint8Array.from(new Array(this._lookbehind.length + data.length), (_, i) => this._charAt(data, i - this._lookbehind.length));\n        return [\n          data.length,\n          ...tokens\n        ];\n      }\n    }\n    pos += bufPos;\n    while (pos <= data.length - this._needle.length) {\n      const ch = data[pos + this._needle.length - 1];\n      if (ch === this._lastChar && data[pos] === this._needle[0] && jsmemcmp(this._needle, 0, data, pos, this._needle.length - 1)) {\n        if (pos > bufPos) {\n          tokens.push(data.slice(bufPos, pos));\n        }\n        tokens.push(MATCH);\n        return [\n          pos + this._needle.length,\n          ...tokens\n        ];\n      } else {\n        pos += this._occ[ch];\n      }\n    }\n    if (pos < data.length) {\n      while (pos < data.length && (data[pos] !== this._needle[0] || !jsmemcmp(data, pos, this._needle, 0, data.length - pos))) {\n        ++pos;\n      }\n      if (pos < data.length) {\n        this._lookbehind = data.slice(pos);\n      }\n    }\n    if (pos > 0) {\n      tokens.push(data.slice(bufPos, pos < data.length ? pos : data.length));\n    }\n    return [\n      data.length,\n      ...tokens\n    ];\n  }\n  _charAt(data, pos) {\n    if (pos < 0) {\n      return this._lookbehind[this._lookbehind.length + pos];\n    }\n    return data[pos];\n  }\n  _memcmp(data, pos, len) {\n    return jsmemcmp(this._charAt.bind(this, data), pos, this._needle, 0, len);\n  }\n}\nclass ReadableStreamSearch {\n  constructor(needle, _readableStream) {\n    this._readableStream = _readableStream;\n    this._search = new StreamSearch(needle);\n  }\n  async *[Symbol.asyncIterator]() {\n    const reader = this._readableStream.getReader();\n    try {\n      while (true) {\n        const result = await reader.read();\n        if (result.done) {\n          break;\n        }\n        yield* this._search.feed(result.value);\n      }\n      const tail = this._search.end();\n      if (tail.length) {\n        yield tail;\n      }\n    } finally {\n      reader.releaseLock();\n    }\n  }\n}\nconst EOQ = Symbol('End of Queue');\nclass QueueableStreamSearch {\n  constructor(needle) {\n    this._chunksQueue = [];\n    this._closed = false;\n    this._search = new StreamSearch(needle);\n  }\n  push(...chunks) {\n    if (this._closed) {\n      throw new Error('cannot call push after close');\n    }\n    this._chunksQueue.push(...chunks);\n    if (this._notify) {\n      this._notify();\n    }\n  }\n  close() {\n    if (this._closed) {\n      throw new Error('close was already called');\n    }\n    this._closed = true;\n    this._chunksQueue.push(EOQ);\n    if (this._notify) {\n      this._notify();\n    }\n  }\n  async *[Symbol.asyncIterator]() {\n    while (true) {\n      let chunk;\n      while (!(chunk = this._chunksQueue.shift())) {\n        await new Promise(resolve => this._notify = resolve);\n        this._notify = undefined;\n      }\n      if (chunk === EOQ) {\n        break;\n      }\n      yield* this._search.feed(chunk);\n    }\n    const tail = this._search.end();\n    if (tail.length) {\n      yield tail;\n    }\n  }\n}\nfunction splitChunks(chunks, needle) {\n  const search = new StreamSearch(needle);\n  const outchunks = [[]];\n  for (const chunk of chunks) {\n    for (const token of search.feed(chunk)) {\n      if (token === MATCH) {\n        outchunks.push([]);\n      } else {\n        outchunks[outchunks.length - 1].push(token);\n      }\n    }\n  }\n  const end = search.end();\n  outchunks[outchunks.length - 1].push(end);\n  return outchunks.map(chunks => (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.mergeArrays)(...chunks));\n}\nfunction split(buf, needle) {\n  return splitChunks([buf], needle);\n}\nasync function* chunksIterator(iter) {\n  let chunks = [];\n  for await (const value of iter) {\n    if (value === MATCH) {\n      yield chunks;\n      chunks = [];\n    } else {\n      chunks.push(value);\n    }\n  }\n  yield chunks;\n}\nasync function* stringIterator(iter) {\n  for await (const chunk of chunksIterator(iter)) {\n    yield chunk.map(_utils_js__WEBPACK_IMPORTED_MODULE_0__.arrayToString).join('');\n  }\n}\nasync function allStrings(iter) {\n  const segments = [];\n  for await (const value of stringIterator(iter)) {\n    segments.push(value);\n  }\n  return segments;\n}\nasync function* arrayIterator(iter) {\n  for await (const chunk of chunksIterator(iter)) {\n    yield (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.mergeArrays)(...chunk);\n  }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQHdlYjMtc3RvcmFnZS9tdWx0aXBhcnQtcGFyc2VyL2VzbS9zcmMvc2VhcmNoLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7O0FBSW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixTQUFTO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixrQkFBa0I7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsd0RBQWE7QUFDM0MsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsc0RBQVc7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isb0RBQWE7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsc0RBQVc7QUFDckI7QUFDQSIsInNvdXJjZXMiOlsiL2hvbWUvYWx0Y29pbi1kYWRkeS9Eb3dubG9hZHMvb3dubHkvbm9kZV9tb2R1bGVzL0B3ZWIzLXN0b3JhZ2UvbXVsdGlwYXJ0LXBhcnNlci9lc20vc3JjL3NlYXJjaC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge1xuICBzdHJpbmdUb0FycmF5LFxuICBtZXJnZUFycmF5cyxcbiAgYXJyYXlUb1N0cmluZ1xufSBmcm9tICcuL3V0aWxzLmpzJztcbmZ1bmN0aW9uIGNvZXJjZShhKSB7XG4gIGlmIChhIGluc3RhbmNlb2YgVWludDhBcnJheSkge1xuICAgIHJldHVybiBpbmRleCA9PiBhW2luZGV4XTtcbiAgfVxuICByZXR1cm4gYTtcbn1cbmZ1bmN0aW9uIGpzbWVtY21wKGJ1ZjEsIHBvczEsIGJ1ZjIsIHBvczIsIGxlbikge1xuICBjb25zdCBmbjEgPSBjb2VyY2UoYnVmMSk7XG4gIGNvbnN0IGZuMiA9IGNvZXJjZShidWYyKTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW47ICsraSkge1xuICAgIGlmIChmbjEocG9zMSArIGkpICE9PSBmbjIocG9zMiArIGkpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG4gIHJldHVybiB0cnVlO1xufVxuZnVuY3Rpb24gY3JlYXRlT2NjdXJlbmNlVGFibGUocykge1xuICBjb25zdCB0YWJsZSA9IG5ldyBBcnJheSgyNTYpLmZpbGwocy5sZW5ndGgpO1xuICBpZiAocy5sZW5ndGggPiAxKSB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzLmxlbmd0aCAtIDE7IGkrKykge1xuICAgICAgdGFibGVbc1tpXV0gPSBzLmxlbmd0aCAtIDEgLSBpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdGFibGU7XG59XG5jb25zdCBNQVRDSCA9IFN5bWJvbCgnTWF0Y2gnKTtcbmNsYXNzIFN0cmVhbVNlYXJjaCB7XG4gIGNvbnN0cnVjdG9yKG5lZWRsZSkge1xuICAgIHRoaXMuX2xvb2tiZWhpbmQgPSBuZXcgVWludDhBcnJheSgpO1xuICAgIGlmICh0eXBlb2YgbmVlZGxlID09PSAnc3RyaW5nJykge1xuICAgICAgdGhpcy5fbmVlZGxlID0gbmVlZGxlID0gc3RyaW5nVG9BcnJheShuZWVkbGUpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9uZWVkbGUgPSBuZWVkbGU7XG4gICAgfVxuICAgIHRoaXMuX2xhc3RDaGFyID0gbmVlZGxlW25lZWRsZS5sZW5ndGggLSAxXTtcbiAgICB0aGlzLl9vY2MgPSBjcmVhdGVPY2N1cmVuY2VUYWJsZShuZWVkbGUpO1xuICB9XG4gIGZlZWQoY2h1bmspIHtcbiAgICBsZXQgcG9zID0gMDtcbiAgICBsZXQgdG9rZW5zO1xuICAgIGNvbnN0IGFsbFRva2VucyA9IFtdO1xuICAgIHdoaWxlIChwb3MgIT09IGNodW5rLmxlbmd0aCkge1xuICAgICAgO1xuICAgICAgW3BvcywgLi4udG9rZW5zXSA9IHRoaXMuX2ZlZWQoY2h1bmssIHBvcyk7XG4gICAgICBhbGxUb2tlbnMucHVzaCguLi50b2tlbnMpO1xuICAgIH1cbiAgICByZXR1cm4gYWxsVG9rZW5zO1xuICB9XG4gIGVuZCgpIHtcbiAgICBjb25zdCB0YWlsID0gdGhpcy5fbG9va2JlaGluZDtcbiAgICB0aGlzLl9sb29rYmVoaW5kID0gbmV3IFVpbnQ4QXJyYXkoKTtcbiAgICByZXR1cm4gdGFpbDtcbiAgfVxuICBfZmVlZChkYXRhLCBidWZQb3MpIHtcbiAgICBjb25zdCB0b2tlbnMgPSBbXTtcbiAgICBsZXQgcG9zID0gLXRoaXMuX2xvb2tiZWhpbmQubGVuZ3RoO1xuICAgIGlmIChwb3MgPCAwKSB7XG4gICAgICB3aGlsZSAocG9zIDwgMCAmJiBwb3MgPD0gZGF0YS5sZW5ndGggLSB0aGlzLl9uZWVkbGUubGVuZ3RoKSB7XG4gICAgICAgIGNvbnN0IGNoID0gdGhpcy5fY2hhckF0KGRhdGEsIHBvcyArIHRoaXMuX25lZWRsZS5sZW5ndGggLSAxKTtcbiAgICAgICAgaWYgKGNoID09PSB0aGlzLl9sYXN0Q2hhciAmJiB0aGlzLl9tZW1jbXAoZGF0YSwgcG9zLCB0aGlzLl9uZWVkbGUubGVuZ3RoIC0gMSkpIHtcbiAgICAgICAgICBpZiAocG9zID4gLXRoaXMuX2xvb2tiZWhpbmQubGVuZ3RoKSB7XG4gICAgICAgICAgICB0b2tlbnMucHVzaCh0aGlzLl9sb29rYmVoaW5kLnNsaWNlKDAsIHRoaXMuX2xvb2tiZWhpbmQubGVuZ3RoICsgcG9zKSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRva2Vucy5wdXNoKE1BVENIKTtcbiAgICAgICAgICB0aGlzLl9sb29rYmVoaW5kID0gbmV3IFVpbnQ4QXJyYXkoKTtcbiAgICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgcG9zICsgdGhpcy5fbmVlZGxlLmxlbmd0aCxcbiAgICAgICAgICAgIC4uLnRva2Vuc1xuICAgICAgICAgIF07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcG9zICs9IHRoaXMuX29jY1tjaF07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChwb3MgPCAwKSB7XG4gICAgICAgIHdoaWxlIChwb3MgPCAwICYmICF0aGlzLl9tZW1jbXAoZGF0YSwgcG9zLCBkYXRhLmxlbmd0aCAtIHBvcykpIHtcbiAgICAgICAgICBwb3MrKztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKHBvcyA+PSAwKSB7XG4gICAgICAgIHRva2Vucy5wdXNoKHRoaXMuX2xvb2tiZWhpbmQpO1xuICAgICAgICB0aGlzLl9sb29rYmVoaW5kID0gbmV3IFVpbnQ4QXJyYXkoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IGJ5dGVzVG9DdXRPZmYgPSB0aGlzLl9sb29rYmVoaW5kLmxlbmd0aCArIHBvcztcbiAgICAgICAgaWYgKGJ5dGVzVG9DdXRPZmYgPiAwKSB7XG4gICAgICAgICAgdG9rZW5zLnB1c2godGhpcy5fbG9va2JlaGluZC5zbGljZSgwLCBieXRlc1RvQ3V0T2ZmKSk7XG4gICAgICAgICAgdGhpcy5fbG9va2JlaGluZCA9IHRoaXMuX2xvb2tiZWhpbmQuc2xpY2UoYnl0ZXNUb0N1dE9mZik7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fbG9va2JlaGluZCA9IFVpbnQ4QXJyYXkuZnJvbShuZXcgQXJyYXkodGhpcy5fbG9va2JlaGluZC5sZW5ndGggKyBkYXRhLmxlbmd0aCksIChfLCBpKSA9PiB0aGlzLl9jaGFyQXQoZGF0YSwgaSAtIHRoaXMuX2xvb2tiZWhpbmQubGVuZ3RoKSk7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgZGF0YS5sZW5ndGgsXG4gICAgICAgICAgLi4udG9rZW5zXG4gICAgICAgIF07XG4gICAgICB9XG4gICAgfVxuICAgIHBvcyArPSBidWZQb3M7XG4gICAgd2hpbGUgKHBvcyA8PSBkYXRhLmxlbmd0aCAtIHRoaXMuX25lZWRsZS5sZW5ndGgpIHtcbiAgICAgIGNvbnN0IGNoID0gZGF0YVtwb3MgKyB0aGlzLl9uZWVkbGUubGVuZ3RoIC0gMV07XG4gICAgICBpZiAoY2ggPT09IHRoaXMuX2xhc3RDaGFyICYmIGRhdGFbcG9zXSA9PT0gdGhpcy5fbmVlZGxlWzBdICYmIGpzbWVtY21wKHRoaXMuX25lZWRsZSwgMCwgZGF0YSwgcG9zLCB0aGlzLl9uZWVkbGUubGVuZ3RoIC0gMSkpIHtcbiAgICAgICAgaWYgKHBvcyA+IGJ1ZlBvcykge1xuICAgICAgICAgIHRva2Vucy5wdXNoKGRhdGEuc2xpY2UoYnVmUG9zLCBwb3MpKTtcbiAgICAgICAgfVxuICAgICAgICB0b2tlbnMucHVzaChNQVRDSCk7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgcG9zICsgdGhpcy5fbmVlZGxlLmxlbmd0aCxcbiAgICAgICAgICAuLi50b2tlbnNcbiAgICAgICAgXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHBvcyArPSB0aGlzLl9vY2NbY2hdO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAocG9zIDwgZGF0YS5sZW5ndGgpIHtcbiAgICAgIHdoaWxlIChwb3MgPCBkYXRhLmxlbmd0aCAmJiAoZGF0YVtwb3NdICE9PSB0aGlzLl9uZWVkbGVbMF0gfHwgIWpzbWVtY21wKGRhdGEsIHBvcywgdGhpcy5fbmVlZGxlLCAwLCBkYXRhLmxlbmd0aCAtIHBvcykpKSB7XG4gICAgICAgICsrcG9zO1xuICAgICAgfVxuICAgICAgaWYgKHBvcyA8IGRhdGEubGVuZ3RoKSB7XG4gICAgICAgIHRoaXMuX2xvb2tiZWhpbmQgPSBkYXRhLnNsaWNlKHBvcyk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChwb3MgPiAwKSB7XG4gICAgICB0b2tlbnMucHVzaChkYXRhLnNsaWNlKGJ1ZlBvcywgcG9zIDwgZGF0YS5sZW5ndGggPyBwb3MgOiBkYXRhLmxlbmd0aCkpO1xuICAgIH1cbiAgICByZXR1cm4gW1xuICAgICAgZGF0YS5sZW5ndGgsXG4gICAgICAuLi50b2tlbnNcbiAgICBdO1xuICB9XG4gIF9jaGFyQXQoZGF0YSwgcG9zKSB7XG4gICAgaWYgKHBvcyA8IDApIHtcbiAgICAgIHJldHVybiB0aGlzLl9sb29rYmVoaW5kW3RoaXMuX2xvb2tiZWhpbmQubGVuZ3RoICsgcG9zXTtcbiAgICB9XG4gICAgcmV0dXJuIGRhdGFbcG9zXTtcbiAgfVxuICBfbWVtY21wKGRhdGEsIHBvcywgbGVuKSB7XG4gICAgcmV0dXJuIGpzbWVtY21wKHRoaXMuX2NoYXJBdC5iaW5kKHRoaXMsIGRhdGEpLCBwb3MsIHRoaXMuX25lZWRsZSwgMCwgbGVuKTtcbiAgfVxufVxuY2xhc3MgUmVhZGFibGVTdHJlYW1TZWFyY2gge1xuICBjb25zdHJ1Y3RvcihuZWVkbGUsIF9yZWFkYWJsZVN0cmVhbSkge1xuICAgIHRoaXMuX3JlYWRhYmxlU3RyZWFtID0gX3JlYWRhYmxlU3RyZWFtO1xuICAgIHRoaXMuX3NlYXJjaCA9IG5ldyBTdHJlYW1TZWFyY2gobmVlZGxlKTtcbiAgfVxuICBhc3luYyAqW1N5bWJvbC5hc3luY0l0ZXJhdG9yXSgpIHtcbiAgICBjb25zdCByZWFkZXIgPSB0aGlzLl9yZWFkYWJsZVN0cmVhbS5nZXRSZWFkZXIoKTtcbiAgICB0cnkge1xuICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgcmVhZGVyLnJlYWQoKTtcbiAgICAgICAgaWYgKHJlc3VsdC5kb25lKSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgeWllbGQqIHRoaXMuX3NlYXJjaC5mZWVkKHJlc3VsdC52YWx1ZSk7XG4gICAgICB9XG4gICAgICBjb25zdCB0YWlsID0gdGhpcy5fc2VhcmNoLmVuZCgpO1xuICAgICAgaWYgKHRhaWwubGVuZ3RoKSB7XG4gICAgICAgIHlpZWxkIHRhaWw7XG4gICAgICB9XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIHJlYWRlci5yZWxlYXNlTG9jaygpO1xuICAgIH1cbiAgfVxufVxuY29uc3QgRU9RID0gU3ltYm9sKCdFbmQgb2YgUXVldWUnKTtcbmNsYXNzIFF1ZXVlYWJsZVN0cmVhbVNlYXJjaCB7XG4gIGNvbnN0cnVjdG9yKG5lZWRsZSkge1xuICAgIHRoaXMuX2NodW5rc1F1ZXVlID0gW107XG4gICAgdGhpcy5fY2xvc2VkID0gZmFsc2U7XG4gICAgdGhpcy5fc2VhcmNoID0gbmV3IFN0cmVhbVNlYXJjaChuZWVkbGUpO1xuICB9XG4gIHB1c2goLi4uY2h1bmtzKSB7XG4gICAgaWYgKHRoaXMuX2Nsb3NlZCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdjYW5ub3QgY2FsbCBwdXNoIGFmdGVyIGNsb3NlJyk7XG4gICAgfVxuICAgIHRoaXMuX2NodW5rc1F1ZXVlLnB1c2goLi4uY2h1bmtzKTtcbiAgICBpZiAodGhpcy5fbm90aWZ5KSB7XG4gICAgICB0aGlzLl9ub3RpZnkoKTtcbiAgICB9XG4gIH1cbiAgY2xvc2UoKSB7XG4gICAgaWYgKHRoaXMuX2Nsb3NlZCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdjbG9zZSB3YXMgYWxyZWFkeSBjYWxsZWQnKTtcbiAgICB9XG4gICAgdGhpcy5fY2xvc2VkID0gdHJ1ZTtcbiAgICB0aGlzLl9jaHVua3NRdWV1ZS5wdXNoKEVPUSk7XG4gICAgaWYgKHRoaXMuX25vdGlmeSkge1xuICAgICAgdGhpcy5fbm90aWZ5KCk7XG4gICAgfVxuICB9XG4gIGFzeW5jICpbU3ltYm9sLmFzeW5jSXRlcmF0b3JdKCkge1xuICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICBsZXQgY2h1bms7XG4gICAgICB3aGlsZSAoIShjaHVuayA9IHRoaXMuX2NodW5rc1F1ZXVlLnNoaWZ0KCkpKSB7XG4gICAgICAgIGF3YWl0IG5ldyBQcm9taXNlKHJlc29sdmUgPT4gdGhpcy5fbm90aWZ5ID0gcmVzb2x2ZSk7XG4gICAgICAgIHRoaXMuX25vdGlmeSA9IHVuZGVmaW5lZDtcbiAgICAgIH1cbiAgICAgIGlmIChjaHVuayA9PT0gRU9RKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgeWllbGQqIHRoaXMuX3NlYXJjaC5mZWVkKGNodW5rKTtcbiAgICB9XG4gICAgY29uc3QgdGFpbCA9IHRoaXMuX3NlYXJjaC5lbmQoKTtcbiAgICBpZiAodGFpbC5sZW5ndGgpIHtcbiAgICAgIHlpZWxkIHRhaWw7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBzcGxpdENodW5rcyhjaHVua3MsIG5lZWRsZSkge1xuICBjb25zdCBzZWFyY2ggPSBuZXcgU3RyZWFtU2VhcmNoKG5lZWRsZSk7XG4gIGNvbnN0IG91dGNodW5rcyA9IFtbXV07XG4gIGZvciAoY29uc3QgY2h1bmsgb2YgY2h1bmtzKSB7XG4gICAgZm9yIChjb25zdCB0b2tlbiBvZiBzZWFyY2guZmVlZChjaHVuaykpIHtcbiAgICAgIGlmICh0b2tlbiA9PT0gTUFUQ0gpIHtcbiAgICAgICAgb3V0Y2h1bmtzLnB1c2goW10pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgb3V0Y2h1bmtzW291dGNodW5rcy5sZW5ndGggLSAxXS5wdXNoKHRva2VuKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgY29uc3QgZW5kID0gc2VhcmNoLmVuZCgpO1xuICBvdXRjaHVua3Nbb3V0Y2h1bmtzLmxlbmd0aCAtIDFdLnB1c2goZW5kKTtcbiAgcmV0dXJuIG91dGNodW5rcy5tYXAoY2h1bmtzID0+IG1lcmdlQXJyYXlzKC4uLmNodW5rcykpO1xufVxuZnVuY3Rpb24gc3BsaXQoYnVmLCBuZWVkbGUpIHtcbiAgcmV0dXJuIHNwbGl0Q2h1bmtzKFtidWZdLCBuZWVkbGUpO1xufVxuYXN5bmMgZnVuY3Rpb24qIGNodW5rc0l0ZXJhdG9yKGl0ZXIpIHtcbiAgbGV0IGNodW5rcyA9IFtdO1xuICBmb3IgYXdhaXQgKGNvbnN0IHZhbHVlIG9mIGl0ZXIpIHtcbiAgICBpZiAodmFsdWUgPT09IE1BVENIKSB7XG4gICAgICB5aWVsZCBjaHVua3M7XG4gICAgICBjaHVua3MgPSBbXTtcbiAgICB9IGVsc2Uge1xuICAgICAgY2h1bmtzLnB1c2godmFsdWUpO1xuICAgIH1cbiAgfVxuICB5aWVsZCBjaHVua3M7XG59XG5hc3luYyBmdW5jdGlvbiogc3RyaW5nSXRlcmF0b3IoaXRlcikge1xuICBmb3IgYXdhaXQgKGNvbnN0IGNodW5rIG9mIGNodW5rc0l0ZXJhdG9yKGl0ZXIpKSB7XG4gICAgeWllbGQgY2h1bmsubWFwKGFycmF5VG9TdHJpbmcpLmpvaW4oJycpO1xuICB9XG59XG5hc3luYyBmdW5jdGlvbiBhbGxTdHJpbmdzKGl0ZXIpIHtcbiAgY29uc3Qgc2VnbWVudHMgPSBbXTtcbiAgZm9yIGF3YWl0IChjb25zdCB2YWx1ZSBvZiBzdHJpbmdJdGVyYXRvcihpdGVyKSkge1xuICAgIHNlZ21lbnRzLnB1c2godmFsdWUpO1xuICB9XG4gIHJldHVybiBzZWdtZW50cztcbn1cbmFzeW5jIGZ1bmN0aW9uKiBhcnJheUl0ZXJhdG9yKGl0ZXIpIHtcbiAgZm9yIGF3YWl0IChjb25zdCBjaHVuayBvZiBjaHVua3NJdGVyYXRvcihpdGVyKSkge1xuICAgIHlpZWxkIG1lcmdlQXJyYXlzKC4uLmNodW5rKTtcbiAgfVxufVxuZXhwb3J0IHtcbiAgTUFUQ0gsXG4gIFF1ZXVlYWJsZVN0cmVhbVNlYXJjaCxcbiAgUmVhZGFibGVTdHJlYW1TZWFyY2gsXG4gIFN0cmVhbVNlYXJjaCxcbiAgYWxsU3RyaW5ncyxcbiAgYXJyYXlJdGVyYXRvcixcbiAgY2h1bmtzSXRlcmF0b3IsXG4gIHNwbGl0LFxuICBzcGxpdENodW5rcyxcbiAgc3RyaW5nSXRlcmF0b3Jcbn07Il0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@web3-storage/multipart-parser/esm/src/search.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@web3-storage/multipart-parser/esm/src/utils.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@web3-storage/multipart-parser/esm/src/utils.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   arrayToString: () => (/* binding */ arrayToString),\n/* harmony export */   arraysEqual: () => (/* binding */ arraysEqual),\n/* harmony export */   mergeArrays: () => (/* binding */ mergeArrays),\n/* harmony export */   stringToArray: () => (/* binding */ stringToArray)\n/* harmony export */ });\nfunction stringToArray(s) {\n  const utf8 = unescape(encodeURIComponent(s));\n  return Uint8Array.from(utf8, (_, i) => utf8.charCodeAt(i));\n}\nfunction arrayToString(a) {\n  const utf8 = String.fromCharCode.apply(null, a);\n  return decodeURIComponent(escape(utf8));\n}\nfunction mergeArrays(...arrays) {\n  const out = new Uint8Array(arrays.reduce((total, arr) => total + arr.length, 0));\n  let offset = 0;\n  for (const arr of arrays) {\n    out.set(arr, offset);\n    offset += arr.length;\n  }\n  return out;\n}\nfunction arraysEqual(a, b) {\n  if (a.length !== b.length) {\n    return false;\n  }\n  for (let i = 0; i < a.length; i++) {\n    if (a[i] !== b[i]) {\n      return false;\n    }\n  }\n  return true;\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQHdlYjMtc3RvcmFnZS9tdWx0aXBhcnQtcGFyc2VyL2VzbS9zcmMvdXRpbHMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixjQUFjO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiL2hvbWUvYWx0Y29pbi1kYWRkeS9Eb3dubG9hZHMvb3dubHkvbm9kZV9tb2R1bGVzL0B3ZWIzLXN0b3JhZ2UvbXVsdGlwYXJ0LXBhcnNlci9lc20vc3JjL3V0aWxzLmpzIl0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCBmdW5jdGlvbiBzdHJpbmdUb0FycmF5KHMpIHtcbiAgY29uc3QgdXRmOCA9IHVuZXNjYXBlKGVuY29kZVVSSUNvbXBvbmVudChzKSk7XG4gIHJldHVybiBVaW50OEFycmF5LmZyb20odXRmOCwgKF8sIGkpID0+IHV0ZjguY2hhckNvZGVBdChpKSk7XG59XG5leHBvcnQgZnVuY3Rpb24gYXJyYXlUb1N0cmluZyhhKSB7XG4gIGNvbnN0IHV0ZjggPSBTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KG51bGwsIGEpO1xuICByZXR1cm4gZGVjb2RlVVJJQ29tcG9uZW50KGVzY2FwZSh1dGY4KSk7XG59XG5leHBvcnQgZnVuY3Rpb24gbWVyZ2VBcnJheXMoLi4uYXJyYXlzKSB7XG4gIGNvbnN0IG91dCA9IG5ldyBVaW50OEFycmF5KGFycmF5cy5yZWR1Y2UoKHRvdGFsLCBhcnIpID0+IHRvdGFsICsgYXJyLmxlbmd0aCwgMCkpO1xuICBsZXQgb2Zmc2V0ID0gMDtcbiAgZm9yIChjb25zdCBhcnIgb2YgYXJyYXlzKSB7XG4gICAgb3V0LnNldChhcnIsIG9mZnNldCk7XG4gICAgb2Zmc2V0ICs9IGFyci5sZW5ndGg7XG4gIH1cbiAgcmV0dXJuIG91dDtcbn1cbmV4cG9ydCBmdW5jdGlvbiBhcnJheXNFcXVhbChhLCBiKSB7XG4gIGlmIChhLmxlbmd0aCAhPT0gYi5sZW5ndGgpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBhLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKGFbaV0gIT09IGJbaV0pIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59Il0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@web3-storage/multipart-parser/esm/src/utils.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@web3-storage/multipart-parser/esm/src/index.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@web3-storage/multipart-parser/esm/src/index.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   iterateMultipart: () => (/* binding */ iterateMultipart),\n/* harmony export */   streamMultipart: () => (/* binding */ streamMultipart)\n/* harmony export */ });\n/* harmony import */ var _search_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./search.js */ \"(ssr)/./node_modules/@web3-storage/multipart-parser/esm/src/search.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils.js */ \"(ssr)/./node_modules/@web3-storage/multipart-parser/esm/src/utils.js\");\n\n\nconst mergeArrays2 = Function.prototype.apply.bind(_utils_js__WEBPACK_IMPORTED_MODULE_1__.mergeArrays, undefined);\nconst dash = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.stringToArray)('--');\nconst CRLF = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.stringToArray)('\\r\\n');\nfunction parseContentDisposition(header) {\n  const parts = header.split(';').map(part => part.trim());\n  if (parts.shift() !== 'form-data') {\n    throw new Error('malformed content-disposition header: missing \"form-data\" in `' + JSON.stringify(parts) + '`');\n  }\n  const out = {};\n  for (const part of parts) {\n    const kv = part.split('=', 2);\n    if (kv.length !== 2) {\n      throw new Error('malformed content-disposition header: key-value pair not found - ' + part + ' in `' + header + '`');\n    }\n    const [name, value] = kv;\n    if (value[0] === '\"' && value[value.length - 1] === '\"') {\n      out[name] = value.slice(1, -1).replace(/\\\\\"/g, '\"');\n    } else if (value[0] !== '\"' && value[value.length - 1] !== '\"') {\n      out[name] = value;\n    } else if (value[0] === '\"' && value[value.length - 1] !== '\"' || value[0] !== '\"' && value[value.length - 1] === '\"') {\n      throw new Error('malformed content-disposition header: mismatched quotations in `' + header + '`');\n    }\n  }\n  if (!out.name) {\n    throw new Error('malformed content-disposition header: missing field name in `' + header + '`');\n  }\n  return out;\n}\nfunction parsePartHeaders(lines) {\n  const entries = [];\n  let disposition = false;\n  let line;\n  while (typeof (line = lines.shift()) !== 'undefined') {\n    const colon = line.indexOf(':');\n    if (colon === -1) {\n      throw new Error('malformed multipart-form header: missing colon');\n    }\n    const header = line.slice(0, colon).trim().toLowerCase();\n    const value = line.slice(colon + 1).trim();\n    switch (header) {\n    case 'content-disposition':\n      disposition = true;\n      entries.push(...Object.entries(parseContentDisposition(value)));\n      break;\n    case 'content-type':\n      entries.push([\n        'contentType',\n        value\n      ]);\n    }\n  }\n  if (!disposition) {\n    throw new Error('malformed multipart-form header: missing content-disposition');\n  }\n  return Object.fromEntries(entries);\n}\nasync function readHeaderLines(it, needle) {\n  let firstChunk = true;\n  let lastTokenWasMatch = false;\n  const headerLines = [[]];\n  const crlfSearch = new _search_js__WEBPACK_IMPORTED_MODULE_0__.StreamSearch(CRLF);\n  for (;;) {\n    const result = await it.next();\n    if (result.done) {\n      throw new Error('malformed multipart-form data: unexpected end of stream');\n    }\n    if (firstChunk && result.value !== _search_js__WEBPACK_IMPORTED_MODULE_0__.MATCH && (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.arraysEqual)(result.value.slice(0, 2), dash)) {\n      return [\n        undefined,\n        new Uint8Array()\n      ];\n    }\n    let chunk;\n    if (result.value !== _search_js__WEBPACK_IMPORTED_MODULE_0__.MATCH) {\n      chunk = result.value;\n    } else if (!lastTokenWasMatch) {\n      chunk = needle;\n    } else {\n      throw new Error('malformed multipart-form data: unexpected boundary');\n    }\n    if (!chunk.length) {\n      continue;\n    }\n    if (firstChunk) {\n      firstChunk = false;\n    }\n    const tokens = crlfSearch.feed(chunk);\n    for (const [i, token] of tokens.entries()) {\n      const isMatch = token === _search_js__WEBPACK_IMPORTED_MODULE_0__.MATCH;\n      if (!isMatch && !token.length) {\n        continue;\n      }\n      if (lastTokenWasMatch && isMatch) {\n        tokens.push(crlfSearch.end());\n        return [\n          headerLines.filter(chunks => chunks.length).map(mergeArrays2).map(_utils_js__WEBPACK_IMPORTED_MODULE_1__.arrayToString),\n          (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.mergeArrays)(...tokens.slice(i + 1).map(token => token === _search_js__WEBPACK_IMPORTED_MODULE_0__.MATCH ? CRLF : token))\n        ];\n      }\n      if (lastTokenWasMatch = isMatch) {\n        headerLines.push([]);\n      } else {\n        headerLines[headerLines.length - 1].push(token);\n      }\n    }\n  }\n}\nasync function* streamMultipart(body, boundary) {\n  const needle = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.mergeArrays)(dash, (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.stringToArray)(boundary));\n  const it = new _search_js__WEBPACK_IMPORTED_MODULE_0__.ReadableStreamSearch(needle, body)[Symbol.asyncIterator]();\n  for (;;) {\n    const result = await it.next();\n    if (result.done) {\n      return;\n    }\n    if (result.value === _search_js__WEBPACK_IMPORTED_MODULE_0__.MATCH) {\n      break;\n    }\n  }\n  const crlfSearch = new _search_js__WEBPACK_IMPORTED_MODULE_0__.StreamSearch(CRLF);\n  for (;;) {\n    const [headerLines, tail] = await readHeaderLines(it, needle);\n    if (!headerLines) {\n      return;\n    }\n    async function nextToken() {\n      const result = await it.next();\n      if (result.done) {\n        throw new Error('malformed multipart-form data: unexpected end of stream');\n      }\n      return result;\n    }\n    let trailingCRLF = false;\n    function feedChunk(chunk) {\n      const chunks = [];\n      for (const token of crlfSearch.feed(chunk)) {\n        if (trailingCRLF) {\n          chunks.push(CRLF);\n        }\n        if (!(trailingCRLF = token === _search_js__WEBPACK_IMPORTED_MODULE_0__.MATCH)) {\n          chunks.push(token);\n        }\n      }\n      return (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.mergeArrays)(...chunks);\n    }\n    let done = false;\n    async function nextChunk() {\n      const result = await nextToken();\n      let chunk;\n      if (result.value !== _search_js__WEBPACK_IMPORTED_MODULE_0__.MATCH) {\n        chunk = result.value;\n      } else if (!trailingCRLF) {\n        chunk = CRLF;\n      } else {\n        done = true;\n        return { value: crlfSearch.end() };\n      }\n      return { value: feedChunk(chunk) };\n    }\n    const bufferedChunks = [{ value: feedChunk(tail) }];\n    yield {\n      ...parsePartHeaders(headerLines),\n      data: {\n        [Symbol.asyncIterator]() {\n          return this;\n        },\n        async next() {\n          for (;;) {\n            const result = bufferedChunks.shift();\n            if (!result) {\n              break;\n            }\n            if (result.value.length > 0) {\n              return result;\n            }\n          }\n          for (;;) {\n            if (done) {\n              return {\n                done,\n                value: undefined\n              };\n            }\n            const result = await nextChunk();\n            if (result.value.length > 0) {\n              return result;\n            }\n          }\n        }\n      }\n    };\n    while (!done) {\n      bufferedChunks.push(await nextChunk());\n    }\n  }\n}\nasync function* iterateMultipart(body, boundary) {\n  for await (const part of streamMultipart(body, boundary)) {\n    const chunks = [];\n    for await (const chunk of part.data) {\n      chunks.push(chunk);\n    }\n    yield {\n      ...part,\n      data: (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.mergeArrays)(...chunks)\n    };\n  }\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHdlYjMtc3RvcmFnZS9tdWx0aXBhcnQtcGFyc2VyL2VzbS9zcmMvaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUlxQjtBQU1EO0FBQ3BCLG1EQUFtRCxrREFBVztBQUM5RCxhQUFhLHdEQUFhO0FBQzFCLGFBQWEsd0RBQWE7QUFDMUI7QUFDQSwrQkFBK0I7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLG9EQUFZO0FBQ3JDLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1Qyw2Q0FBSyxJQUFJLHNEQUFXO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5Qiw2Q0FBSztBQUM5QjtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyw2Q0FBSztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0RUFBNEUsb0RBQWE7QUFDekYsVUFBVSxzREFBVywrQ0FBK0MsNkNBQUs7QUFDekU7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1AsaUJBQWlCLHNEQUFXLE9BQU8sd0RBQWE7QUFDaEQsaUJBQWlCLDREQUFvQjtBQUNyQyxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsNkNBQUs7QUFDOUI7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLG9EQUFZO0FBQ3JDLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsNkNBQUs7QUFDNUM7QUFDQTtBQUNBO0FBQ0EsYUFBYSxzREFBVztBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLDZDQUFLO0FBQ2hDO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0EsZUFBZTtBQUNmO0FBQ0EsOEJBQThCLHdCQUF3QjtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxzREFBVztBQUN2QjtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIi9ob21lL2FsdGNvaW4tZGFkZHkvRG93bmxvYWRzL293bmx5L25vZGVfbW9kdWxlcy9Ad2ViMy1zdG9yYWdlL211bHRpcGFydC1wYXJzZXIvZXNtL3NyYy9pbmRleC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge1xuICBSZWFkYWJsZVN0cmVhbVNlYXJjaCxcbiAgU3RyZWFtU2VhcmNoLFxuICBNQVRDSFxufSBmcm9tICcuL3NlYXJjaC5qcyc7XG5pbXBvcnQge1xuICBhcnJheXNFcXVhbCxcbiAgc3RyaW5nVG9BcnJheSxcbiAgYXJyYXlUb1N0cmluZyxcbiAgbWVyZ2VBcnJheXNcbn0gZnJvbSAnLi91dGlscy5qcyc7XG5jb25zdCBtZXJnZUFycmF5czIgPSBGdW5jdGlvbi5wcm90b3R5cGUuYXBwbHkuYmluZChtZXJnZUFycmF5cywgdW5kZWZpbmVkKTtcbmNvbnN0IGRhc2ggPSBzdHJpbmdUb0FycmF5KCctLScpO1xuY29uc3QgQ1JMRiA9IHN0cmluZ1RvQXJyYXkoJ1xcclxcbicpO1xuZnVuY3Rpb24gcGFyc2VDb250ZW50RGlzcG9zaXRpb24oaGVhZGVyKSB7XG4gIGNvbnN0IHBhcnRzID0gaGVhZGVyLnNwbGl0KCc7JykubWFwKHBhcnQgPT4gcGFydC50cmltKCkpO1xuICBpZiAocGFydHMuc2hpZnQoKSAhPT0gJ2Zvcm0tZGF0YScpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ21hbGZvcm1lZCBjb250ZW50LWRpc3Bvc2l0aW9uIGhlYWRlcjogbWlzc2luZyBcImZvcm0tZGF0YVwiIGluIGAnICsgSlNPTi5zdHJpbmdpZnkocGFydHMpICsgJ2AnKTtcbiAgfVxuICBjb25zdCBvdXQgPSB7fTtcbiAgZm9yIChjb25zdCBwYXJ0IG9mIHBhcnRzKSB7XG4gICAgY29uc3Qga3YgPSBwYXJ0LnNwbGl0KCc9JywgMik7XG4gICAgaWYgKGt2Lmxlbmd0aCAhPT0gMikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdtYWxmb3JtZWQgY29udGVudC1kaXNwb3NpdGlvbiBoZWFkZXI6IGtleS12YWx1ZSBwYWlyIG5vdCBmb3VuZCAtICcgKyBwYXJ0ICsgJyBpbiBgJyArIGhlYWRlciArICdgJyk7XG4gICAgfVxuICAgIGNvbnN0IFtuYW1lLCB2YWx1ZV0gPSBrdjtcbiAgICBpZiAodmFsdWVbMF0gPT09ICdcIicgJiYgdmFsdWVbdmFsdWUubGVuZ3RoIC0gMV0gPT09ICdcIicpIHtcbiAgICAgIG91dFtuYW1lXSA9IHZhbHVlLnNsaWNlKDEsIC0xKS5yZXBsYWNlKC9cXFxcXCIvZywgJ1wiJyk7XG4gICAgfSBlbHNlIGlmICh2YWx1ZVswXSAhPT0gJ1wiJyAmJiB2YWx1ZVt2YWx1ZS5sZW5ndGggLSAxXSAhPT0gJ1wiJykge1xuICAgICAgb3V0W25hbWVdID0gdmFsdWU7XG4gICAgfSBlbHNlIGlmICh2YWx1ZVswXSA9PT0gJ1wiJyAmJiB2YWx1ZVt2YWx1ZS5sZW5ndGggLSAxXSAhPT0gJ1wiJyB8fCB2YWx1ZVswXSAhPT0gJ1wiJyAmJiB2YWx1ZVt2YWx1ZS5sZW5ndGggLSAxXSA9PT0gJ1wiJykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdtYWxmb3JtZWQgY29udGVudC1kaXNwb3NpdGlvbiBoZWFkZXI6IG1pc21hdGNoZWQgcXVvdGF0aW9ucyBpbiBgJyArIGhlYWRlciArICdgJyk7XG4gICAgfVxuICB9XG4gIGlmICghb3V0Lm5hbWUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ21hbGZvcm1lZCBjb250ZW50LWRpc3Bvc2l0aW9uIGhlYWRlcjogbWlzc2luZyBmaWVsZCBuYW1lIGluIGAnICsgaGVhZGVyICsgJ2AnKTtcbiAgfVxuICByZXR1cm4gb3V0O1xufVxuZnVuY3Rpb24gcGFyc2VQYXJ0SGVhZGVycyhsaW5lcykge1xuICBjb25zdCBlbnRyaWVzID0gW107XG4gIGxldCBkaXNwb3NpdGlvbiA9IGZhbHNlO1xuICBsZXQgbGluZTtcbiAgd2hpbGUgKHR5cGVvZiAobGluZSA9IGxpbmVzLnNoaWZ0KCkpICE9PSAndW5kZWZpbmVkJykge1xuICAgIGNvbnN0IGNvbG9uID0gbGluZS5pbmRleE9mKCc6Jyk7XG4gICAgaWYgKGNvbG9uID09PSAtMSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdtYWxmb3JtZWQgbXVsdGlwYXJ0LWZvcm0gaGVhZGVyOiBtaXNzaW5nIGNvbG9uJyk7XG4gICAgfVxuICAgIGNvbnN0IGhlYWRlciA9IGxpbmUuc2xpY2UoMCwgY29sb24pLnRyaW0oKS50b0xvd2VyQ2FzZSgpO1xuICAgIGNvbnN0IHZhbHVlID0gbGluZS5zbGljZShjb2xvbiArIDEpLnRyaW0oKTtcbiAgICBzd2l0Y2ggKGhlYWRlcikge1xuICAgIGNhc2UgJ2NvbnRlbnQtZGlzcG9zaXRpb24nOlxuICAgICAgZGlzcG9zaXRpb24gPSB0cnVlO1xuICAgICAgZW50cmllcy5wdXNoKC4uLk9iamVjdC5lbnRyaWVzKHBhcnNlQ29udGVudERpc3Bvc2l0aW9uKHZhbHVlKSkpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnY29udGVudC10eXBlJzpcbiAgICAgIGVudHJpZXMucHVzaChbXG4gICAgICAgICdjb250ZW50VHlwZScsXG4gICAgICAgIHZhbHVlXG4gICAgICBdKTtcbiAgICB9XG4gIH1cbiAgaWYgKCFkaXNwb3NpdGlvbikge1xuICAgIHRocm93IG5ldyBFcnJvcignbWFsZm9ybWVkIG11bHRpcGFydC1mb3JtIGhlYWRlcjogbWlzc2luZyBjb250ZW50LWRpc3Bvc2l0aW9uJyk7XG4gIH1cbiAgcmV0dXJuIE9iamVjdC5mcm9tRW50cmllcyhlbnRyaWVzKTtcbn1cbmFzeW5jIGZ1bmN0aW9uIHJlYWRIZWFkZXJMaW5lcyhpdCwgbmVlZGxlKSB7XG4gIGxldCBmaXJzdENodW5rID0gdHJ1ZTtcbiAgbGV0IGxhc3RUb2tlbldhc01hdGNoID0gZmFsc2U7XG4gIGNvbnN0IGhlYWRlckxpbmVzID0gW1tdXTtcbiAgY29uc3QgY3JsZlNlYXJjaCA9IG5ldyBTdHJlYW1TZWFyY2goQ1JMRik7XG4gIGZvciAoOzspIHtcbiAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBpdC5uZXh0KCk7XG4gICAgaWYgKHJlc3VsdC5kb25lKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ21hbGZvcm1lZCBtdWx0aXBhcnQtZm9ybSBkYXRhOiB1bmV4cGVjdGVkIGVuZCBvZiBzdHJlYW0nKTtcbiAgICB9XG4gICAgaWYgKGZpcnN0Q2h1bmsgJiYgcmVzdWx0LnZhbHVlICE9PSBNQVRDSCAmJiBhcnJheXNFcXVhbChyZXN1bHQudmFsdWUuc2xpY2UoMCwgMiksIGRhc2gpKSB7XG4gICAgICByZXR1cm4gW1xuICAgICAgICB1bmRlZmluZWQsXG4gICAgICAgIG5ldyBVaW50OEFycmF5KClcbiAgICAgIF07XG4gICAgfVxuICAgIGxldCBjaHVuaztcbiAgICBpZiAocmVzdWx0LnZhbHVlICE9PSBNQVRDSCkge1xuICAgICAgY2h1bmsgPSByZXN1bHQudmFsdWU7XG4gICAgfSBlbHNlIGlmICghbGFzdFRva2VuV2FzTWF0Y2gpIHtcbiAgICAgIGNodW5rID0gbmVlZGxlO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ21hbGZvcm1lZCBtdWx0aXBhcnQtZm9ybSBkYXRhOiB1bmV4cGVjdGVkIGJvdW5kYXJ5Jyk7XG4gICAgfVxuICAgIGlmICghY2h1bmsubGVuZ3RoKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgaWYgKGZpcnN0Q2h1bmspIHtcbiAgICAgIGZpcnN0Q2h1bmsgPSBmYWxzZTtcbiAgICB9XG4gICAgY29uc3QgdG9rZW5zID0gY3JsZlNlYXJjaC5mZWVkKGNodW5rKTtcbiAgICBmb3IgKGNvbnN0IFtpLCB0b2tlbl0gb2YgdG9rZW5zLmVudHJpZXMoKSkge1xuICAgICAgY29uc3QgaXNNYXRjaCA9IHRva2VuID09PSBNQVRDSDtcbiAgICAgIGlmICghaXNNYXRjaCAmJiAhdG9rZW4ubGVuZ3RoKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgaWYgKGxhc3RUb2tlbldhc01hdGNoICYmIGlzTWF0Y2gpIHtcbiAgICAgICAgdG9rZW5zLnB1c2goY3JsZlNlYXJjaC5lbmQoKSk7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgaGVhZGVyTGluZXMuZmlsdGVyKGNodW5rcyA9PiBjaHVua3MubGVuZ3RoKS5tYXAobWVyZ2VBcnJheXMyKS5tYXAoYXJyYXlUb1N0cmluZyksXG4gICAgICAgICAgbWVyZ2VBcnJheXMoLi4udG9rZW5zLnNsaWNlKGkgKyAxKS5tYXAodG9rZW4gPT4gdG9rZW4gPT09IE1BVENIID8gQ1JMRiA6IHRva2VuKSlcbiAgICAgICAgXTtcbiAgICAgIH1cbiAgICAgIGlmIChsYXN0VG9rZW5XYXNNYXRjaCA9IGlzTWF0Y2gpIHtcbiAgICAgICAgaGVhZGVyTGluZXMucHVzaChbXSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBoZWFkZXJMaW5lc1toZWFkZXJMaW5lcy5sZW5ndGggLSAxXS5wdXNoKHRva2VuKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiogc3RyZWFtTXVsdGlwYXJ0KGJvZHksIGJvdW5kYXJ5KSB7XG4gIGNvbnN0IG5lZWRsZSA9IG1lcmdlQXJyYXlzKGRhc2gsIHN0cmluZ1RvQXJyYXkoYm91bmRhcnkpKTtcbiAgY29uc3QgaXQgPSBuZXcgUmVhZGFibGVTdHJlYW1TZWFyY2gobmVlZGxlLCBib2R5KVtTeW1ib2wuYXN5bmNJdGVyYXRvcl0oKTtcbiAgZm9yICg7Oykge1xuICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGl0Lm5leHQoKTtcbiAgICBpZiAocmVzdWx0LmRvbmUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHJlc3VsdC52YWx1ZSA9PT0gTUFUQ0gpIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuICBjb25zdCBjcmxmU2VhcmNoID0gbmV3IFN0cmVhbVNlYXJjaChDUkxGKTtcbiAgZm9yICg7Oykge1xuICAgIGNvbnN0IFtoZWFkZXJMaW5lcywgdGFpbF0gPSBhd2FpdCByZWFkSGVhZGVyTGluZXMoaXQsIG5lZWRsZSk7XG4gICAgaWYgKCFoZWFkZXJMaW5lcykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBhc3luYyBmdW5jdGlvbiBuZXh0VG9rZW4oKSB7XG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBpdC5uZXh0KCk7XG4gICAgICBpZiAocmVzdWx0LmRvbmUpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdtYWxmb3JtZWQgbXVsdGlwYXJ0LWZvcm0gZGF0YTogdW5leHBlY3RlZCBlbmQgb2Ygc3RyZWFtJyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICBsZXQgdHJhaWxpbmdDUkxGID0gZmFsc2U7XG4gICAgZnVuY3Rpb24gZmVlZENodW5rKGNodW5rKSB7XG4gICAgICBjb25zdCBjaHVua3MgPSBbXTtcbiAgICAgIGZvciAoY29uc3QgdG9rZW4gb2YgY3JsZlNlYXJjaC5mZWVkKGNodW5rKSkge1xuICAgICAgICBpZiAodHJhaWxpbmdDUkxGKSB7XG4gICAgICAgICAgY2h1bmtzLnB1c2goQ1JMRik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCEodHJhaWxpbmdDUkxGID0gdG9rZW4gPT09IE1BVENIKSkge1xuICAgICAgICAgIGNodW5rcy5wdXNoKHRva2VuKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIG1lcmdlQXJyYXlzKC4uLmNodW5rcyk7XG4gICAgfVxuICAgIGxldCBkb25lID0gZmFsc2U7XG4gICAgYXN5bmMgZnVuY3Rpb24gbmV4dENodW5rKCkge1xuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgbmV4dFRva2VuKCk7XG4gICAgICBsZXQgY2h1bms7XG4gICAgICBpZiAocmVzdWx0LnZhbHVlICE9PSBNQVRDSCkge1xuICAgICAgICBjaHVuayA9IHJlc3VsdC52YWx1ZTtcbiAgICAgIH0gZWxzZSBpZiAoIXRyYWlsaW5nQ1JMRikge1xuICAgICAgICBjaHVuayA9IENSTEY7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkb25lID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIHsgdmFsdWU6IGNybGZTZWFyY2guZW5kKCkgfTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB7IHZhbHVlOiBmZWVkQ2h1bmsoY2h1bmspIH07XG4gICAgfVxuICAgIGNvbnN0IGJ1ZmZlcmVkQ2h1bmtzID0gW3sgdmFsdWU6IGZlZWRDaHVuayh0YWlsKSB9XTtcbiAgICB5aWVsZCB7XG4gICAgICAuLi5wYXJzZVBhcnRIZWFkZXJzKGhlYWRlckxpbmVzKSxcbiAgICAgIGRhdGE6IHtcbiAgICAgICAgW1N5bWJvbC5hc3luY0l0ZXJhdG9yXSgpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSxcbiAgICAgICAgYXN5bmMgbmV4dCgpIHtcbiAgICAgICAgICBmb3IgKDs7KSB7XG4gICAgICAgICAgICBjb25zdCByZXN1bHQgPSBidWZmZXJlZENodW5rcy5zaGlmdCgpO1xuICAgICAgICAgICAgaWYgKCFyZXN1bHQpIHtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocmVzdWx0LnZhbHVlLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgZm9yICg7Oykge1xuICAgICAgICAgICAgaWYgKGRvbmUpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBkb25lLFxuICAgICAgICAgICAgICAgIHZhbHVlOiB1bmRlZmluZWRcbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IG5leHRDaHVuaygpO1xuICAgICAgICAgICAgaWYgKHJlc3VsdC52YWx1ZS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcbiAgICB3aGlsZSAoIWRvbmUpIHtcbiAgICAgIGJ1ZmZlcmVkQ2h1bmtzLnB1c2goYXdhaXQgbmV4dENodW5rKCkpO1xuICAgIH1cbiAgfVxufVxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uKiBpdGVyYXRlTXVsdGlwYXJ0KGJvZHksIGJvdW5kYXJ5KSB7XG4gIGZvciBhd2FpdCAoY29uc3QgcGFydCBvZiBzdHJlYW1NdWx0aXBhcnQoYm9keSwgYm91bmRhcnkpKSB7XG4gICAgY29uc3QgY2h1bmtzID0gW107XG4gICAgZm9yIGF3YWl0IChjb25zdCBjaHVuayBvZiBwYXJ0LmRhdGEpIHtcbiAgICAgIGNodW5rcy5wdXNoKGNodW5rKTtcbiAgICB9XG4gICAgeWllbGQge1xuICAgICAgLi4ucGFydCxcbiAgICAgIGRhdGE6IG1lcmdlQXJyYXlzKC4uLmNodW5rcylcbiAgICB9O1xuICB9XG59Il0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@web3-storage/multipart-parser/esm/src/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@web3-storage/multipart-parser/esm/src/search.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@web3-storage/multipart-parser/esm/src/search.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   MATCH: () => (/* binding */ MATCH),\n/* harmony export */   QueueableStreamSearch: () => (/* binding */ QueueableStreamSearch),\n/* harmony export */   ReadableStreamSearch: () => (/* binding */ ReadableStreamSearch),\n/* harmony export */   StreamSearch: () => (/* binding */ StreamSearch),\n/* harmony export */   allStrings: () => (/* binding */ allStrings),\n/* harmony export */   arrayIterator: () => (/* binding */ arrayIterator),\n/* harmony export */   chunksIterator: () => (/* binding */ chunksIterator),\n/* harmony export */   split: () => (/* binding */ split),\n/* harmony export */   splitChunks: () => (/* binding */ splitChunks),\n/* harmony export */   stringIterator: () => (/* binding */ stringIterator)\n/* harmony export */ });\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils.js */ \"(ssr)/./node_modules/@web3-storage/multipart-parser/esm/src/utils.js\");\n\nfunction coerce(a) {\n  if (a instanceof Uint8Array) {\n    return index => a[index];\n  }\n  return a;\n}\nfunction jsmemcmp(buf1, pos1, buf2, pos2, len) {\n  const fn1 = coerce(buf1);\n  const fn2 = coerce(buf2);\n  for (let i = 0; i < len; ++i) {\n    if (fn1(pos1 + i) !== fn2(pos2 + i)) {\n      return false;\n    }\n  }\n  return true;\n}\nfunction createOccurenceTable(s) {\n  const table = new Array(256).fill(s.length);\n  if (s.length > 1) {\n    for (let i = 0; i < s.length - 1; i++) {\n      table[s[i]] = s.length - 1 - i;\n    }\n  }\n  return table;\n}\nconst MATCH = Symbol('Match');\nclass StreamSearch {\n  constructor(needle) {\n    this._lookbehind = new Uint8Array();\n    if (typeof needle === 'string') {\n      this._needle = needle = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.stringToArray)(needle);\n    } else {\n      this._needle = needle;\n    }\n    this._lastChar = needle[needle.length - 1];\n    this._occ = createOccurenceTable(needle);\n  }\n  feed(chunk) {\n    let pos = 0;\n    let tokens;\n    const allTokens = [];\n    while (pos !== chunk.length) {\n      ;\n      [pos, ...tokens] = this._feed(chunk, pos);\n      allTokens.push(...tokens);\n    }\n    return allTokens;\n  }\n  end() {\n    const tail = this._lookbehind;\n    this._lookbehind = new Uint8Array();\n    return tail;\n  }\n  _feed(data, bufPos) {\n    const tokens = [];\n    let pos = -this._lookbehind.length;\n    if (pos < 0) {\n      while (pos < 0 && pos <= data.length - this._needle.length) {\n        const ch = this._charAt(data, pos + this._needle.length - 1);\n        if (ch === this._lastChar && this._memcmp(data, pos, this._needle.length - 1)) {\n          if (pos > -this._lookbehind.length) {\n            tokens.push(this._lookbehind.slice(0, this._lookbehind.length + pos));\n          }\n          tokens.push(MATCH);\n          this._lookbehind = new Uint8Array();\n          return [\n            pos + this._needle.length,\n            ...tokens\n          ];\n        } else {\n          pos += this._occ[ch];\n        }\n      }\n      if (pos < 0) {\n        while (pos < 0 && !this._memcmp(data, pos, data.length - pos)) {\n          pos++;\n        }\n      }\n      if (pos >= 0) {\n        tokens.push(this._lookbehind);\n        this._lookbehind = new Uint8Array();\n      } else {\n        const bytesToCutOff = this._lookbehind.length + pos;\n        if (bytesToCutOff > 0) {\n          tokens.push(this._lookbehind.slice(0, bytesToCutOff));\n          this._lookbehind = this._lookbehind.slice(bytesToCutOff);\n        }\n        this._lookbehind = Uint8Array.from(new Array(this._lookbehind.length + data.length), (_, i) => this._charAt(data, i - this._lookbehind.length));\n        return [\n          data.length,\n          ...tokens\n        ];\n      }\n    }\n    pos += bufPos;\n    while (pos <= data.length - this._needle.length) {\n      const ch = data[pos + this._needle.length - 1];\n      if (ch === this._lastChar && data[pos] === this._needle[0] && jsmemcmp(this._needle, 0, data, pos, this._needle.length - 1)) {\n        if (pos > bufPos) {\n          tokens.push(data.slice(bufPos, pos));\n        }\n        tokens.push(MATCH);\n        return [\n          pos + this._needle.length,\n          ...tokens\n        ];\n      } else {\n        pos += this._occ[ch];\n      }\n    }\n    if (pos < data.length) {\n      while (pos < data.length && (data[pos] !== this._needle[0] || !jsmemcmp(data, pos, this._needle, 0, data.length - pos))) {\n        ++pos;\n      }\n      if (pos < data.length) {\n        this._lookbehind = data.slice(pos);\n      }\n    }\n    if (pos > 0) {\n      tokens.push(data.slice(bufPos, pos < data.length ? pos : data.length));\n    }\n    return [\n      data.length,\n      ...tokens\n    ];\n  }\n  _charAt(data, pos) {\n    if (pos < 0) {\n      return this._lookbehind[this._lookbehind.length + pos];\n    }\n    return data[pos];\n  }\n  _memcmp(data, pos, len) {\n    return jsmemcmp(this._charAt.bind(this, data), pos, this._needle, 0, len);\n  }\n}\nclass ReadableStreamSearch {\n  constructor(needle, _readableStream) {\n    this._readableStream = _readableStream;\n    this._search = new StreamSearch(needle);\n  }\n  async *[Symbol.asyncIterator]() {\n    const reader = this._readableStream.getReader();\n    try {\n      while (true) {\n        const result = await reader.read();\n        if (result.done) {\n          break;\n        }\n        yield* this._search.feed(result.value);\n      }\n      const tail = this._search.end();\n      if (tail.length) {\n        yield tail;\n      }\n    } finally {\n      reader.releaseLock();\n    }\n  }\n}\nconst EOQ = Symbol('End of Queue');\nclass QueueableStreamSearch {\n  constructor(needle) {\n    this._chunksQueue = [];\n    this._closed = false;\n    this._search = new StreamSearch(needle);\n  }\n  push(...chunks) {\n    if (this._closed) {\n      throw new Error('cannot call push after close');\n    }\n    this._chunksQueue.push(...chunks);\n    if (this._notify) {\n      this._notify();\n    }\n  }\n  close() {\n    if (this._closed) {\n      throw new Error('close was already called');\n    }\n    this._closed = true;\n    this._chunksQueue.push(EOQ);\n    if (this._notify) {\n      this._notify();\n    }\n  }\n  async *[Symbol.asyncIterator]() {\n    while (true) {\n      let chunk;\n      while (!(chunk = this._chunksQueue.shift())) {\n        await new Promise(resolve => this._notify = resolve);\n        this._notify = undefined;\n      }\n      if (chunk === EOQ) {\n        break;\n      }\n      yield* this._search.feed(chunk);\n    }\n    const tail = this._search.end();\n    if (tail.length) {\n      yield tail;\n    }\n  }\n}\nfunction splitChunks(chunks, needle) {\n  const search = new StreamSearch(needle);\n  const outchunks = [[]];\n  for (const chunk of chunks) {\n    for (const token of search.feed(chunk)) {\n      if (token === MATCH) {\n        outchunks.push([]);\n      } else {\n        outchunks[outchunks.length - 1].push(token);\n      }\n    }\n  }\n  const end = search.end();\n  outchunks[outchunks.length - 1].push(end);\n  return outchunks.map(chunks => (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.mergeArrays)(...chunks));\n}\nfunction split(buf, needle) {\n  return splitChunks([buf], needle);\n}\nasync function* chunksIterator(iter) {\n  let chunks = [];\n  for await (const value of iter) {\n    if (value === MATCH) {\n      yield chunks;\n      chunks = [];\n    } else {\n      chunks.push(value);\n    }\n  }\n  yield chunks;\n}\nasync function* stringIterator(iter) {\n  for await (const chunk of chunksIterator(iter)) {\n    yield chunk.map(_utils_js__WEBPACK_IMPORTED_MODULE_0__.arrayToString).join('');\n  }\n}\nasync function allStrings(iter) {\n  const segments = [];\n  for await (const value of stringIterator(iter)) {\n    segments.push(value);\n  }\n  return segments;\n}\nasync function* arrayIterator(iter) {\n  for await (const chunk of chunksIterator(iter)) {\n    yield (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.mergeArrays)(...chunk);\n  }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHdlYjMtc3RvcmFnZS9tdWx0aXBhcnQtcGFyc2VyL2VzbS9zcmMvc2VhcmNoLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7O0FBSW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixTQUFTO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixrQkFBa0I7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsd0RBQWE7QUFDM0MsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsc0RBQVc7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isb0RBQWE7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsc0RBQVc7QUFDckI7QUFDQSIsInNvdXJjZXMiOlsiL2hvbWUvYWx0Y29pbi1kYWRkeS9Eb3dubG9hZHMvb3dubHkvbm9kZV9tb2R1bGVzL0B3ZWIzLXN0b3JhZ2UvbXVsdGlwYXJ0LXBhcnNlci9lc20vc3JjL3NlYXJjaC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge1xuICBzdHJpbmdUb0FycmF5LFxuICBtZXJnZUFycmF5cyxcbiAgYXJyYXlUb1N0cmluZ1xufSBmcm9tICcuL3V0aWxzLmpzJztcbmZ1bmN0aW9uIGNvZXJjZShhKSB7XG4gIGlmIChhIGluc3RhbmNlb2YgVWludDhBcnJheSkge1xuICAgIHJldHVybiBpbmRleCA9PiBhW2luZGV4XTtcbiAgfVxuICByZXR1cm4gYTtcbn1cbmZ1bmN0aW9uIGpzbWVtY21wKGJ1ZjEsIHBvczEsIGJ1ZjIsIHBvczIsIGxlbikge1xuICBjb25zdCBmbjEgPSBjb2VyY2UoYnVmMSk7XG4gIGNvbnN0IGZuMiA9IGNvZXJjZShidWYyKTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW47ICsraSkge1xuICAgIGlmIChmbjEocG9zMSArIGkpICE9PSBmbjIocG9zMiArIGkpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG4gIHJldHVybiB0cnVlO1xufVxuZnVuY3Rpb24gY3JlYXRlT2NjdXJlbmNlVGFibGUocykge1xuICBjb25zdCB0YWJsZSA9IG5ldyBBcnJheSgyNTYpLmZpbGwocy5sZW5ndGgpO1xuICBpZiAocy5sZW5ndGggPiAxKSB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzLmxlbmd0aCAtIDE7IGkrKykge1xuICAgICAgdGFibGVbc1tpXV0gPSBzLmxlbmd0aCAtIDEgLSBpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdGFibGU7XG59XG5jb25zdCBNQVRDSCA9IFN5bWJvbCgnTWF0Y2gnKTtcbmNsYXNzIFN0cmVhbVNlYXJjaCB7XG4gIGNvbnN0cnVjdG9yKG5lZWRsZSkge1xuICAgIHRoaXMuX2xvb2tiZWhpbmQgPSBuZXcgVWludDhBcnJheSgpO1xuICAgIGlmICh0eXBlb2YgbmVlZGxlID09PSAnc3RyaW5nJykge1xuICAgICAgdGhpcy5fbmVlZGxlID0gbmVlZGxlID0gc3RyaW5nVG9BcnJheShuZWVkbGUpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9uZWVkbGUgPSBuZWVkbGU7XG4gICAgfVxuICAgIHRoaXMuX2xhc3RDaGFyID0gbmVlZGxlW25lZWRsZS5sZW5ndGggLSAxXTtcbiAgICB0aGlzLl9vY2MgPSBjcmVhdGVPY2N1cmVuY2VUYWJsZShuZWVkbGUpO1xuICB9XG4gIGZlZWQoY2h1bmspIHtcbiAgICBsZXQgcG9zID0gMDtcbiAgICBsZXQgdG9rZW5zO1xuICAgIGNvbnN0IGFsbFRva2VucyA9IFtdO1xuICAgIHdoaWxlIChwb3MgIT09IGNodW5rLmxlbmd0aCkge1xuICAgICAgO1xuICAgICAgW3BvcywgLi4udG9rZW5zXSA9IHRoaXMuX2ZlZWQoY2h1bmssIHBvcyk7XG4gICAgICBhbGxUb2tlbnMucHVzaCguLi50b2tlbnMpO1xuICAgIH1cbiAgICByZXR1cm4gYWxsVG9rZW5zO1xuICB9XG4gIGVuZCgpIHtcbiAgICBjb25zdCB0YWlsID0gdGhpcy5fbG9va2JlaGluZDtcbiAgICB0aGlzLl9sb29rYmVoaW5kID0gbmV3IFVpbnQ4QXJyYXkoKTtcbiAgICByZXR1cm4gdGFpbDtcbiAgfVxuICBfZmVlZChkYXRhLCBidWZQb3MpIHtcbiAgICBjb25zdCB0b2tlbnMgPSBbXTtcbiAgICBsZXQgcG9zID0gLXRoaXMuX2xvb2tiZWhpbmQubGVuZ3RoO1xuICAgIGlmIChwb3MgPCAwKSB7XG4gICAgICB3aGlsZSAocG9zIDwgMCAmJiBwb3MgPD0gZGF0YS5sZW5ndGggLSB0aGlzLl9uZWVkbGUubGVuZ3RoKSB7XG4gICAgICAgIGNvbnN0IGNoID0gdGhpcy5fY2hhckF0KGRhdGEsIHBvcyArIHRoaXMuX25lZWRsZS5sZW5ndGggLSAxKTtcbiAgICAgICAgaWYgKGNoID09PSB0aGlzLl9sYXN0Q2hhciAmJiB0aGlzLl9tZW1jbXAoZGF0YSwgcG9zLCB0aGlzLl9uZWVkbGUubGVuZ3RoIC0gMSkpIHtcbiAgICAgICAgICBpZiAocG9zID4gLXRoaXMuX2xvb2tiZWhpbmQubGVuZ3RoKSB7XG4gICAgICAgICAgICB0b2tlbnMucHVzaCh0aGlzLl9sb29rYmVoaW5kLnNsaWNlKDAsIHRoaXMuX2xvb2tiZWhpbmQubGVuZ3RoICsgcG9zKSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRva2Vucy5wdXNoKE1BVENIKTtcbiAgICAgICAgICB0aGlzLl9sb29rYmVoaW5kID0gbmV3IFVpbnQ4QXJyYXkoKTtcbiAgICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgcG9zICsgdGhpcy5fbmVlZGxlLmxlbmd0aCxcbiAgICAgICAgICAgIC4uLnRva2Vuc1xuICAgICAgICAgIF07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcG9zICs9IHRoaXMuX29jY1tjaF07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChwb3MgPCAwKSB7XG4gICAgICAgIHdoaWxlIChwb3MgPCAwICYmICF0aGlzLl9tZW1jbXAoZGF0YSwgcG9zLCBkYXRhLmxlbmd0aCAtIHBvcykpIHtcbiAgICAgICAgICBwb3MrKztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKHBvcyA+PSAwKSB7XG4gICAgICAgIHRva2Vucy5wdXNoKHRoaXMuX2xvb2tiZWhpbmQpO1xuICAgICAgICB0aGlzLl9sb29rYmVoaW5kID0gbmV3IFVpbnQ4QXJyYXkoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IGJ5dGVzVG9DdXRPZmYgPSB0aGlzLl9sb29rYmVoaW5kLmxlbmd0aCArIHBvcztcbiAgICAgICAgaWYgKGJ5dGVzVG9DdXRPZmYgPiAwKSB7XG4gICAgICAgICAgdG9rZW5zLnB1c2godGhpcy5fbG9va2JlaGluZC5zbGljZSgwLCBieXRlc1RvQ3V0T2ZmKSk7XG4gICAgICAgICAgdGhpcy5fbG9va2JlaGluZCA9IHRoaXMuX2xvb2tiZWhpbmQuc2xpY2UoYnl0ZXNUb0N1dE9mZik7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fbG9va2JlaGluZCA9IFVpbnQ4QXJyYXkuZnJvbShuZXcgQXJyYXkodGhpcy5fbG9va2JlaGluZC5sZW5ndGggKyBkYXRhLmxlbmd0aCksIChfLCBpKSA9PiB0aGlzLl9jaGFyQXQoZGF0YSwgaSAtIHRoaXMuX2xvb2tiZWhpbmQubGVuZ3RoKSk7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgZGF0YS5sZW5ndGgsXG4gICAgICAgICAgLi4udG9rZW5zXG4gICAgICAgIF07XG4gICAgICB9XG4gICAgfVxuICAgIHBvcyArPSBidWZQb3M7XG4gICAgd2hpbGUgKHBvcyA8PSBkYXRhLmxlbmd0aCAtIHRoaXMuX25lZWRsZS5sZW5ndGgpIHtcbiAgICAgIGNvbnN0IGNoID0gZGF0YVtwb3MgKyB0aGlzLl9uZWVkbGUubGVuZ3RoIC0gMV07XG4gICAgICBpZiAoY2ggPT09IHRoaXMuX2xhc3RDaGFyICYmIGRhdGFbcG9zXSA9PT0gdGhpcy5fbmVlZGxlWzBdICYmIGpzbWVtY21wKHRoaXMuX25lZWRsZSwgMCwgZGF0YSwgcG9zLCB0aGlzLl9uZWVkbGUubGVuZ3RoIC0gMSkpIHtcbiAgICAgICAgaWYgKHBvcyA+IGJ1ZlBvcykge1xuICAgICAgICAgIHRva2Vucy5wdXNoKGRhdGEuc2xpY2UoYnVmUG9zLCBwb3MpKTtcbiAgICAgICAgfVxuICAgICAgICB0b2tlbnMucHVzaChNQVRDSCk7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgcG9zICsgdGhpcy5fbmVlZGxlLmxlbmd0aCxcbiAgICAgICAgICAuLi50b2tlbnNcbiAgICAgICAgXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHBvcyArPSB0aGlzLl9vY2NbY2hdO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAocG9zIDwgZGF0YS5sZW5ndGgpIHtcbiAgICAgIHdoaWxlIChwb3MgPCBkYXRhLmxlbmd0aCAmJiAoZGF0YVtwb3NdICE9PSB0aGlzLl9uZWVkbGVbMF0gfHwgIWpzbWVtY21wKGRhdGEsIHBvcywgdGhpcy5fbmVlZGxlLCAwLCBkYXRhLmxlbmd0aCAtIHBvcykpKSB7XG4gICAgICAgICsrcG9zO1xuICAgICAgfVxuICAgICAgaWYgKHBvcyA8IGRhdGEubGVuZ3RoKSB7XG4gICAgICAgIHRoaXMuX2xvb2tiZWhpbmQgPSBkYXRhLnNsaWNlKHBvcyk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChwb3MgPiAwKSB7XG4gICAgICB0b2tlbnMucHVzaChkYXRhLnNsaWNlKGJ1ZlBvcywgcG9zIDwgZGF0YS5sZW5ndGggPyBwb3MgOiBkYXRhLmxlbmd0aCkpO1xuICAgIH1cbiAgICByZXR1cm4gW1xuICAgICAgZGF0YS5sZW5ndGgsXG4gICAgICAuLi50b2tlbnNcbiAgICBdO1xuICB9XG4gIF9jaGFyQXQoZGF0YSwgcG9zKSB7XG4gICAgaWYgKHBvcyA8IDApIHtcbiAgICAgIHJldHVybiB0aGlzLl9sb29rYmVoaW5kW3RoaXMuX2xvb2tiZWhpbmQubGVuZ3RoICsgcG9zXTtcbiAgICB9XG4gICAgcmV0dXJuIGRhdGFbcG9zXTtcbiAgfVxuICBfbWVtY21wKGRhdGEsIHBvcywgbGVuKSB7XG4gICAgcmV0dXJuIGpzbWVtY21wKHRoaXMuX2NoYXJBdC5iaW5kKHRoaXMsIGRhdGEpLCBwb3MsIHRoaXMuX25lZWRsZSwgMCwgbGVuKTtcbiAgfVxufVxuY2xhc3MgUmVhZGFibGVTdHJlYW1TZWFyY2gge1xuICBjb25zdHJ1Y3RvcihuZWVkbGUsIF9yZWFkYWJsZVN0cmVhbSkge1xuICAgIHRoaXMuX3JlYWRhYmxlU3RyZWFtID0gX3JlYWRhYmxlU3RyZWFtO1xuICAgIHRoaXMuX3NlYXJjaCA9IG5ldyBTdHJlYW1TZWFyY2gobmVlZGxlKTtcbiAgfVxuICBhc3luYyAqW1N5bWJvbC5hc3luY0l0ZXJhdG9yXSgpIHtcbiAgICBjb25zdCByZWFkZXIgPSB0aGlzLl9yZWFkYWJsZVN0cmVhbS5nZXRSZWFkZXIoKTtcbiAgICB0cnkge1xuICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgcmVhZGVyLnJlYWQoKTtcbiAgICAgICAgaWYgKHJlc3VsdC5kb25lKSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgeWllbGQqIHRoaXMuX3NlYXJjaC5mZWVkKHJlc3VsdC52YWx1ZSk7XG4gICAgICB9XG4gICAgICBjb25zdCB0YWlsID0gdGhpcy5fc2VhcmNoLmVuZCgpO1xuICAgICAgaWYgKHRhaWwubGVuZ3RoKSB7XG4gICAgICAgIHlpZWxkIHRhaWw7XG4gICAgICB9XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIHJlYWRlci5yZWxlYXNlTG9jaygpO1xuICAgIH1cbiAgfVxufVxuY29uc3QgRU9RID0gU3ltYm9sKCdFbmQgb2YgUXVldWUnKTtcbmNsYXNzIFF1ZXVlYWJsZVN0cmVhbVNlYXJjaCB7XG4gIGNvbnN0cnVjdG9yKG5lZWRsZSkge1xuICAgIHRoaXMuX2NodW5rc1F1ZXVlID0gW107XG4gICAgdGhpcy5fY2xvc2VkID0gZmFsc2U7XG4gICAgdGhpcy5fc2VhcmNoID0gbmV3IFN0cmVhbVNlYXJjaChuZWVkbGUpO1xuICB9XG4gIHB1c2goLi4uY2h1bmtzKSB7XG4gICAgaWYgKHRoaXMuX2Nsb3NlZCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdjYW5ub3QgY2FsbCBwdXNoIGFmdGVyIGNsb3NlJyk7XG4gICAgfVxuICAgIHRoaXMuX2NodW5rc1F1ZXVlLnB1c2goLi4uY2h1bmtzKTtcbiAgICBpZiAodGhpcy5fbm90aWZ5KSB7XG4gICAgICB0aGlzLl9ub3RpZnkoKTtcbiAgICB9XG4gIH1cbiAgY2xvc2UoKSB7XG4gICAgaWYgKHRoaXMuX2Nsb3NlZCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdjbG9zZSB3YXMgYWxyZWFkeSBjYWxsZWQnKTtcbiAgICB9XG4gICAgdGhpcy5fY2xvc2VkID0gdHJ1ZTtcbiAgICB0aGlzLl9jaHVua3NRdWV1ZS5wdXNoKEVPUSk7XG4gICAgaWYgKHRoaXMuX25vdGlmeSkge1xuICAgICAgdGhpcy5fbm90aWZ5KCk7XG4gICAgfVxuICB9XG4gIGFzeW5jICpbU3ltYm9sLmFzeW5jSXRlcmF0b3JdKCkge1xuICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICBsZXQgY2h1bms7XG4gICAgICB3aGlsZSAoIShjaHVuayA9IHRoaXMuX2NodW5rc1F1ZXVlLnNoaWZ0KCkpKSB7XG4gICAgICAgIGF3YWl0IG5ldyBQcm9taXNlKHJlc29sdmUgPT4gdGhpcy5fbm90aWZ5ID0gcmVzb2x2ZSk7XG4gICAgICAgIHRoaXMuX25vdGlmeSA9IHVuZGVmaW5lZDtcbiAgICAgIH1cbiAgICAgIGlmIChjaHVuayA9PT0gRU9RKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgeWllbGQqIHRoaXMuX3NlYXJjaC5mZWVkKGNodW5rKTtcbiAgICB9XG4gICAgY29uc3QgdGFpbCA9IHRoaXMuX3NlYXJjaC5lbmQoKTtcbiAgICBpZiAodGFpbC5sZW5ndGgpIHtcbiAgICAgIHlpZWxkIHRhaWw7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBzcGxpdENodW5rcyhjaHVua3MsIG5lZWRsZSkge1xuICBjb25zdCBzZWFyY2ggPSBuZXcgU3RyZWFtU2VhcmNoKG5lZWRsZSk7XG4gIGNvbnN0IG91dGNodW5rcyA9IFtbXV07XG4gIGZvciAoY29uc3QgY2h1bmsgb2YgY2h1bmtzKSB7XG4gICAgZm9yIChjb25zdCB0b2tlbiBvZiBzZWFyY2guZmVlZChjaHVuaykpIHtcbiAgICAgIGlmICh0b2tlbiA9PT0gTUFUQ0gpIHtcbiAgICAgICAgb3V0Y2h1bmtzLnB1c2goW10pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgb3V0Y2h1bmtzW291dGNodW5rcy5sZW5ndGggLSAxXS5wdXNoKHRva2VuKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgY29uc3QgZW5kID0gc2VhcmNoLmVuZCgpO1xuICBvdXRjaHVua3Nbb3V0Y2h1bmtzLmxlbmd0aCAtIDFdLnB1c2goZW5kKTtcbiAgcmV0dXJuIG91dGNodW5rcy5tYXAoY2h1bmtzID0+IG1lcmdlQXJyYXlzKC4uLmNodW5rcykpO1xufVxuZnVuY3Rpb24gc3BsaXQoYnVmLCBuZWVkbGUpIHtcbiAgcmV0dXJuIHNwbGl0Q2h1bmtzKFtidWZdLCBuZWVkbGUpO1xufVxuYXN5bmMgZnVuY3Rpb24qIGNodW5rc0l0ZXJhdG9yKGl0ZXIpIHtcbiAgbGV0IGNodW5rcyA9IFtdO1xuICBmb3IgYXdhaXQgKGNvbnN0IHZhbHVlIG9mIGl0ZXIpIHtcbiAgICBpZiAodmFsdWUgPT09IE1BVENIKSB7XG4gICAgICB5aWVsZCBjaHVua3M7XG4gICAgICBjaHVua3MgPSBbXTtcbiAgICB9IGVsc2Uge1xuICAgICAgY2h1bmtzLnB1c2godmFsdWUpO1xuICAgIH1cbiAgfVxuICB5aWVsZCBjaHVua3M7XG59XG5hc3luYyBmdW5jdGlvbiogc3RyaW5nSXRlcmF0b3IoaXRlcikge1xuICBmb3IgYXdhaXQgKGNvbnN0IGNodW5rIG9mIGNodW5rc0l0ZXJhdG9yKGl0ZXIpKSB7XG4gICAgeWllbGQgY2h1bmsubWFwKGFycmF5VG9TdHJpbmcpLmpvaW4oJycpO1xuICB9XG59XG5hc3luYyBmdW5jdGlvbiBhbGxTdHJpbmdzKGl0ZXIpIHtcbiAgY29uc3Qgc2VnbWVudHMgPSBbXTtcbiAgZm9yIGF3YWl0IChjb25zdCB2YWx1ZSBvZiBzdHJpbmdJdGVyYXRvcihpdGVyKSkge1xuICAgIHNlZ21lbnRzLnB1c2godmFsdWUpO1xuICB9XG4gIHJldHVybiBzZWdtZW50cztcbn1cbmFzeW5jIGZ1bmN0aW9uKiBhcnJheUl0ZXJhdG9yKGl0ZXIpIHtcbiAgZm9yIGF3YWl0IChjb25zdCBjaHVuayBvZiBjaHVua3NJdGVyYXRvcihpdGVyKSkge1xuICAgIHlpZWxkIG1lcmdlQXJyYXlzKC4uLmNodW5rKTtcbiAgfVxufVxuZXhwb3J0IHtcbiAgTUFUQ0gsXG4gIFF1ZXVlYWJsZVN0cmVhbVNlYXJjaCxcbiAgUmVhZGFibGVTdHJlYW1TZWFyY2gsXG4gIFN0cmVhbVNlYXJjaCxcbiAgYWxsU3RyaW5ncyxcbiAgYXJyYXlJdGVyYXRvcixcbiAgY2h1bmtzSXRlcmF0b3IsXG4gIHNwbGl0LFxuICBzcGxpdENodW5rcyxcbiAgc3RyaW5nSXRlcmF0b3Jcbn07Il0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@web3-storage/multipart-parser/esm/src/search.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@web3-storage/multipart-parser/esm/src/utils.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@web3-storage/multipart-parser/esm/src/utils.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   arrayToString: () => (/* binding */ arrayToString),\n/* harmony export */   arraysEqual: () => (/* binding */ arraysEqual),\n/* harmony export */   mergeArrays: () => (/* binding */ mergeArrays),\n/* harmony export */   stringToArray: () => (/* binding */ stringToArray)\n/* harmony export */ });\nfunction stringToArray(s) {\n  const utf8 = unescape(encodeURIComponent(s));\n  return Uint8Array.from(utf8, (_, i) => utf8.charCodeAt(i));\n}\nfunction arrayToString(a) {\n  const utf8 = String.fromCharCode.apply(null, a);\n  return decodeURIComponent(escape(utf8));\n}\nfunction mergeArrays(...arrays) {\n  const out = new Uint8Array(arrays.reduce((total, arr) => total + arr.length, 0));\n  let offset = 0;\n  for (const arr of arrays) {\n    out.set(arr, offset);\n    offset += arr.length;\n  }\n  return out;\n}\nfunction arraysEqual(a, b) {\n  if (a.length !== b.length) {\n    return false;\n  }\n  for (let i = 0; i < a.length; i++) {\n    if (a[i] !== b[i]) {\n      return false;\n    }\n  }\n  return true;\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHdlYjMtc3RvcmFnZS9tdWx0aXBhcnQtcGFyc2VyL2VzbS9zcmMvdXRpbHMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixjQUFjO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiL2hvbWUvYWx0Y29pbi1kYWRkeS9Eb3dubG9hZHMvb3dubHkvbm9kZV9tb2R1bGVzL0B3ZWIzLXN0b3JhZ2UvbXVsdGlwYXJ0LXBhcnNlci9lc20vc3JjL3V0aWxzLmpzIl0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCBmdW5jdGlvbiBzdHJpbmdUb0FycmF5KHMpIHtcbiAgY29uc3QgdXRmOCA9IHVuZXNjYXBlKGVuY29kZVVSSUNvbXBvbmVudChzKSk7XG4gIHJldHVybiBVaW50OEFycmF5LmZyb20odXRmOCwgKF8sIGkpID0+IHV0ZjguY2hhckNvZGVBdChpKSk7XG59XG5leHBvcnQgZnVuY3Rpb24gYXJyYXlUb1N0cmluZyhhKSB7XG4gIGNvbnN0IHV0ZjggPSBTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KG51bGwsIGEpO1xuICByZXR1cm4gZGVjb2RlVVJJQ29tcG9uZW50KGVzY2FwZSh1dGY4KSk7XG59XG5leHBvcnQgZnVuY3Rpb24gbWVyZ2VBcnJheXMoLi4uYXJyYXlzKSB7XG4gIGNvbnN0IG91dCA9IG5ldyBVaW50OEFycmF5KGFycmF5cy5yZWR1Y2UoKHRvdGFsLCBhcnIpID0+IHRvdGFsICsgYXJyLmxlbmd0aCwgMCkpO1xuICBsZXQgb2Zmc2V0ID0gMDtcbiAgZm9yIChjb25zdCBhcnIgb2YgYXJyYXlzKSB7XG4gICAgb3V0LnNldChhcnIsIG9mZnNldCk7XG4gICAgb2Zmc2V0ICs9IGFyci5sZW5ndGg7XG4gIH1cbiAgcmV0dXJuIG91dDtcbn1cbmV4cG9ydCBmdW5jdGlvbiBhcnJheXNFcXVhbChhLCBiKSB7XG4gIGlmIChhLmxlbmd0aCAhPT0gYi5sZW5ndGgpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBhLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKGFbaV0gIT09IGJbaV0pIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59Il0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@web3-storage/multipart-parser/esm/src/utils.js\n");

/***/ })

};
;