"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/nft.storage";
exports.ids = ["vendor-chunks/nft.storage"];
exports.modules = {

/***/ "(rsc)/./node_modules/nft.storage/src/bs-car-reader.js":
/*!*******************************************************!*\
  !*** ./node_modules/nft.storage/src/bs-car-reader.js ***!
  \*******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   BlockstoreCarReader: () => (/* binding */ BlockstoreCarReader)\n/* harmony export */ });\n/**\n * An implementation of the CAR reader interface that is backed by a blockstore.\n *\n * @typedef {import('multiformats').CID} CID\n * @typedef {import('@ipld/car/api').CarReader} CarReader\n * @implements {CarReader}\n */\nclass BlockstoreCarReader {\n  /**\n   * @param {number} version\n   * @param {CID[]} roots\n   * @param {import('ipfs-car/blockstore').Blockstore} blockstore\n   */\n  constructor(version, roots, blockstore) {\n    /**\n     * @private\n     */\n    this._version = version\n    /**\n     * @private\n     */\n    this._roots = roots\n    /**\n     * @private\n     */\n    this._blockstore = blockstore\n  }\n\n  get version() {\n    return this._version\n  }\n\n  get blockstore() {\n    return this._blockstore\n  }\n\n  async getRoots() {\n    return this._roots\n  }\n\n  /**\n   * @param {CID} cid\n   */\n  has(cid) {\n    return this._blockstore.has(cid)\n  }\n\n  /**\n   * @param {CID} cid\n   */\n  async get(cid) {\n    const bytes = await this._blockstore.get(cid)\n    return { cid, bytes }\n  }\n\n  blocks() {\n    return this._blockstore.blocks()\n  }\n\n  async *cids() {\n    for await (const b of this.blocks()) {\n      yield b.cid\n    }\n  }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbmZ0LnN0b3JhZ2Uvc3JjL2JzLWNhci1yZWFkZXIuanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsNEJBQTRCO0FBQ3pDLGFBQWEsbUNBQW1DO0FBQ2hELGdCQUFnQjtBQUNoQjtBQUNPO0FBQ1A7QUFDQSxhQUFhLFFBQVE7QUFDckIsYUFBYSxPQUFPO0FBQ3BCLGFBQWEsMENBQTBDO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGFBQWEsS0FBSztBQUNsQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGFBQWEsS0FBSztBQUNsQjtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiL2hvbWUvYWx0Y29pbi1kYWRkeS9Eb3dubG9hZHMvb3dubHkvbm9kZV9tb2R1bGVzL25mdC5zdG9yYWdlL3NyYy9icy1jYXItcmVhZGVyLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQW4gaW1wbGVtZW50YXRpb24gb2YgdGhlIENBUiByZWFkZXIgaW50ZXJmYWNlIHRoYXQgaXMgYmFja2VkIGJ5IGEgYmxvY2tzdG9yZS5cbiAqXG4gKiBAdHlwZWRlZiB7aW1wb3J0KCdtdWx0aWZvcm1hdHMnKS5DSUR9IENJRFxuICogQHR5cGVkZWYge2ltcG9ydCgnQGlwbGQvY2FyL2FwaScpLkNhclJlYWRlcn0gQ2FyUmVhZGVyXG4gKiBAaW1wbGVtZW50cyB7Q2FyUmVhZGVyfVxuICovXG5leHBvcnQgY2xhc3MgQmxvY2tzdG9yZUNhclJlYWRlciB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge251bWJlcn0gdmVyc2lvblxuICAgKiBAcGFyYW0ge0NJRFtdfSByb290c1xuICAgKiBAcGFyYW0ge2ltcG9ydCgnaXBmcy1jYXIvYmxvY2tzdG9yZScpLkJsb2Nrc3RvcmV9IGJsb2Nrc3RvcmVcbiAgICovXG4gIGNvbnN0cnVjdG9yKHZlcnNpb24sIHJvb3RzLCBibG9ja3N0b3JlKSB7XG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLl92ZXJzaW9uID0gdmVyc2lvblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5fcm9vdHMgPSByb290c1xuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5fYmxvY2tzdG9yZSA9IGJsb2Nrc3RvcmVcbiAgfVxuXG4gIGdldCB2ZXJzaW9uKCkge1xuICAgIHJldHVybiB0aGlzLl92ZXJzaW9uXG4gIH1cblxuICBnZXQgYmxvY2tzdG9yZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fYmxvY2tzdG9yZVxuICB9XG5cbiAgYXN5bmMgZ2V0Um9vdHMoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3Jvb3RzXG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtDSUR9IGNpZFxuICAgKi9cbiAgaGFzKGNpZCkge1xuICAgIHJldHVybiB0aGlzLl9ibG9ja3N0b3JlLmhhcyhjaWQpXG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtDSUR9IGNpZFxuICAgKi9cbiAgYXN5bmMgZ2V0KGNpZCkge1xuICAgIGNvbnN0IGJ5dGVzID0gYXdhaXQgdGhpcy5fYmxvY2tzdG9yZS5nZXQoY2lkKVxuICAgIHJldHVybiB7IGNpZCwgYnl0ZXMgfVxuICB9XG5cbiAgYmxvY2tzKCkge1xuICAgIHJldHVybiB0aGlzLl9ibG9ja3N0b3JlLmJsb2NrcygpXG4gIH1cblxuICBhc3luYyAqY2lkcygpIHtcbiAgICBmb3IgYXdhaXQgKGNvbnN0IGIgb2YgdGhpcy5ibG9ja3MoKSkge1xuICAgICAgeWllbGQgYi5jaWRcbiAgICB9XG4gIH1cbn1cbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/nft.storage/src/bs-car-reader.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/nft.storage/src/gateway.js":
/*!*************************************************!*\
  !*** ./node_modules/nft.storage/src/gateway.js ***!
  \*************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   GATEWAY: () => (/* binding */ GATEWAY),\n/* harmony export */   toGatewayURL: () => (/* binding */ toGatewayURL)\n/* harmony export */ });\nconst GATEWAY = new URL('https://nftstorage.link/')\n\n/**\n * @typedef {string|URL} GatewayURL Base URL of an IPFS Gateway e.g. https://dweb.link/ or https://ipfs.io/\n * @typedef {{ gateway?: GatewayURL }} GatewayURLOptions\n */\n\n/**\n * Convert an IPFS URL (starting ipfs://) to a gateway URL (starting https://)\n * that can be used in a webpage. If the passed URL is not an IPFS URL it is\n * returned as a new URL object with no further changes.\n *\n * @param {string|URL} url An IPFS URL e.g. ipfs://bafy.../path\n * @param {GatewayURLOptions} [options] Options that allow customization of the gateway used.\n * @returns {URL} An IPFS gateway URL e.g. https://nftstorage.link/ipfs/bafy.../path\n */\nconst toGatewayURL = (url, options = {}) => {\n  const gateway = options.gateway || GATEWAY\n  url = new URL(String(url))\n  return url.protocol === 'ipfs:'\n    ? new URL(`/ipfs/${url.href.slice('ipfs://'.length)}`, gateway)\n    : url\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbmZ0LnN0b3JhZ2Uvc3JjL2dhdGV3YXkuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBTzs7QUFFUDtBQUNBLGFBQWEsWUFBWTtBQUN6QixlQUFlLHdCQUF3QjtBQUN2Qzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxZQUFZO0FBQ3ZCLFdBQVcsbUJBQW1CO0FBQzlCLGFBQWEsS0FBSztBQUNsQjtBQUNPLHVDQUF1QztBQUM5QztBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsaUNBQWlDO0FBQ3hEO0FBQ0EiLCJzb3VyY2VzIjpbIi9ob21lL2FsdGNvaW4tZGFkZHkvRG93bmxvYWRzL293bmx5L25vZGVfbW9kdWxlcy9uZnQuc3RvcmFnZS9zcmMvZ2F0ZXdheS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgY29uc3QgR0FURVdBWSA9IG5ldyBVUkwoJ2h0dHBzOi8vbmZ0c3RvcmFnZS5saW5rLycpXG5cbi8qKlxuICogQHR5cGVkZWYge3N0cmluZ3xVUkx9IEdhdGV3YXlVUkwgQmFzZSBVUkwgb2YgYW4gSVBGUyBHYXRld2F5IGUuZy4gaHR0cHM6Ly9kd2ViLmxpbmsvIG9yIGh0dHBzOi8vaXBmcy5pby9cbiAqIEB0eXBlZGVmIHt7IGdhdGV3YXk/OiBHYXRld2F5VVJMIH19IEdhdGV3YXlVUkxPcHRpb25zXG4gKi9cblxuLyoqXG4gKiBDb252ZXJ0IGFuIElQRlMgVVJMIChzdGFydGluZyBpcGZzOi8vKSB0byBhIGdhdGV3YXkgVVJMIChzdGFydGluZyBodHRwczovLylcbiAqIHRoYXQgY2FuIGJlIHVzZWQgaW4gYSB3ZWJwYWdlLiBJZiB0aGUgcGFzc2VkIFVSTCBpcyBub3QgYW4gSVBGUyBVUkwgaXQgaXNcbiAqIHJldHVybmVkIGFzIGEgbmV3IFVSTCBvYmplY3Qgd2l0aCBubyBmdXJ0aGVyIGNoYW5nZXMuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd8VVJMfSB1cmwgQW4gSVBGUyBVUkwgZS5nLiBpcGZzOi8vYmFmeS4uLi9wYXRoXG4gKiBAcGFyYW0ge0dhdGV3YXlVUkxPcHRpb25zfSBbb3B0aW9uc10gT3B0aW9ucyB0aGF0IGFsbG93IGN1c3RvbWl6YXRpb24gb2YgdGhlIGdhdGV3YXkgdXNlZC5cbiAqIEByZXR1cm5zIHtVUkx9IEFuIElQRlMgZ2F0ZXdheSBVUkwgZS5nLiBodHRwczovL25mdHN0b3JhZ2UubGluay9pcGZzL2JhZnkuLi4vcGF0aFxuICovXG5leHBvcnQgY29uc3QgdG9HYXRld2F5VVJMID0gKHVybCwgb3B0aW9ucyA9IHt9KSA9PiB7XG4gIGNvbnN0IGdhdGV3YXkgPSBvcHRpb25zLmdhdGV3YXkgfHwgR0FURVdBWVxuICB1cmwgPSBuZXcgVVJMKFN0cmluZyh1cmwpKVxuICByZXR1cm4gdXJsLnByb3RvY29sID09PSAnaXBmczonXG4gICAgPyBuZXcgVVJMKGAvaXBmcy8ke3VybC5ocmVmLnNsaWNlKCdpcGZzOi8vJy5sZW5ndGgpfWAsIGdhdGV3YXkpXG4gICAgOiB1cmxcbn1cbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/nft.storage/src/gateway.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/nft.storage/src/lib.js":
/*!*********************************************!*\
  !*** ./node_modules/nft.storage/src/lib.js ***!
  \*********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Blob: () => (/* reexport safe */ _platform_js__WEBPACK_IMPORTED_MODULE_7__.Blob),\n/* harmony export */   File: () => (/* reexport safe */ _platform_js__WEBPACK_IMPORTED_MODULE_7__.File),\n/* harmony export */   FormData: () => (/* reexport safe */ _platform_js__WEBPACK_IMPORTED_MODULE_7__.FormData),\n/* harmony export */   NFTStorage: () => (/* binding */ NFTStorage),\n/* harmony export */   Token: () => (/* reexport module object */ _token_js__WEBPACK_IMPORTED_MODULE_6__),\n/* harmony export */   createRateLimiter: () => (/* binding */ createRateLimiter),\n/* harmony export */   toAsyncIterable: () => (/* binding */ toAsyncIterable),\n/* harmony export */   toGatewayURL: () => (/* reexport safe */ _gateway_js__WEBPACK_IMPORTED_MODULE_8__.toGatewayURL)\n/* harmony export */ });\n/* harmony import */ var streaming_iterables__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! streaming-iterables */ \"(rsc)/./node_modules/streaming-iterables/dist/index.mjs\");\n/* harmony import */ var p_retry__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! p-retry */ \"(rsc)/./node_modules/p-retry/index.js\");\n/* harmony import */ var carbites_treewalk__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! carbites/treewalk */ \"(rsc)/./node_modules/carbites/esm/lib/treewalk/index.js\");\n/* harmony import */ var ipfs_car_pack__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ipfs-car/pack */ \"(rsc)/./node_modules/ipfs-car/dist/esm/pack/index.js\");\n/* harmony import */ var multiformats_cid__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! multiformats/cid */ \"(rsc)/./node_modules/multiformats/esm/src/cid.js\");\n/* harmony import */ var throttled_queue__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! throttled-queue */ \"(rsc)/./node_modules/throttled-queue/dist/throttledQueue.js\");\n/* harmony import */ var _token_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./token.js */ \"(rsc)/./node_modules/nft.storage/src/token.js\");\n/* harmony import */ var _platform_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./platform.js */ \"(rsc)/./node_modules/nft.storage/src/platform.js\");\n/* harmony import */ var _gateway_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./gateway.js */ \"(rsc)/./node_modules/nft.storage/src/gateway.js\");\n/* harmony import */ var _bs_car_reader_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./bs-car-reader.js */ \"(rsc)/./node_modules/nft.storage/src/bs-car-reader.js\");\n/* harmony import */ var it_pipe__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! it-pipe */ \"(rsc)/./node_modules/it-pipe/index.js\");\n/**\n * A client library for the https://nft.storage/ service. It provides a convenient\n * interface for working with the [Raw HTTP API](https://nft.storage/#api-docs)\n * from a web browser or [Node.js](https://nodejs.org/) and comes bundled with\n * TS for out-of-the box type inference and better IntelliSense.\n *\n * @example\n * ```js\n * import { NFTStorage, File, Blob } from \"nft.storage\"\n * const client = new NFTStorage({ token: API_TOKEN })\n *\n * const cid = await client.storeBlob(new Blob(['hello world']))\n * ```\n * @module\n */\n\n\n\n\n\n\n\n\n\n\n\n\n\nconst MAX_STORE_RETRIES = 5\nconst MAX_CONCURRENT_UPLOADS = 3\nconst MAX_CHUNK_SIZE = 1024 * 1024 * 50 // chunk to ~50MB CARs\nconst RATE_LIMIT_REQUESTS = 30\nconst RATE_LIMIT_PERIOD = 10 * 1000\n\n/**\n * @typedef {import('./lib/interface.js').Service} Service\n * @typedef {import('./lib/interface.js').CIDString} CIDString\n * @typedef {import('./lib/interface.js').Deal} Deal\n * @typedef {import('./lib/interface.js').FileObject} FileObject\n * @typedef {import('./lib/interface.js').FilesSource} FilesSource\n * @typedef {import('./lib/interface.js').Pin} Pin\n * @typedef {import('./lib/interface.js').CarReader} CarReader\n * @typedef {import('ipfs-car/blockstore').Blockstore} BlockstoreI\n * @typedef {import('./lib/interface.js').RateLimiter} RateLimiter\n * @typedef {import('./lib/interface.js').RequestOptions} RequestOptions\n */\n\n/**\n * @returns {RateLimiter}\n */\nfunction createRateLimiter() {\n  const throttle = throttled_queue__WEBPACK_IMPORTED_MODULE_5__(RATE_LIMIT_REQUESTS, RATE_LIMIT_PERIOD)\n  return () => throttle(() => {})\n}\n\n/**\n * Rate limiter used by static API if no rate limiter is passed. Note that each\n * instance of the NFTStorage class gets it's own limiter if none is passed.\n * This is because rate limits are enforced per API token.\n */\nconst globalRateLimiter = createRateLimiter()\n\n/**\n * @template {import('./lib/interface.js').TokenInput} T\n * @typedef {import('./lib/interface.js').Token<T>} TokenType\n */\n\n/**\n * @implements {Service}\n */\nclass NFTStorage {\n  /**\n   * Constructs a client bound to the given `options.token` and\n   * `options.endpoint`.\n   *\n   * @example\n   * ```js\n   * import { NFTStorage, File, Blob } from \"nft.storage\"\n   * const client = new NFTStorage({ token: API_TOKEN })\n   *\n   * const cid = await client.storeBlob(new Blob(['hello world']))\n   * ```\n   * Optionally you could pass an alternative API endpoint (e.g. for testing)\n   * @example\n   * ```js\n   * import { NFTStorage } from \"nft.storage\"\n   * const client = new NFTStorage({\n   *   token: API_TOKEN\n   *   endpoint: new URL('http://localhost:8080/')\n   * })\n   * ```\n   *\n   * @param {{token: string, endpoint?: URL, rateLimiter?: RateLimiter, did?: string}} options\n   */\n  constructor({\n    token,\n    did,\n    endpoint = new URL('https://api.nft.storage'),\n    rateLimiter,\n  }) {\n    /**\n     * Authorization token.\n     *\n     * @readonly\n     */\n    this.token = token\n    /**\n     * Service API endpoint `URL`.\n     * @readonly\n     */\n    this.endpoint = endpoint\n    /**\n     * @readonly\n     */\n    this.rateLimiter = rateLimiter || createRateLimiter()\n\n    /**\n     * @readonly\n     */\n    this.did = did\n  }\n\n  /**\n   * @hidden\n   * @param {object} options\n   * @param {string} options.token\n   * @param {string} [options.did]\n   */\n  static auth({ token, did }) {\n    if (!token) throw new Error('missing token')\n    return {\n      Authorization: `Bearer ${token}`,\n      'X-Client': 'nft.storage/js',\n      ...(did ? { 'x-agent-did': did } : {}),\n    }\n  }\n\n  /**\n   * Stores a single file and returns its CID.\n   *\n   * @param {Service} service\n   * @param {Blob} blob\n   * @param {RequestOptions} [options]\n   * @returns {Promise<CIDString>}\n   */\n  static async storeBlob(service, blob, options) {\n    const blockstore = new _platform_js__WEBPACK_IMPORTED_MODULE_7__.Blockstore()\n    let cidString\n\n    try {\n      const { cid, car } = await NFTStorage.encodeBlob(blob, { blockstore })\n      await NFTStorage.storeCar(service, car, options)\n      cidString = cid.toString()\n    } finally {\n      await blockstore.close()\n    }\n\n    return cidString\n  }\n\n  /**\n   * Stores a CAR file and returns its root CID.\n   *\n   * @param {Service} service\n   * @param {Blob|CarReader} car\n   * @param {import('./lib/interface.js').CarStorerOptions} [options]\n   * @returns {Promise<CIDString>}\n   */\n  static async storeCar(\n    { endpoint, rateLimiter = globalRateLimiter, ...token },\n    car,\n    { onStoredChunk, maxRetries, maxChunkSize, decoders, signal } = {}\n  ) {\n    const url = new URL('upload/', endpoint)\n    const headers = {\n      ...NFTStorage.auth(token),\n      'Content-Type': 'application/car',\n    }\n    const targetSize = maxChunkSize || MAX_CHUNK_SIZE\n    const splitter =\n      car instanceof _platform_js__WEBPACK_IMPORTED_MODULE_7__.Blob\n        ? await carbites_treewalk__WEBPACK_IMPORTED_MODULE_2__.TreewalkCarSplitter.fromBlob(car, targetSize, { decoders })\n        : new carbites_treewalk__WEBPACK_IMPORTED_MODULE_2__.TreewalkCarSplitter(car, targetSize, { decoders })\n\n    const upload = (0,streaming_iterables__WEBPACK_IMPORTED_MODULE_0__.transform)(\n      MAX_CONCURRENT_UPLOADS,\n      async function (/** @type {AsyncIterable<Uint8Array>} */ car) {\n        const carParts = []\n        for await (const part of car) {\n          carParts.push(part)\n        }\n        const carFile = new _platform_js__WEBPACK_IMPORTED_MODULE_7__.Blob(carParts, { type: 'application/car' })\n        /** @type {Blob|ArrayBuffer} */\n        let body = carFile\n        // FIXME: should not be necessary to await arrayBuffer()!\n        // Node.js 20 hangs reading the stream (it never ends) but in\n        // older node versions and the browser it is fine to pass a blob.\n        /* c8 ignore next 3 */\n        if (parseInt(globalThis.process?.versions?.node) > 18) {\n          body = await body.arrayBuffer()\n        }\n        const cid = await p_retry__WEBPACK_IMPORTED_MODULE_1__(\n          async () => {\n            await rateLimiter()\n            /** @type {Response} */\n            let response\n            try {\n              response = await (0,_platform_js__WEBPACK_IMPORTED_MODULE_7__.fetch)(url.toString(), {\n                method: 'POST',\n                headers,\n                body,\n                signal,\n              })\n            } catch (/** @type {any} */ err) {\n              // TODO: remove me and test when client accepts custom fetch impl\n              /* c8 ignore next 1 */\n              throw signal && signal.aborted ? new p_retry__WEBPACK_IMPORTED_MODULE_1__.AbortError(err) : err\n            }\n            /* c8 ignore next 3 */\n            if (response.status === 429) {\n              throw new Error('rate limited')\n            }\n            const result = await response.json()\n            if (!result.ok) {\n              // do not retry if unauthorized - will not succeed\n              if (response.status === 401) {\n                throw new p_retry__WEBPACK_IMPORTED_MODULE_1__.AbortError(result.error.message)\n              }\n              throw new Error(result.error.message)\n            }\n            return result.value.cid\n          },\n          {\n            retries: maxRetries == null ? MAX_STORE_RETRIES : maxRetries,\n          }\n        )\n        onStoredChunk && onStoredChunk(carFile.size)\n        return cid\n      }\n    )\n\n    let root\n    for await (const cid of upload(splitter.cars())) {\n      root = cid\n    }\n\n    return /** @type {CIDString} */ (root)\n  }\n\n  /**\n   * Stores a directory of files and returns a CID. Provided files **MUST**\n   * be within the same directory, otherwise error is raised e.g. `foo/bar.png`,\n   * `foo/bla/baz.json` is ok but `foo/bar.png`, `bla/baz.json` is not.\n   *\n   * @param {Service} service\n   * @param {FilesSource} filesSource\n   * @param {RequestOptions} [options]\n   * @returns {Promise<CIDString>}\n   */\n  static async storeDirectory(service, filesSource, options) {\n    const blockstore = new _platform_js__WEBPACK_IMPORTED_MODULE_7__.Blockstore()\n    let cidString\n    try {\n      const { cid, car } = await NFTStorage.encodeDirectory(filesSource, {\n        blockstore,\n      })\n      await NFTStorage.storeCar(service, car, options)\n      cidString = cid.toString()\n    } finally {\n      await blockstore.close()\n    }\n\n    return cidString\n  }\n\n  /**\n   * Stores the given token and all resources it references (in the form of a\n   * File or a Blob) along with a metadata JSON as specificed in ERC-1155. The\n   * `token.image` must be either a `File` or a `Blob` instance, which will be\n   * stored and the corresponding content address URL will be saved in the\n   * metadata JSON file under `image` field.\n   *\n   * If `token.properties` contains properties with `File` or `Blob` values,\n   * those also get stored and their URLs will be saved in the metadata JSON\n   * file in their place.\n   *\n   * Note: URLs for `File` objects will retain file names e.g. in case of\n   * `new File([bytes], 'cat.png', { type: 'image/png' })` will be transformed\n   * into a URL that looks like `ipfs://bafy...hash/image/cat.png`. For `Blob`\n   * objects, the URL will not have a file name name or mime type, instead it\n   * will be transformed into a URL that looks like\n   * `ipfs://bafy...hash/image/blob`.\n   *\n   * @template {import('./lib/interface.js').TokenInput} T\n   * @param {Service} service\n   * @param {T} metadata\n   * @param {RequestOptions} [options]\n   * @returns {Promise<TokenType<T>>}\n   */\n  static async store(service, metadata, options) {\n    const { token, car } = await NFTStorage.encodeNFT(metadata)\n    await NFTStorage.storeCar(service, car, options)\n    return token\n  }\n\n  /**\n   * Returns current status of the stored NFT by its CID. Note the NFT must\n   * have previously been stored by this account.\n   *\n   * @param {Service} service\n   * @param {string} cid\n   * @param {RequestOptions} [options]\n   * @returns {Promise<import('./lib/interface.js').StatusResult>}\n   */\n  static async status(\n    { endpoint, rateLimiter = globalRateLimiter, ...token },\n    cid,\n    options\n  ) {\n    const url = new URL(`${cid}/`, endpoint)\n    await rateLimiter()\n    const response = await (0,_platform_js__WEBPACK_IMPORTED_MODULE_7__.fetch)(url.toString(), {\n      method: 'GET',\n      headers: NFTStorage.auth(token),\n      signal: options && options.signal,\n    })\n    /* c8 ignore next 3 */\n    if (response.status === 429) {\n      throw new Error('rate limited')\n    }\n    const result = await response.json()\n\n    if (result.ok) {\n      return {\n        cid: result.value.cid,\n        deals: decodeDeals(result.value.deals),\n        size: result.value.size,\n        pin: decodePin(result.value.pin),\n        created: new Date(result.value.created),\n      }\n    } else {\n      throw new Error(result.error.message)\n    }\n  }\n\n  /**\n   * Check if a CID of an NFT is being stored by NFT.Storage.\n   *\n   * @param {import('./lib/interface.js').PublicService} service\n   * @param {string} cid\n   * @param {RequestOptions} [options]\n   * @returns {Promise<import('./lib/interface.js').CheckResult>}\n   */\n  static async check(\n    { endpoint, rateLimiter = globalRateLimiter },\n    cid,\n    options\n  ) {\n    const url = new URL(`check/${cid}/`, endpoint)\n    await rateLimiter()\n    const response = await (0,_platform_js__WEBPACK_IMPORTED_MODULE_7__.fetch)(url.toString(), {\n      signal: options && options.signal,\n    })\n    /* c8 ignore next 3 */\n    if (response.status === 429) {\n      throw new Error('rate limited')\n    }\n    const result = await response.json()\n\n    if (result.ok) {\n      return {\n        cid: result.value.cid,\n        deals: decodeDeals(result.value.deals),\n        pin: result.value.pin,\n      }\n    } else {\n      throw new Error(result.error.message)\n    }\n  }\n\n  /**\n   * Removes stored content by its CID from this account. Please note that\n   * even if content is removed from the service other nodes that have\n   * replicated it might still continue providing it.\n   *\n   * @param {Service} service\n   * @param {string} cid\n   * @param {RequestOptions} [options]\n   * @returns {Promise<void>}\n   */\n  static async delete(\n    { endpoint, rateLimiter = globalRateLimiter, ...token },\n    cid,\n    options\n  ) {\n    const url = new URL(`${cid}/`, endpoint)\n    await rateLimiter()\n    const response = await (0,_platform_js__WEBPACK_IMPORTED_MODULE_7__.fetch)(url.toString(), {\n      method: 'DELETE',\n      headers: NFTStorage.auth(token),\n      signal: options && options.signal,\n    })\n    /* c8 ignore next 3 */\n    if (response.status === 429) {\n      throw new Error('rate limited')\n    }\n    const result = await response.json()\n    if (!result.ok) {\n      throw new Error(result.error.message)\n    }\n  }\n\n  /**\n   * Encodes the given token and all resources it references (in the form of a\n   * File or a Blob) along with a metadata JSON as specificed in ERC-1155 to a\n   * CAR file. The `token.image` must be either a `File` or a `Blob` instance,\n   * which will be stored and the corresponding content address URL will be\n   * saved in the metadata JSON file under `image` field.\n   *\n   * If `token.properties` contains properties with `File` or `Blob` values,\n   * those also get stored and their URLs will be saved in the metadata JSON\n   * file in their place.\n   *\n   * Note: URLs for `File` objects will retain file names e.g. in case of\n   * `new File([bytes], 'cat.png', { type: 'image/png' })` will be transformed\n   * into a URL that looks like `ipfs://bafy...hash/image/cat.png`. For `Blob`\n   * objects, the URL will not have a file name name or mime type, instead it\n   * will be transformed into a URL that looks like\n   * `ipfs://bafy...hash/image/blob`.\n   *\n   * @example\n   * ```js\n   * const { token, car } = await NFTStorage.encodeNFT({\n   *   name: 'nft.storage store test',\n   *   description: 'Test ERC-1155 compatible metadata.',\n   *   image: new File(['<DATA>'], 'pinpie.jpg', { type: 'image/jpg' }),\n   *   properties: {\n   *     custom: 'Custom data can appear here, files are auto uploaded.',\n   *     file: new File(['<DATA>'], 'README.md', { type: 'text/plain' }),\n   *   }\n   * })\n   *\n   * console.log('IPFS URL for the metadata:', token.url)\n   * console.log('metadata.json contents:\\n', token.data)\n   * console.log('metadata.json with IPFS gateway URLs:\\n', token.embed())\n   *\n   * // Now store the CAR file on NFT.Storage\n   * await client.storeCar(car)\n   * ```\n   *\n   * @template {import('./lib/interface.js').TokenInput} T\n   * @param {T} input\n   * @returns {Promise<{ cid: CID, token: TokenType<T>, car: CarReader }>}\n   */\n  static async encodeNFT(input) {\n    validateERC1155(input)\n    return _token_js__WEBPACK_IMPORTED_MODULE_6__.Token.encode(input)\n  }\n\n  /**\n   * Encodes a single file to a CAR file and also returns its root CID.\n   *\n   * @example\n   * ```js\n   * const content = new Blob(['hello world'])\n   * const { cid, car } = await NFTStorage.encodeBlob(content)\n   *\n   * // Root CID of the file\n   * console.log(cid.toString())\n   *\n   * // Now store the CAR file on NFT.Storage\n   * await client.storeCar(car)\n   * ```\n   *\n   * @param {Blob} blob\n   * @param {object} [options]\n   * @param {BlockstoreI} [options.blockstore]\n   * @returns {Promise<{ cid: CID, car: CarReader }>}\n   */\n  static async encodeBlob(blob, { blockstore } = {}) {\n    if (blob.size === 0) {\n      throw new Error('Content size is 0, make sure to provide some content')\n    }\n    return packCar([toImportCandidate('blob', blob)], {\n      blockstore,\n      wrapWithDirectory: false,\n    })\n  }\n\n  /**\n   * Encodes a directory of files to a CAR file and also returns the root CID.\n   * Provided files **MUST** be within the same directory, otherwise error is\n   * raised e.g. `foo/bar.png`, `foo/bla/baz.json` is ok but `foo/bar.png`,\n   * `bla/baz.json` is not.\n   *\n   * @example\n   * ```js\n   * const { cid, car } = await NFTStorage.encodeDirectory([\n   *   new File(['hello world'], 'hello.txt'),\n   *   new File([JSON.stringify({'from': 'incognito'}, null, 2)], 'metadata.json')\n   * ])\n   *\n   * // Root CID of the directory\n   * console.log(cid.toString())\n   *\n   * // Now store the CAR file on NFT.Storage\n   * await client.storeCar(car)\n   * ```\n   *\n   * @param {FilesSource} files\n   * @param {object} [options]\n   * @param {BlockstoreI} [options.blockstore]\n   * @returns {Promise<{ cid: CID, car: CarReader }>}\n   */\n  static async encodeDirectory(files, { blockstore } = {}) {\n    let size = 0\n    const input = it_pipe__WEBPACK_IMPORTED_MODULE_10__(files, async function* (files) {\n      for await (const file of files) {\n        yield toImportCandidate(file.name, file)\n        size += file.size\n      }\n    })\n    const packed = await packCar(input, {\n      blockstore,\n      wrapWithDirectory: true,\n    })\n    if (size === 0) {\n      throw new Error(\n        'Total size of files should exceed 0, make sure to provide some content'\n      )\n    }\n    return packed\n  }\n\n  // Just a sugar so you don't have to pass around endpoint and token around.\n\n  /**\n   * Stores a single file and returns the corresponding Content Identifier (CID).\n   * Takes a [Blob](https://developer.mozilla.org/en-US/docs/Web/API/Blob/Blob)\n   * or a [File](https://developer.mozilla.org/en-US/docs/Web/API/File). Note\n   * that no file name or file metadata is retained.\n   *\n   * @example\n   * ```js\n   * const content = new Blob(['hello world'])\n   * const cid = await client.storeBlob(content)\n   * cid //> 'zdj7Wn9FQAURCP6MbwcWuzi7u65kAsXCdjNTkhbJcoaXBusq9'\n   * ```\n   *\n   * @param {Blob} blob\n   * @param {RequestOptions} [options]\n   */\n  storeBlob(blob, options) {\n    return NFTStorage.storeBlob(this, blob, options)\n  }\n\n  /**\n   * Stores files encoded as a single [Content Addressed Archive\n   * (CAR)](https://github.com/ipld/specs/blob/master/block-layer/content-addressable-archives.md).\n   *\n   * Takes a [Blob](https://developer.mozilla.org/en-US/docs/Web/API/Blob/Blob)\n   * or a [File](https://developer.mozilla.org/en-US/docs/Web/API/File).\n   *\n   * Returns the corresponding Content Identifier (CID).\n   *\n   * See the [`ipfs-car` docs](https://www.npmjs.com/package/ipfs-car) for more\n   * details on packing a CAR file.\n   *\n   * @example\n   * ```js\n   * import { pack } from 'ipfs-car/pack'\n   * import { CarReader } from '@ipld/car'\n   * const { out, root } = await pack({\n   *  input: fs.createReadStream('pinpie.pdf')\n   * })\n   * const expectedCid = root.toString()\n   * const carReader = await CarReader.fromIterable(out)\n   * const cid = await storage.storeCar(carReader)\n   * console.assert(cid === expectedCid)\n   * ```\n   *\n   * @example\n   * ```\n   * import { packToBlob } from 'ipfs-car/pack/blob'\n   * const data = 'Hello world'\n   * const { root, car } = await packToBlob({ input: [new TextEncoder().encode(data)] })\n   * const expectedCid = root.toString()\n   * const cid = await client.storeCar(car)\n   * console.assert(cid === expectedCid)\n   * ```\n   * @param {Blob|CarReader} car\n   * @param {import('./lib/interface.js').CarStorerOptions} [options]\n   */\n  storeCar(car, options) {\n    return NFTStorage.storeCar(this, car, options)\n  }\n\n  /**\n   * Stores a directory of files and returns a CID for the directory.\n   *\n   * @example\n   * ```js\n   * const cid = await client.storeDirectory([\n   *   new File(['hello world'], 'hello.txt'),\n   *   new File([JSON.stringify({'from': 'incognito'}, null, 2)], 'metadata.json')\n   * ])\n   * cid //>\n   * ```\n   *\n   * Argument can be a [FileList](https://developer.mozilla.org/en-US/docs/Web/API/FileList)\n   * instance as well, in which case directory structure will be retained.\n   *\n   * @param {FilesSource} files\n   * @param {RequestOptions} [options]\n   */\n  storeDirectory(files, options) {\n    return NFTStorage.storeDirectory(this, files, options)\n  }\n\n  /**\n   * Returns current status of the stored NFT by its CID. Note the NFT must\n   * have previously been stored by this account.\n   *\n   * @example\n   * ```js\n   * const status = await client.status('zdj7Wn9FQAURCP6MbwcWuzi7u65kAsXCdjNTkhbJcoaXBusq9')\n   * ```\n   *\n   * @param {string} cid\n   * @param {RequestOptions} [options]\n   */\n  status(cid, options) {\n    return NFTStorage.status(this, cid, options)\n  }\n\n  /**\n   * Removes stored content by its CID from the service.\n   *\n   * > Please note that even if content is removed from the service other nodes\n   * that have replicated it might still continue providing it.\n   *\n   * @example\n   * ```js\n   * await client.delete('zdj7Wn9FQAURCP6MbwcWuzi7u65kAsXCdjNTkhbJcoaXBusq9')\n   * ```\n   *\n   * @param {string} cid\n   * @param {RequestOptions} [options]\n   */\n  delete(cid, options) {\n    return NFTStorage.delete(this, cid, options)\n  }\n\n  /**\n   * Check if a CID of an NFT is being stored by nft.storage. Throws if the NFT\n   * was not found.\n   *\n   * @example\n   * ```js\n   * const status = await client.check('zdj7Wn9FQAURCP6MbwcWuzi7u65kAsXCdjNTkhbJcoaXBusq9')\n   * ```\n   *\n   * @param {string} cid\n   * @param {RequestOptions} [options]\n   */\n  check(cid, options) {\n    return NFTStorage.check(this, cid, options)\n  }\n\n  /**\n   * Stores the given token and all resources it references (in the form of a\n   * File or a Blob) along with a metadata JSON as specificed in\n   * [ERC-1155](https://eips.ethereum.org/EIPS/eip-1155#metadata). The\n   * `token.image` must be either a `File` or a `Blob` instance, which will be\n   * stored and the corresponding content address URL will be saved in the\n   * metadata JSON file under `image` field.\n   *\n   * If `token.properties` contains properties with `File` or `Blob` values,\n   * those also get stored and their URLs will be saved in the metadata JSON\n   * file in their place.\n   *\n   * Note: URLs for `File` objects will retain file names e.g. in case of\n   * `new File([bytes], 'cat.png', { type: 'image/png' })` will be transformed\n   * into a URL that looks like `ipfs://bafy...hash/image/cat.png`. For `Blob`\n   * objects, the URL will not have a file name name or mime type, instead it\n   * will be transformed into a URL that looks like\n   * `ipfs://bafy...hash/image/blob`.\n   *\n   * @example\n   * ```js\n   * const metadata = await client.store({\n   *   name: 'nft.storage store test',\n   *   description: 'Test ERC-1155 compatible metadata.',\n   *   image: new File(['<DATA>'], 'pinpie.jpg', { type: 'image/jpg' }),\n   *   properties: {\n   *     custom: 'Custom data can appear here, files are auto uploaded.',\n   *     file: new File(['<DATA>'], 'README.md', { type: 'text/plain' }),\n   *   }\n   * })\n   *\n   * console.log('IPFS URL for the metadata:', metadata.url)\n   * console.log('metadata.json contents:\\n', metadata.data)\n   * console.log('metadata.json with IPFS gateway URLs:\\n', metadata.embed())\n   * ```\n   *\n   * @template {import('./lib/interface.js').TokenInput} T\n   * @param {T} token\n   * @param {RequestOptions} [options]\n   */\n  store(token, options) {\n    return NFTStorage.store(this, token, options)\n  }\n}\n\n/**\n * Cast an iterable to an asyncIterable\n * @template T\n * @param {Iterable<T>} iterable\n * @returns {AsyncIterable<T>}\n */\nfunction toAsyncIterable(iterable) {\n  return (async function* () {\n    for (const item of iterable) {\n      yield item\n    }\n  })()\n}\n\n/**\n * @template {import('./lib/interface.js').TokenInput} T\n * @param {T} metadata\n */\nconst validateERC1155 = ({ name, description, image, decimals }) => {\n  // Just validate that expected fields are present\n  if (typeof name !== 'string') {\n    throw new TypeError(\n      'string property `name` identifying the asset is required'\n    )\n  }\n  if (typeof description !== 'string') {\n    throw new TypeError(\n      'string property `description` describing asset is required'\n    )\n  }\n  if (!(image instanceof _platform_js__WEBPACK_IMPORTED_MODULE_7__.Blob)) {\n    throw new TypeError('property `image` must be a Blob or File object')\n  } else if (!image.type.startsWith('image/')) {\n    console.warn(`According to ERC721 Metadata JSON Schema 'image' must have 'image/*' mime type.\n\nFor better interoperability we would highly recommend storing content with different mime type under 'properties' namespace e.g. \\`properties: { video: file }\\` and using 'image' field for storing a preview image for it instead.\n\nFor more context please see ERC-721 specification https://eips.ethereum.org/EIPS/eip-721`)\n  }\n\n  if (typeof decimals !== 'undefined' && typeof decimals !== 'number') {\n    throw new TypeError('property `decimals` must be an integer value')\n  }\n}\n\n/**\n * @param {import('ipfs-car/pack').ImportCandidateStream|Array<{ path: string, content: import('./platform.js').ReadableStream }>} input\n * @param {object} [options]\n * @param {BlockstoreI} [options.blockstore]\n * @param {boolean} [options.wrapWithDirectory]\n */\nconst packCar = async (input, { blockstore, wrapWithDirectory } = {}) => {\n  /* c8 ignore next 1 */\n  blockstore = blockstore || new _platform_js__WEBPACK_IMPORTED_MODULE_7__.Blockstore()\n  const { root: cid } = await (0,ipfs_car_pack__WEBPACK_IMPORTED_MODULE_3__.pack)({ input, blockstore, wrapWithDirectory })\n  const car = new _bs_car_reader_js__WEBPACK_IMPORTED_MODULE_9__.BlockstoreCarReader(1, [cid], blockstore)\n  return { cid, car }\n}\n\n/**\n * @param {Deal[]} deals\n * @returns {Deal[]}\n */\nconst decodeDeals = (deals) =>\n  deals.map((deal) => {\n    const { dealActivation, dealExpiration, lastChanged } = {\n      dealExpiration: null,\n      dealActivation: null,\n      ...deal,\n    }\n\n    return {\n      ...deal,\n      lastChanged: new Date(lastChanged),\n      ...(dealActivation && { dealActivation: new Date(dealActivation) }),\n      ...(dealExpiration && { dealExpiration: new Date(dealExpiration) }),\n    }\n  })\n\n/**\n * @param {Pin} pin\n * @returns {Pin}\n */\nconst decodePin = (pin) => ({ ...pin, created: new Date(pin.created) })\n\n/**\n * Convert the passed blob to an \"import candidate\" - an object suitable for\n * passing to the ipfs-unixfs-importer. Note: content is an accessor so that\n * the stream is created only when needed.\n *\n * @param {string} path\n * @param {Pick<Blob, 'stream'>|{ stream: () => AsyncIterable<Uint8Array> }} blob\n * @returns {import('ipfs-core-types/src/utils.js').ImportCandidate}\n */\nfunction toImportCandidate(path, blob) {\n  /** @type {AsyncIterable<Uint8Array>} */\n  let stream\n  return {\n    path,\n    get content() {\n      stream = stream || blob.stream()\n      return stream\n    },\n  }\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbmZ0LnN0b3JhZ2Uvc3JjL2xpYi5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVkseUJBQXlCO0FBQ3JDLG1DQUFtQyxrQkFBa0I7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFK0M7QUFDSDtBQUNXO0FBQ25CO0FBQ0U7QUFDTTtBQUNUO0FBQ29DO0FBQzVCO0FBQ2E7QUFDOUI7O0FBRTFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxhQUFhLHNDQUFzQztBQUNuRCxhQUFhLHdDQUF3QztBQUNyRCxhQUFhLG1DQUFtQztBQUNoRCxhQUFhLHlDQUF5QztBQUN0RCxhQUFhLDBDQUEwQztBQUN2RCxhQUFhLGtDQUFrQztBQUMvQyxhQUFhLHdDQUF3QztBQUNyRCxhQUFhLDBDQUEwQztBQUN2RCxhQUFhLDBDQUEwQztBQUN2RCxhQUFhLDZDQUE2QztBQUMxRDs7QUFFQTtBQUNBLGFBQWE7QUFDYjtBQUNPO0FBQ1AsbUJBQW1CLDRDQUFjO0FBQ2pDLGdDQUFnQztBQUNoQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxjQUFjLHlDQUF5QztBQUN2RCxhQUFhLHVDQUF1QztBQUNwRDs7QUFFQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyx5QkFBeUI7QUFDdkMscUNBQXFDLGtCQUFrQjtBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLGFBQWE7QUFDM0I7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxjQUFjLHlFQUF5RTtBQUN2RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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bmZ0LnN0b3JhZ2Uvc3JjL2xpYi5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEEgY2xpZW50IGxpYnJhcnkgZm9yIHRoZSBodHRwczovL25mdC5zdG9yYWdlLyBzZXJ2aWNlLiBJdCBwcm92aWRlcyBhIGNvbnZlbmllbnRcbiAqIGludGVyZmFjZSBmb3Igd29ya2luZyB3aXRoIHRoZSBbUmF3IEhUVFAgQVBJXShodHRwczovL25mdC5zdG9yYWdlLyNhcGktZG9jcylcbiAqIGZyb20gYSB3ZWIgYnJvd3NlciBvciBbTm9kZS5qc10oaHR0cHM6Ly9ub2RlanMub3JnLykgYW5kIGNvbWVzIGJ1bmRsZWQgd2l0aFxuICogVFMgZm9yIG91dC1vZi10aGUgYm94IHR5cGUgaW5mZXJlbmNlIGFuZCBiZXR0ZXIgSW50ZWxsaVNlbnNlLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGBqc1xuICogaW1wb3J0IHsgTkZUU3RvcmFnZSwgRmlsZSwgQmxvYiB9IGZyb20gXCJuZnQuc3RvcmFnZVwiXG4gKiBjb25zdCBjbGllbnQgPSBuZXcgTkZUU3RvcmFnZSh7IHRva2VuOiBBUElfVE9LRU4gfSlcbiAqXG4gKiBjb25zdCBjaWQgPSBhd2FpdCBjbGllbnQuc3RvcmVCbG9iKG5ldyBCbG9iKFsnaGVsbG8gd29ybGQnXSkpXG4gKiBgYGBcbiAqIEBtb2R1bGVcbiAqL1xuXG5pbXBvcnQgeyB0cmFuc2Zvcm0gfSBmcm9tICdzdHJlYW1pbmctaXRlcmFibGVzJ1xuaW1wb3J0IHBSZXRyeSwgeyBBYm9ydEVycm9yIH0gZnJvbSAncC1yZXRyeSdcbmltcG9ydCB7IFRyZWV3YWxrQ2FyU3BsaXR0ZXIgfSBmcm9tICdjYXJiaXRlcy90cmVld2FsaydcbmltcG9ydCB7IHBhY2sgfSBmcm9tICdpcGZzLWNhci9wYWNrJ1xuaW1wb3J0IHsgQ0lEIH0gZnJvbSAnbXVsdGlmb3JtYXRzL2NpZCdcbmltcG9ydCB0aHJvdHRsZWRRdWV1ZSBmcm9tICd0aHJvdHRsZWQtcXVldWUnXG5pbXBvcnQgKiBhcyBUb2tlbiBmcm9tICcuL3Rva2VuLmpzJ1xuaW1wb3J0IHsgZmV0Y2gsIEZpbGUsIEJsb2IsIEZvcm1EYXRhLCBCbG9ja3N0b3JlIH0gZnJvbSAnLi9wbGF0Zm9ybS5qcydcbmltcG9ydCB7IHRvR2F0ZXdheVVSTCB9IGZyb20gJy4vZ2F0ZXdheS5qcydcbmltcG9ydCB7IEJsb2Nrc3RvcmVDYXJSZWFkZXIgfSBmcm9tICcuL2JzLWNhci1yZWFkZXIuanMnXG5pbXBvcnQgcGlwZSBmcm9tICdpdC1waXBlJ1xuXG5jb25zdCBNQVhfU1RPUkVfUkVUUklFUyA9IDVcbmNvbnN0IE1BWF9DT05DVVJSRU5UX1VQTE9BRFMgPSAzXG5jb25zdCBNQVhfQ0hVTktfU0laRSA9IDEwMjQgKiAxMDI0ICogNTAgLy8gY2h1bmsgdG8gfjUwTUIgQ0FSc1xuY29uc3QgUkFURV9MSU1JVF9SRVFVRVNUUyA9IDMwXG5jb25zdCBSQVRFX0xJTUlUX1BFUklPRCA9IDEwICogMTAwMFxuXG4vKipcbiAqIEB0eXBlZGVmIHtpbXBvcnQoJy4vbGliL2ludGVyZmFjZS5qcycpLlNlcnZpY2V9IFNlcnZpY2VcbiAqIEB0eXBlZGVmIHtpbXBvcnQoJy4vbGliL2ludGVyZmFjZS5qcycpLkNJRFN0cmluZ30gQ0lEU3RyaW5nXG4gKiBAdHlwZWRlZiB7aW1wb3J0KCcuL2xpYi9pbnRlcmZhY2UuanMnKS5EZWFsfSBEZWFsXG4gKiBAdHlwZWRlZiB7aW1wb3J0KCcuL2xpYi9pbnRlcmZhY2UuanMnKS5GaWxlT2JqZWN0fSBGaWxlT2JqZWN0XG4gKiBAdHlwZWRlZiB7aW1wb3J0KCcuL2xpYi9pbnRlcmZhY2UuanMnKS5GaWxlc1NvdXJjZX0gRmlsZXNTb3VyY2VcbiAqIEB0eXBlZGVmIHtpbXBvcnQoJy4vbGliL2ludGVyZmFjZS5qcycpLlBpbn0gUGluXG4gKiBAdHlwZWRlZiB7aW1wb3J0KCcuL2xpYi9pbnRlcmZhY2UuanMnKS5DYXJSZWFkZXJ9IENhclJlYWRlclxuICogQHR5cGVkZWYge2ltcG9ydCgnaXBmcy1jYXIvYmxvY2tzdG9yZScpLkJsb2Nrc3RvcmV9IEJsb2Nrc3RvcmVJXG4gKiBAdHlwZWRlZiB7aW1wb3J0KCcuL2xpYi9pbnRlcmZhY2UuanMnKS5SYXRlTGltaXRlcn0gUmF0ZUxpbWl0ZXJcbiAqIEB0eXBlZGVmIHtpbXBvcnQoJy4vbGliL2ludGVyZmFjZS5qcycpLlJlcXVlc3RPcHRpb25zfSBSZXF1ZXN0T3B0aW9uc1xuICovXG5cbi8qKlxuICogQHJldHVybnMge1JhdGVMaW1pdGVyfVxuICovXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlUmF0ZUxpbWl0ZXIoKSB7XG4gIGNvbnN0IHRocm90dGxlID0gdGhyb3R0bGVkUXVldWUoUkFURV9MSU1JVF9SRVFVRVNUUywgUkFURV9MSU1JVF9QRVJJT0QpXG4gIHJldHVybiAoKSA9PiB0aHJvdHRsZSgoKSA9PiB7fSlcbn1cblxuLyoqXG4gKiBSYXRlIGxpbWl0ZXIgdXNlZCBieSBzdGF0aWMgQVBJIGlmIG5vIHJhdGUgbGltaXRlciBpcyBwYXNzZWQuIE5vdGUgdGhhdCBlYWNoXG4gKiBpbnN0YW5jZSBvZiB0aGUgTkZUU3RvcmFnZSBjbGFzcyBnZXRzIGl0J3Mgb3duIGxpbWl0ZXIgaWYgbm9uZSBpcyBwYXNzZWQuXG4gKiBUaGlzIGlzIGJlY2F1c2UgcmF0ZSBsaW1pdHMgYXJlIGVuZm9yY2VkIHBlciBBUEkgdG9rZW4uXG4gKi9cbmNvbnN0IGdsb2JhbFJhdGVMaW1pdGVyID0gY3JlYXRlUmF0ZUxpbWl0ZXIoKVxuXG4vKipcbiAqIEB0ZW1wbGF0ZSB7aW1wb3J0KCcuL2xpYi9pbnRlcmZhY2UuanMnKS5Ub2tlbklucHV0fSBUXG4gKiBAdHlwZWRlZiB7aW1wb3J0KCcuL2xpYi9pbnRlcmZhY2UuanMnKS5Ub2tlbjxUPn0gVG9rZW5UeXBlXG4gKi9cblxuLyoqXG4gKiBAaW1wbGVtZW50cyB7U2VydmljZX1cbiAqL1xuY2xhc3MgTkZUU3RvcmFnZSB7XG4gIC8qKlxuICAgKiBDb25zdHJ1Y3RzIGEgY2xpZW50IGJvdW5kIHRvIHRoZSBnaXZlbiBgb3B0aW9ucy50b2tlbmAgYW5kXG4gICAqIGBvcHRpb25zLmVuZHBvaW50YC5cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogYGBganNcbiAgICogaW1wb3J0IHsgTkZUU3RvcmFnZSwgRmlsZSwgQmxvYiB9IGZyb20gXCJuZnQuc3RvcmFnZVwiXG4gICAqIGNvbnN0IGNsaWVudCA9IG5ldyBORlRTdG9yYWdlKHsgdG9rZW46IEFQSV9UT0tFTiB9KVxuICAgKlxuICAgKiBjb25zdCBjaWQgPSBhd2FpdCBjbGllbnQuc3RvcmVCbG9iKG5ldyBCbG9iKFsnaGVsbG8gd29ybGQnXSkpXG4gICAqIGBgYFxuICAgKiBPcHRpb25hbGx5IHlvdSBjb3VsZCBwYXNzIGFuIGFsdGVybmF0aXZlIEFQSSBlbmRwb2ludCAoZS5nLiBmb3IgdGVzdGluZylcbiAgICogQGV4YW1wbGVcbiAgICogYGBganNcbiAgICogaW1wb3J0IHsgTkZUU3RvcmFnZSB9IGZyb20gXCJuZnQuc3RvcmFnZVwiXG4gICAqIGNvbnN0IGNsaWVudCA9IG5ldyBORlRTdG9yYWdlKHtcbiAgICogICB0b2tlbjogQVBJX1RPS0VOXG4gICAqICAgZW5kcG9pbnQ6IG5ldyBVUkwoJ2h0dHA6Ly9sb2NhbGhvc3Q6ODA4MC8nKVxuICAgKiB9KVxuICAgKiBgYGBcbiAgICpcbiAgICogQHBhcmFtIHt7dG9rZW46IHN0cmluZywgZW5kcG9pbnQ/OiBVUkwsIHJhdGVMaW1pdGVyPzogUmF0ZUxpbWl0ZXIsIGRpZD86IHN0cmluZ319IG9wdGlvbnNcbiAgICovXG4gIGNvbnN0cnVjdG9yKHtcbiAgICB0b2tlbixcbiAgICBkaWQsXG4gICAgZW5kcG9pbnQgPSBuZXcgVVJMKCdodHRwczovL2FwaS5uZnQuc3RvcmFnZScpLFxuICAgIHJhdGVMaW1pdGVyLFxuICB9KSB7XG4gICAgLyoqXG4gICAgICogQXV0aG9yaXphdGlvbiB0b2tlbi5cbiAgICAgKlxuICAgICAqIEByZWFkb25seVxuICAgICAqL1xuICAgIHRoaXMudG9rZW4gPSB0b2tlblxuICAgIC8qKlxuICAgICAqIFNlcnZpY2UgQVBJIGVuZHBvaW50IGBVUkxgLlxuICAgICAqIEByZWFkb25seVxuICAgICAqL1xuICAgIHRoaXMuZW5kcG9pbnQgPSBlbmRwb2ludFxuICAgIC8qKlxuICAgICAqIEByZWFkb25seVxuICAgICAqL1xuICAgIHRoaXMucmF0ZUxpbWl0ZXIgPSByYXRlTGltaXRlciB8fCBjcmVhdGVSYXRlTGltaXRlcigpXG5cbiAgICAvKipcbiAgICAgKiBAcmVhZG9ubHlcbiAgICAgKi9cbiAgICB0aGlzLmRpZCA9IGRpZFxuICB9XG5cbiAgLyoqXG4gICAqIEBoaWRkZW5cbiAgICogQHBhcmFtIHtvYmplY3R9IG9wdGlvbnNcbiAgICogQHBhcmFtIHtzdHJpbmd9IG9wdGlvbnMudG9rZW5cbiAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLmRpZF1cbiAgICovXG4gIHN0YXRpYyBhdXRoKHsgdG9rZW4sIGRpZCB9KSB7XG4gICAgaWYgKCF0b2tlbikgdGhyb3cgbmV3IEVycm9yKCdtaXNzaW5nIHRva2VuJylcbiAgICByZXR1cm4ge1xuICAgICAgQXV0aG9yaXphdGlvbjogYEJlYXJlciAke3Rva2VufWAsXG4gICAgICAnWC1DbGllbnQnOiAnbmZ0LnN0b3JhZ2UvanMnLFxuICAgICAgLi4uKGRpZCA/IHsgJ3gtYWdlbnQtZGlkJzogZGlkIH0gOiB7fSksXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFN0b3JlcyBhIHNpbmdsZSBmaWxlIGFuZCByZXR1cm5zIGl0cyBDSUQuXG4gICAqXG4gICAqIEBwYXJhbSB7U2VydmljZX0gc2VydmljZVxuICAgKiBAcGFyYW0ge0Jsb2J9IGJsb2JcbiAgICogQHBhcmFtIHtSZXF1ZXN0T3B0aW9uc30gW29wdGlvbnNdXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPENJRFN0cmluZz59XG4gICAqL1xuICBzdGF0aWMgYXN5bmMgc3RvcmVCbG9iKHNlcnZpY2UsIGJsb2IsIG9wdGlvbnMpIHtcbiAgICBjb25zdCBibG9ja3N0b3JlID0gbmV3IEJsb2Nrc3RvcmUoKVxuICAgIGxldCBjaWRTdHJpbmdcblxuICAgIHRyeSB7XG4gICAgICBjb25zdCB7IGNpZCwgY2FyIH0gPSBhd2FpdCBORlRTdG9yYWdlLmVuY29kZUJsb2IoYmxvYiwgeyBibG9ja3N0b3JlIH0pXG4gICAgICBhd2FpdCBORlRTdG9yYWdlLnN0b3JlQ2FyKHNlcnZpY2UsIGNhciwgb3B0aW9ucylcbiAgICAgIGNpZFN0cmluZyA9IGNpZC50b1N0cmluZygpXG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIGF3YWl0IGJsb2Nrc3RvcmUuY2xvc2UoKVxuICAgIH1cblxuICAgIHJldHVybiBjaWRTdHJpbmdcbiAgfVxuXG4gIC8qKlxuICAgKiBTdG9yZXMgYSBDQVIgZmlsZSBhbmQgcmV0dXJucyBpdHMgcm9vdCBDSUQuXG4gICAqXG4gICAqIEBwYXJhbSB7U2VydmljZX0gc2VydmljZVxuICAgKiBAcGFyYW0ge0Jsb2J8Q2FyUmVhZGVyfSBjYXJcbiAgICogQHBhcmFtIHtpbXBvcnQoJy4vbGliL2ludGVyZmFjZS5qcycpLkNhclN0b3Jlck9wdGlvbnN9IFtvcHRpb25zXVxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxDSURTdHJpbmc+fVxuICAgKi9cbiAgc3RhdGljIGFzeW5jIHN0b3JlQ2FyKFxuICAgIHsgZW5kcG9pbnQsIHJhdGVMaW1pdGVyID0gZ2xvYmFsUmF0ZUxpbWl0ZXIsIC4uLnRva2VuIH0sXG4gICAgY2FyLFxuICAgIHsgb25TdG9yZWRDaHVuaywgbWF4UmV0cmllcywgbWF4Q2h1bmtTaXplLCBkZWNvZGVycywgc2lnbmFsIH0gPSB7fVxuICApIHtcbiAgICBjb25zdCB1cmwgPSBuZXcgVVJMKCd1cGxvYWQvJywgZW5kcG9pbnQpXG4gICAgY29uc3QgaGVhZGVycyA9IHtcbiAgICAgIC4uLk5GVFN0b3JhZ2UuYXV0aCh0b2tlbiksXG4gICAgICAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2NhcicsXG4gICAgfVxuICAgIGNvbnN0IHRhcmdldFNpemUgPSBtYXhDaHVua1NpemUgfHwgTUFYX0NIVU5LX1NJWkVcbiAgICBjb25zdCBzcGxpdHRlciA9XG4gICAgICBjYXIgaW5zdGFuY2VvZiBCbG9iXG4gICAgICAgID8gYXdhaXQgVHJlZXdhbGtDYXJTcGxpdHRlci5mcm9tQmxvYihjYXIsIHRhcmdldFNpemUsIHsgZGVjb2RlcnMgfSlcbiAgICAgICAgOiBuZXcgVHJlZXdhbGtDYXJTcGxpdHRlcihjYXIsIHRhcmdldFNpemUsIHsgZGVjb2RlcnMgfSlcblxuICAgIGNvbnN0IHVwbG9hZCA9IHRyYW5zZm9ybShcbiAgICAgIE1BWF9DT05DVVJSRU5UX1VQTE9BRFMsXG4gICAgICBhc3luYyBmdW5jdGlvbiAoLyoqIEB0eXBlIHtBc3luY0l0ZXJhYmxlPFVpbnQ4QXJyYXk+fSAqLyBjYXIpIHtcbiAgICAgICAgY29uc3QgY2FyUGFydHMgPSBbXVxuICAgICAgICBmb3IgYXdhaXQgKGNvbnN0IHBhcnQgb2YgY2FyKSB7XG4gICAgICAgICAgY2FyUGFydHMucHVzaChwYXJ0KVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGNhckZpbGUgPSBuZXcgQmxvYihjYXJQYXJ0cywgeyB0eXBlOiAnYXBwbGljYXRpb24vY2FyJyB9KVxuICAgICAgICAvKiogQHR5cGUge0Jsb2J8QXJyYXlCdWZmZXJ9ICovXG4gICAgICAgIGxldCBib2R5ID0gY2FyRmlsZVxuICAgICAgICAvLyBGSVhNRTogc2hvdWxkIG5vdCBiZSBuZWNlc3NhcnkgdG8gYXdhaXQgYXJyYXlCdWZmZXIoKSFcbiAgICAgICAgLy8gTm9kZS5qcyAyMCBoYW5ncyByZWFkaW5nIHRoZSBzdHJlYW0gKGl0IG5ldmVyIGVuZHMpIGJ1dCBpblxuICAgICAgICAvLyBvbGRlciBub2RlIHZlcnNpb25zIGFuZCB0aGUgYnJvd3NlciBpdCBpcyBmaW5lIHRvIHBhc3MgYSBibG9iLlxuICAgICAgICAvKiBjOCBpZ25vcmUgbmV4dCAzICovXG4gICAgICAgIGlmIChwYXJzZUludChnbG9iYWxUaGlzLnByb2Nlc3M/LnZlcnNpb25zPy5ub2RlKSA+IDE4KSB7XG4gICAgICAgICAgYm9keSA9IGF3YWl0IGJvZHkuYXJyYXlCdWZmZXIoKVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGNpZCA9IGF3YWl0IHBSZXRyeShcbiAgICAgICAgICBhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICBhd2FpdCByYXRlTGltaXRlcigpXG4gICAgICAgICAgICAvKiogQHR5cGUge1Jlc3BvbnNlfSAqL1xuICAgICAgICAgICAgbGV0IHJlc3BvbnNlXG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICByZXNwb25zZSA9IGF3YWl0IGZldGNoKHVybC50b1N0cmluZygpLCB7XG4gICAgICAgICAgICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICAgICAgICAgICAgaGVhZGVycyxcbiAgICAgICAgICAgICAgICBib2R5LFxuICAgICAgICAgICAgICAgIHNpZ25hbCxcbiAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIH0gY2F0Y2ggKC8qKiBAdHlwZSB7YW55fSAqLyBlcnIpIHtcbiAgICAgICAgICAgICAgLy8gVE9ETzogcmVtb3ZlIG1lIGFuZCB0ZXN0IHdoZW4gY2xpZW50IGFjY2VwdHMgY3VzdG9tIGZldGNoIGltcGxcbiAgICAgICAgICAgICAgLyogYzggaWdub3JlIG5leHQgMSAqL1xuICAgICAgICAgICAgICB0aHJvdyBzaWduYWwgJiYgc2lnbmFsLmFib3J0ZWQgPyBuZXcgQWJvcnRFcnJvcihlcnIpIDogZXJyXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvKiBjOCBpZ25vcmUgbmV4dCAzICovXG4gICAgICAgICAgICBpZiAocmVzcG9uc2Uuc3RhdHVzID09PSA0MjkpIHtcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdyYXRlIGxpbWl0ZWQnKVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgcmVzcG9uc2UuanNvbigpXG4gICAgICAgICAgICBpZiAoIXJlc3VsdC5vaykge1xuICAgICAgICAgICAgICAvLyBkbyBub3QgcmV0cnkgaWYgdW5hdXRob3JpemVkIC0gd2lsbCBub3Qgc3VjY2VlZFxuICAgICAgICAgICAgICBpZiAocmVzcG9uc2Uuc3RhdHVzID09PSA0MDEpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgQWJvcnRFcnJvcihyZXN1bHQuZXJyb3IubWVzc2FnZSlcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IocmVzdWx0LmVycm9yLm1lc3NhZ2UpXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0LnZhbHVlLmNpZFxuICAgICAgICAgIH0sXG4gICAgICAgICAge1xuICAgICAgICAgICAgcmV0cmllczogbWF4UmV0cmllcyA9PSBudWxsID8gTUFYX1NUT1JFX1JFVFJJRVMgOiBtYXhSZXRyaWVzLFxuICAgICAgICAgIH1cbiAgICAgICAgKVxuICAgICAgICBvblN0b3JlZENodW5rICYmIG9uU3RvcmVkQ2h1bmsoY2FyRmlsZS5zaXplKVxuICAgICAgICByZXR1cm4gY2lkXG4gICAgICB9XG4gICAgKVxuXG4gICAgbGV0IHJvb3RcbiAgICBmb3IgYXdhaXQgKGNvbnN0IGNpZCBvZiB1cGxvYWQoc3BsaXR0ZXIuY2FycygpKSkge1xuICAgICAgcm9vdCA9IGNpZFxuICAgIH1cblxuICAgIHJldHVybiAvKiogQHR5cGUge0NJRFN0cmluZ30gKi8gKHJvb3QpXG4gIH1cblxuICAvKipcbiAgICogU3RvcmVzIGEgZGlyZWN0b3J5IG9mIGZpbGVzIGFuZCByZXR1cm5zIGEgQ0lELiBQcm92aWRlZCBmaWxlcyAqKk1VU1QqKlxuICAgKiBiZSB3aXRoaW4gdGhlIHNhbWUgZGlyZWN0b3J5LCBvdGhlcndpc2UgZXJyb3IgaXMgcmFpc2VkIGUuZy4gYGZvby9iYXIucG5nYCxcbiAgICogYGZvby9ibGEvYmF6Lmpzb25gIGlzIG9rIGJ1dCBgZm9vL2Jhci5wbmdgLCBgYmxhL2Jhei5qc29uYCBpcyBub3QuXG4gICAqXG4gICAqIEBwYXJhbSB7U2VydmljZX0gc2VydmljZVxuICAgKiBAcGFyYW0ge0ZpbGVzU291cmNlfSBmaWxlc1NvdXJjZVxuICAgKiBAcGFyYW0ge1JlcXVlc3RPcHRpb25zfSBbb3B0aW9uc11cbiAgICogQHJldHVybnMge1Byb21pc2U8Q0lEU3RyaW5nPn1cbiAgICovXG4gIHN0YXRpYyBhc3luYyBzdG9yZURpcmVjdG9yeShzZXJ2aWNlLCBmaWxlc1NvdXJjZSwgb3B0aW9ucykge1xuICAgIGNvbnN0IGJsb2Nrc3RvcmUgPSBuZXcgQmxvY2tzdG9yZSgpXG4gICAgbGV0IGNpZFN0cmluZ1xuICAgIHRyeSB7XG4gICAgICBjb25zdCB7IGNpZCwgY2FyIH0gPSBhd2FpdCBORlRTdG9yYWdlLmVuY29kZURpcmVjdG9yeShmaWxlc1NvdXJjZSwge1xuICAgICAgICBibG9ja3N0b3JlLFxuICAgICAgfSlcbiAgICAgIGF3YWl0IE5GVFN0b3JhZ2Uuc3RvcmVDYXIoc2VydmljZSwgY2FyLCBvcHRpb25zKVxuICAgICAgY2lkU3RyaW5nID0gY2lkLnRvU3RyaW5nKClcbiAgICB9IGZpbmFsbHkge1xuICAgICAgYXdhaXQgYmxvY2tzdG9yZS5jbG9zZSgpXG4gICAgfVxuXG4gICAgcmV0dXJuIGNpZFN0cmluZ1xuICB9XG5cbiAgLyoqXG4gICAqIFN0b3JlcyB0aGUgZ2l2ZW4gdG9rZW4gYW5kIGFsbCByZXNvdXJjZXMgaXQgcmVmZXJlbmNlcyAoaW4gdGhlIGZvcm0gb2YgYVxuICAgKiBGaWxlIG9yIGEgQmxvYikgYWxvbmcgd2l0aCBhIG1ldGFkYXRhIEpTT04gYXMgc3BlY2lmaWNlZCBpbiBFUkMtMTE1NS4gVGhlXG4gICAqIGB0b2tlbi5pbWFnZWAgbXVzdCBiZSBlaXRoZXIgYSBgRmlsZWAgb3IgYSBgQmxvYmAgaW5zdGFuY2UsIHdoaWNoIHdpbGwgYmVcbiAgICogc3RvcmVkIGFuZCB0aGUgY29ycmVzcG9uZGluZyBjb250ZW50IGFkZHJlc3MgVVJMIHdpbGwgYmUgc2F2ZWQgaW4gdGhlXG4gICAqIG1ldGFkYXRhIEpTT04gZmlsZSB1bmRlciBgaW1hZ2VgIGZpZWxkLlxuICAgKlxuICAgKiBJZiBgdG9rZW4ucHJvcGVydGllc2AgY29udGFpbnMgcHJvcGVydGllcyB3aXRoIGBGaWxlYCBvciBgQmxvYmAgdmFsdWVzLFxuICAgKiB0aG9zZSBhbHNvIGdldCBzdG9yZWQgYW5kIHRoZWlyIFVSTHMgd2lsbCBiZSBzYXZlZCBpbiB0aGUgbWV0YWRhdGEgSlNPTlxuICAgKiBmaWxlIGluIHRoZWlyIHBsYWNlLlxuICAgKlxuICAgKiBOb3RlOiBVUkxzIGZvciBgRmlsZWAgb2JqZWN0cyB3aWxsIHJldGFpbiBmaWxlIG5hbWVzIGUuZy4gaW4gY2FzZSBvZlxuICAgKiBgbmV3IEZpbGUoW2J5dGVzXSwgJ2NhdC5wbmcnLCB7IHR5cGU6ICdpbWFnZS9wbmcnIH0pYCB3aWxsIGJlIHRyYW5zZm9ybWVkXG4gICAqIGludG8gYSBVUkwgdGhhdCBsb29rcyBsaWtlIGBpcGZzOi8vYmFmeS4uLmhhc2gvaW1hZ2UvY2F0LnBuZ2AuIEZvciBgQmxvYmBcbiAgICogb2JqZWN0cywgdGhlIFVSTCB3aWxsIG5vdCBoYXZlIGEgZmlsZSBuYW1lIG5hbWUgb3IgbWltZSB0eXBlLCBpbnN0ZWFkIGl0XG4gICAqIHdpbGwgYmUgdHJhbnNmb3JtZWQgaW50byBhIFVSTCB0aGF0IGxvb2tzIGxpa2VcbiAgICogYGlwZnM6Ly9iYWZ5Li4uaGFzaC9pbWFnZS9ibG9iYC5cbiAgICpcbiAgICogQHRlbXBsYXRlIHtpbXBvcnQoJy4vbGliL2ludGVyZmFjZS5qcycpLlRva2VuSW5wdXR9IFRcbiAgICogQHBhcmFtIHtTZXJ2aWNlfSBzZXJ2aWNlXG4gICAqIEBwYXJhbSB7VH0gbWV0YWRhdGFcbiAgICogQHBhcmFtIHtSZXF1ZXN0T3B0aW9uc30gW29wdGlvbnNdXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPFRva2VuVHlwZTxUPj59XG4gICAqL1xuICBzdGF0aWMgYXN5bmMgc3RvcmUoc2VydmljZSwgbWV0YWRhdGEsIG9wdGlvbnMpIHtcbiAgICBjb25zdCB7IHRva2VuLCBjYXIgfSA9IGF3YWl0IE5GVFN0b3JhZ2UuZW5jb2RlTkZUKG1ldGFkYXRhKVxuICAgIGF3YWl0IE5GVFN0b3JhZ2Uuc3RvcmVDYXIoc2VydmljZSwgY2FyLCBvcHRpb25zKVxuICAgIHJldHVybiB0b2tlblxuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgY3VycmVudCBzdGF0dXMgb2YgdGhlIHN0b3JlZCBORlQgYnkgaXRzIENJRC4gTm90ZSB0aGUgTkZUIG11c3RcbiAgICogaGF2ZSBwcmV2aW91c2x5IGJlZW4gc3RvcmVkIGJ5IHRoaXMgYWNjb3VudC5cbiAgICpcbiAgICogQHBhcmFtIHtTZXJ2aWNlfSBzZXJ2aWNlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBjaWRcbiAgICogQHBhcmFtIHtSZXF1ZXN0T3B0aW9uc30gW29wdGlvbnNdXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPGltcG9ydCgnLi9saWIvaW50ZXJmYWNlLmpzJykuU3RhdHVzUmVzdWx0Pn1cbiAgICovXG4gIHN0YXRpYyBhc3luYyBzdGF0dXMoXG4gICAgeyBlbmRwb2ludCwgcmF0ZUxpbWl0ZXIgPSBnbG9iYWxSYXRlTGltaXRlciwgLi4udG9rZW4gfSxcbiAgICBjaWQsXG4gICAgb3B0aW9uc1xuICApIHtcbiAgICBjb25zdCB1cmwgPSBuZXcgVVJMKGAke2NpZH0vYCwgZW5kcG9pbnQpXG4gICAgYXdhaXQgcmF0ZUxpbWl0ZXIoKVxuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2godXJsLnRvU3RyaW5nKCksIHtcbiAgICAgIG1ldGhvZDogJ0dFVCcsXG4gICAgICBoZWFkZXJzOiBORlRTdG9yYWdlLmF1dGgodG9rZW4pLFxuICAgICAgc2lnbmFsOiBvcHRpb25zICYmIG9wdGlvbnMuc2lnbmFsLFxuICAgIH0pXG4gICAgLyogYzggaWdub3JlIG5leHQgMyAqL1xuICAgIGlmIChyZXNwb25zZS5zdGF0dXMgPT09IDQyOSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdyYXRlIGxpbWl0ZWQnKVxuICAgIH1cbiAgICBjb25zdCByZXN1bHQgPSBhd2FpdCByZXNwb25zZS5qc29uKClcblxuICAgIGlmIChyZXN1bHQub2spIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGNpZDogcmVzdWx0LnZhbHVlLmNpZCxcbiAgICAgICAgZGVhbHM6IGRlY29kZURlYWxzKHJlc3VsdC52YWx1ZS5kZWFscyksXG4gICAgICAgIHNpemU6IHJlc3VsdC52YWx1ZS5zaXplLFxuICAgICAgICBwaW46IGRlY29kZVBpbihyZXN1bHQudmFsdWUucGluKSxcbiAgICAgICAgY3JlYXRlZDogbmV3IERhdGUocmVzdWx0LnZhbHVlLmNyZWF0ZWQpLFxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IocmVzdWx0LmVycm9yLm1lc3NhZ2UpXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIENoZWNrIGlmIGEgQ0lEIG9mIGFuIE5GVCBpcyBiZWluZyBzdG9yZWQgYnkgTkZULlN0b3JhZ2UuXG4gICAqXG4gICAqIEBwYXJhbSB7aW1wb3J0KCcuL2xpYi9pbnRlcmZhY2UuanMnKS5QdWJsaWNTZXJ2aWNlfSBzZXJ2aWNlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBjaWRcbiAgICogQHBhcmFtIHtSZXF1ZXN0T3B0aW9uc30gW29wdGlvbnNdXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPGltcG9ydCgnLi9saWIvaW50ZXJmYWNlLmpzJykuQ2hlY2tSZXN1bHQ+fVxuICAgKi9cbiAgc3RhdGljIGFzeW5jIGNoZWNrKFxuICAgIHsgZW5kcG9pbnQsIHJhdGVMaW1pdGVyID0gZ2xvYmFsUmF0ZUxpbWl0ZXIgfSxcbiAgICBjaWQsXG4gICAgb3B0aW9uc1xuICApIHtcbiAgICBjb25zdCB1cmwgPSBuZXcgVVJMKGBjaGVjay8ke2NpZH0vYCwgZW5kcG9pbnQpXG4gICAgYXdhaXQgcmF0ZUxpbWl0ZXIoKVxuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2godXJsLnRvU3RyaW5nKCksIHtcbiAgICAgIHNpZ25hbDogb3B0aW9ucyAmJiBvcHRpb25zLnNpZ25hbCxcbiAgICB9KVxuICAgIC8qIGM4IGlnbm9yZSBuZXh0IDMgKi9cbiAgICBpZiAocmVzcG9uc2Uuc3RhdHVzID09PSA0MjkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcigncmF0ZSBsaW1pdGVkJylcbiAgICB9XG4gICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgcmVzcG9uc2UuanNvbigpXG5cbiAgICBpZiAocmVzdWx0Lm9rKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBjaWQ6IHJlc3VsdC52YWx1ZS5jaWQsXG4gICAgICAgIGRlYWxzOiBkZWNvZGVEZWFscyhyZXN1bHQudmFsdWUuZGVhbHMpLFxuICAgICAgICBwaW46IHJlc3VsdC52YWx1ZS5waW4sXG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihyZXN1bHQuZXJyb3IubWVzc2FnZSlcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogUmVtb3ZlcyBzdG9yZWQgY29udGVudCBieSBpdHMgQ0lEIGZyb20gdGhpcyBhY2NvdW50LiBQbGVhc2Ugbm90ZSB0aGF0XG4gICAqIGV2ZW4gaWYgY29udGVudCBpcyByZW1vdmVkIGZyb20gdGhlIHNlcnZpY2Ugb3RoZXIgbm9kZXMgdGhhdCBoYXZlXG4gICAqIHJlcGxpY2F0ZWQgaXQgbWlnaHQgc3RpbGwgY29udGludWUgcHJvdmlkaW5nIGl0LlxuICAgKlxuICAgKiBAcGFyYW0ge1NlcnZpY2V9IHNlcnZpY2VcbiAgICogQHBhcmFtIHtzdHJpbmd9IGNpZFxuICAgKiBAcGFyYW0ge1JlcXVlc3RPcHRpb25zfSBbb3B0aW9uc11cbiAgICogQHJldHVybnMge1Byb21pc2U8dm9pZD59XG4gICAqL1xuICBzdGF0aWMgYXN5bmMgZGVsZXRlKFxuICAgIHsgZW5kcG9pbnQsIHJhdGVMaW1pdGVyID0gZ2xvYmFsUmF0ZUxpbWl0ZXIsIC4uLnRva2VuIH0sXG4gICAgY2lkLFxuICAgIG9wdGlvbnNcbiAgKSB7XG4gICAgY29uc3QgdXJsID0gbmV3IFVSTChgJHtjaWR9L2AsIGVuZHBvaW50KVxuICAgIGF3YWl0IHJhdGVMaW1pdGVyKClcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKHVybC50b1N0cmluZygpLCB7XG4gICAgICBtZXRob2Q6ICdERUxFVEUnLFxuICAgICAgaGVhZGVyczogTkZUU3RvcmFnZS5hdXRoKHRva2VuKSxcbiAgICAgIHNpZ25hbDogb3B0aW9ucyAmJiBvcHRpb25zLnNpZ25hbCxcbiAgICB9KVxuICAgIC8qIGM4IGlnbm9yZSBuZXh0IDMgKi9cbiAgICBpZiAocmVzcG9uc2Uuc3RhdHVzID09PSA0MjkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcigncmF0ZSBsaW1pdGVkJylcbiAgICB9XG4gICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgcmVzcG9uc2UuanNvbigpXG4gICAgaWYgKCFyZXN1bHQub2spIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihyZXN1bHQuZXJyb3IubWVzc2FnZSlcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogRW5jb2RlcyB0aGUgZ2l2ZW4gdG9rZW4gYW5kIGFsbCByZXNvdXJjZXMgaXQgcmVmZXJlbmNlcyAoaW4gdGhlIGZvcm0gb2YgYVxuICAgKiBGaWxlIG9yIGEgQmxvYikgYWxvbmcgd2l0aCBhIG1ldGFkYXRhIEpTT04gYXMgc3BlY2lmaWNlZCBpbiBFUkMtMTE1NSB0byBhXG4gICAqIENBUiBmaWxlLiBUaGUgYHRva2VuLmltYWdlYCBtdXN0IGJlIGVpdGhlciBhIGBGaWxlYCBvciBhIGBCbG9iYCBpbnN0YW5jZSxcbiAgICogd2hpY2ggd2lsbCBiZSBzdG9yZWQgYW5kIHRoZSBjb3JyZXNwb25kaW5nIGNvbnRlbnQgYWRkcmVzcyBVUkwgd2lsbCBiZVxuICAgKiBzYXZlZCBpbiB0aGUgbWV0YWRhdGEgSlNPTiBmaWxlIHVuZGVyIGBpbWFnZWAgZmllbGQuXG4gICAqXG4gICAqIElmIGB0b2tlbi5wcm9wZXJ0aWVzYCBjb250YWlucyBwcm9wZXJ0aWVzIHdpdGggYEZpbGVgIG9yIGBCbG9iYCB2YWx1ZXMsXG4gICAqIHRob3NlIGFsc28gZ2V0IHN0b3JlZCBhbmQgdGhlaXIgVVJMcyB3aWxsIGJlIHNhdmVkIGluIHRoZSBtZXRhZGF0YSBKU09OXG4gICAqIGZpbGUgaW4gdGhlaXIgcGxhY2UuXG4gICAqXG4gICAqIE5vdGU6IFVSTHMgZm9yIGBGaWxlYCBvYmplY3RzIHdpbGwgcmV0YWluIGZpbGUgbmFtZXMgZS5nLiBpbiBjYXNlIG9mXG4gICAqIGBuZXcgRmlsZShbYnl0ZXNdLCAnY2F0LnBuZycsIHsgdHlwZTogJ2ltYWdlL3BuZycgfSlgIHdpbGwgYmUgdHJhbnNmb3JtZWRcbiAgICogaW50byBhIFVSTCB0aGF0IGxvb2tzIGxpa2UgYGlwZnM6Ly9iYWZ5Li4uaGFzaC9pbWFnZS9jYXQucG5nYC4gRm9yIGBCbG9iYFxuICAgKiBvYmplY3RzLCB0aGUgVVJMIHdpbGwgbm90IGhhdmUgYSBmaWxlIG5hbWUgbmFtZSBvciBtaW1lIHR5cGUsIGluc3RlYWQgaXRcbiAgICogd2lsbCBiZSB0cmFuc2Zvcm1lZCBpbnRvIGEgVVJMIHRoYXQgbG9va3MgbGlrZVxuICAgKiBgaXBmczovL2JhZnkuLi5oYXNoL2ltYWdlL2Jsb2JgLlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBgYGBqc1xuICAgKiBjb25zdCB7IHRva2VuLCBjYXIgfSA9IGF3YWl0IE5GVFN0b3JhZ2UuZW5jb2RlTkZUKHtcbiAgICogICBuYW1lOiAnbmZ0LnN0b3JhZ2Ugc3RvcmUgdGVzdCcsXG4gICAqICAgZGVzY3JpcHRpb246ICdUZXN0IEVSQy0xMTU1IGNvbXBhdGlibGUgbWV0YWRhdGEuJyxcbiAgICogICBpbWFnZTogbmV3IEZpbGUoWyc8REFUQT4nXSwgJ3BpbnBpZS5qcGcnLCB7IHR5cGU6ICdpbWFnZS9qcGcnIH0pLFxuICAgKiAgIHByb3BlcnRpZXM6IHtcbiAgICogICAgIGN1c3RvbTogJ0N1c3RvbSBkYXRhIGNhbiBhcHBlYXIgaGVyZSwgZmlsZXMgYXJlIGF1dG8gdXBsb2FkZWQuJyxcbiAgICogICAgIGZpbGU6IG5ldyBGaWxlKFsnPERBVEE+J10sICdSRUFETUUubWQnLCB7IHR5cGU6ICd0ZXh0L3BsYWluJyB9KSxcbiAgICogICB9XG4gICAqIH0pXG4gICAqXG4gICAqIGNvbnNvbGUubG9nKCdJUEZTIFVSTCBmb3IgdGhlIG1ldGFkYXRhOicsIHRva2VuLnVybClcbiAgICogY29uc29sZS5sb2coJ21ldGFkYXRhLmpzb24gY29udGVudHM6XFxuJywgdG9rZW4uZGF0YSlcbiAgICogY29uc29sZS5sb2coJ21ldGFkYXRhLmpzb24gd2l0aCBJUEZTIGdhdGV3YXkgVVJMczpcXG4nLCB0b2tlbi5lbWJlZCgpKVxuICAgKlxuICAgKiAvLyBOb3cgc3RvcmUgdGhlIENBUiBmaWxlIG9uIE5GVC5TdG9yYWdlXG4gICAqIGF3YWl0IGNsaWVudC5zdG9yZUNhcihjYXIpXG4gICAqIGBgYFxuICAgKlxuICAgKiBAdGVtcGxhdGUge2ltcG9ydCgnLi9saWIvaW50ZXJmYWNlLmpzJykuVG9rZW5JbnB1dH0gVFxuICAgKiBAcGFyYW0ge1R9IGlucHV0XG4gICAqIEByZXR1cm5zIHtQcm9taXNlPHsgY2lkOiBDSUQsIHRva2VuOiBUb2tlblR5cGU8VD4sIGNhcjogQ2FyUmVhZGVyIH0+fVxuICAgKi9cbiAgc3RhdGljIGFzeW5jIGVuY29kZU5GVChpbnB1dCkge1xuICAgIHZhbGlkYXRlRVJDMTE1NShpbnB1dClcbiAgICByZXR1cm4gVG9rZW4uVG9rZW4uZW5jb2RlKGlucHV0KVxuICB9XG5cbiAgLyoqXG4gICAqIEVuY29kZXMgYSBzaW5nbGUgZmlsZSB0byBhIENBUiBmaWxlIGFuZCBhbHNvIHJldHVybnMgaXRzIHJvb3QgQ0lELlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBgYGBqc1xuICAgKiBjb25zdCBjb250ZW50ID0gbmV3IEJsb2IoWydoZWxsbyB3b3JsZCddKVxuICAgKiBjb25zdCB7IGNpZCwgY2FyIH0gPSBhd2FpdCBORlRTdG9yYWdlLmVuY29kZUJsb2IoY29udGVudClcbiAgICpcbiAgICogLy8gUm9vdCBDSUQgb2YgdGhlIGZpbGVcbiAgICogY29uc29sZS5sb2coY2lkLnRvU3RyaW5nKCkpXG4gICAqXG4gICAqIC8vIE5vdyBzdG9yZSB0aGUgQ0FSIGZpbGUgb24gTkZULlN0b3JhZ2VcbiAgICogYXdhaXQgY2xpZW50LnN0b3JlQ2FyKGNhcilcbiAgICogYGBgXG4gICAqXG4gICAqIEBwYXJhbSB7QmxvYn0gYmxvYlxuICAgKiBAcGFyYW0ge29iamVjdH0gW29wdGlvbnNdXG4gICAqIEBwYXJhbSB7QmxvY2tzdG9yZUl9IFtvcHRpb25zLmJsb2Nrc3RvcmVdXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPHsgY2lkOiBDSUQsIGNhcjogQ2FyUmVhZGVyIH0+fVxuICAgKi9cbiAgc3RhdGljIGFzeW5jIGVuY29kZUJsb2IoYmxvYiwgeyBibG9ja3N0b3JlIH0gPSB7fSkge1xuICAgIGlmIChibG9iLnNpemUgPT09IDApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignQ29udGVudCBzaXplIGlzIDAsIG1ha2Ugc3VyZSB0byBwcm92aWRlIHNvbWUgY29udGVudCcpXG4gICAgfVxuICAgIHJldHVybiBwYWNrQ2FyKFt0b0ltcG9ydENhbmRpZGF0ZSgnYmxvYicsIGJsb2IpXSwge1xuICAgICAgYmxvY2tzdG9yZSxcbiAgICAgIHdyYXBXaXRoRGlyZWN0b3J5OiBmYWxzZSxcbiAgICB9KVxuICB9XG5cbiAgLyoqXG4gICAqIEVuY29kZXMgYSBkaXJlY3Rvcnkgb2YgZmlsZXMgdG8gYSBDQVIgZmlsZSBhbmQgYWxzbyByZXR1cm5zIHRoZSByb290IENJRC5cbiAgICogUHJvdmlkZWQgZmlsZXMgKipNVVNUKiogYmUgd2l0aGluIHRoZSBzYW1lIGRpcmVjdG9yeSwgb3RoZXJ3aXNlIGVycm9yIGlzXG4gICAqIHJhaXNlZCBlLmcuIGBmb28vYmFyLnBuZ2AsIGBmb28vYmxhL2Jhei5qc29uYCBpcyBvayBidXQgYGZvby9iYXIucG5nYCxcbiAgICogYGJsYS9iYXouanNvbmAgaXMgbm90LlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBgYGBqc1xuICAgKiBjb25zdCB7IGNpZCwgY2FyIH0gPSBhd2FpdCBORlRTdG9yYWdlLmVuY29kZURpcmVjdG9yeShbXG4gICAqICAgbmV3IEZpbGUoWydoZWxsbyB3b3JsZCddLCAnaGVsbG8udHh0JyksXG4gICAqICAgbmV3IEZpbGUoW0pTT04uc3RyaW5naWZ5KHsnZnJvbSc6ICdpbmNvZ25pdG8nfSwgbnVsbCwgMildLCAnbWV0YWRhdGEuanNvbicpXG4gICAqIF0pXG4gICAqXG4gICAqIC8vIFJvb3QgQ0lEIG9mIHRoZSBkaXJlY3RvcnlcbiAgICogY29uc29sZS5sb2coY2lkLnRvU3RyaW5nKCkpXG4gICAqXG4gICAqIC8vIE5vdyBzdG9yZSB0aGUgQ0FSIGZpbGUgb24gTkZULlN0b3JhZ2VcbiAgICogYXdhaXQgY2xpZW50LnN0b3JlQ2FyKGNhcilcbiAgICogYGBgXG4gICAqXG4gICAqIEBwYXJhbSB7RmlsZXNTb3VyY2V9IGZpbGVzXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBbb3B0aW9uc11cbiAgICogQHBhcmFtIHtCbG9ja3N0b3JlSX0gW29wdGlvbnMuYmxvY2tzdG9yZV1cbiAgICogQHJldHVybnMge1Byb21pc2U8eyBjaWQ6IENJRCwgY2FyOiBDYXJSZWFkZXIgfT59XG4gICAqL1xuICBzdGF0aWMgYXN5bmMgZW5jb2RlRGlyZWN0b3J5KGZpbGVzLCB7IGJsb2Nrc3RvcmUgfSA9IHt9KSB7XG4gICAgbGV0IHNpemUgPSAwXG4gICAgY29uc3QgaW5wdXQgPSBwaXBlKGZpbGVzLCBhc3luYyBmdW5jdGlvbiogKGZpbGVzKSB7XG4gICAgICBmb3IgYXdhaXQgKGNvbnN0IGZpbGUgb2YgZmlsZXMpIHtcbiAgICAgICAgeWllbGQgdG9JbXBvcnRDYW5kaWRhdGUoZmlsZS5uYW1lLCBmaWxlKVxuICAgICAgICBzaXplICs9IGZpbGUuc2l6ZVxuICAgICAgfVxuICAgIH0pXG4gICAgY29uc3QgcGFja2VkID0gYXdhaXQgcGFja0NhcihpbnB1dCwge1xuICAgICAgYmxvY2tzdG9yZSxcbiAgICAgIHdyYXBXaXRoRGlyZWN0b3J5OiB0cnVlLFxuICAgIH0pXG4gICAgaWYgKHNpemUgPT09IDApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgJ1RvdGFsIHNpemUgb2YgZmlsZXMgc2hvdWxkIGV4Y2VlZCAwLCBtYWtlIHN1cmUgdG8gcHJvdmlkZSBzb21lIGNvbnRlbnQnXG4gICAgICApXG4gICAgfVxuICAgIHJldHVybiBwYWNrZWRcbiAgfVxuXG4gIC8vIEp1c3QgYSBzdWdhciBzbyB5b3UgZG9uJ3QgaGF2ZSB0byBwYXNzIGFyb3VuZCBlbmRwb2ludCBhbmQgdG9rZW4gYXJvdW5kLlxuXG4gIC8qKlxuICAgKiBTdG9yZXMgYSBzaW5nbGUgZmlsZSBhbmQgcmV0dXJucyB0aGUgY29ycmVzcG9uZGluZyBDb250ZW50IElkZW50aWZpZXIgKENJRCkuXG4gICAqIFRha2VzIGEgW0Jsb2JdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9CbG9iL0Jsb2IpXG4gICAqIG9yIGEgW0ZpbGVdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9GaWxlKS4gTm90ZVxuICAgKiB0aGF0IG5vIGZpbGUgbmFtZSBvciBmaWxlIG1ldGFkYXRhIGlzIHJldGFpbmVkLlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBgYGBqc1xuICAgKiBjb25zdCBjb250ZW50ID0gbmV3IEJsb2IoWydoZWxsbyB3b3JsZCddKVxuICAgKiBjb25zdCBjaWQgPSBhd2FpdCBjbGllbnQuc3RvcmVCbG9iKGNvbnRlbnQpXG4gICAqIGNpZCAvLz4gJ3pkajdXbjlGUUFVUkNQNk1id2NXdXppN3U2NWtBc1hDZGpOVGtoYkpjb2FYQnVzcTknXG4gICAqIGBgYFxuICAgKlxuICAgKiBAcGFyYW0ge0Jsb2J9IGJsb2JcbiAgICogQHBhcmFtIHtSZXF1ZXN0T3B0aW9uc30gW29wdGlvbnNdXG4gICAqL1xuICBzdG9yZUJsb2IoYmxvYiwgb3B0aW9ucykge1xuICAgIHJldHVybiBORlRTdG9yYWdlLnN0b3JlQmxvYih0aGlzLCBibG9iLCBvcHRpb25zKVxuICB9XG5cbiAgLyoqXG4gICAqIFN0b3JlcyBmaWxlcyBlbmNvZGVkIGFzIGEgc2luZ2xlIFtDb250ZW50IEFkZHJlc3NlZCBBcmNoaXZlXG4gICAqIChDQVIpXShodHRwczovL2dpdGh1Yi5jb20vaXBsZC9zcGVjcy9ibG9iL21hc3Rlci9ibG9jay1sYXllci9jb250ZW50LWFkZHJlc3NhYmxlLWFyY2hpdmVzLm1kKS5cbiAgICpcbiAgICogVGFrZXMgYSBbQmxvYl0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0Jsb2IvQmxvYilcbiAgICogb3IgYSBbRmlsZV0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0ZpbGUpLlxuICAgKlxuICAgKiBSZXR1cm5zIHRoZSBjb3JyZXNwb25kaW5nIENvbnRlbnQgSWRlbnRpZmllciAoQ0lEKS5cbiAgICpcbiAgICogU2VlIHRoZSBbYGlwZnMtY2FyYCBkb2NzXShodHRwczovL3d3dy5ucG1qcy5jb20vcGFja2FnZS9pcGZzLWNhcikgZm9yIG1vcmVcbiAgICogZGV0YWlscyBvbiBwYWNraW5nIGEgQ0FSIGZpbGUuXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIGBgYGpzXG4gICAqIGltcG9ydCB7IHBhY2sgfSBmcm9tICdpcGZzLWNhci9wYWNrJ1xuICAgKiBpbXBvcnQgeyBDYXJSZWFkZXIgfSBmcm9tICdAaXBsZC9jYXInXG4gICAqIGNvbnN0IHsgb3V0LCByb290IH0gPSBhd2FpdCBwYWNrKHtcbiAgICogIGlucHV0OiBmcy5jcmVhdGVSZWFkU3RyZWFtKCdwaW5waWUucGRmJylcbiAgICogfSlcbiAgICogY29uc3QgZXhwZWN0ZWRDaWQgPSByb290LnRvU3RyaW5nKClcbiAgICogY29uc3QgY2FyUmVhZGVyID0gYXdhaXQgQ2FyUmVhZGVyLmZyb21JdGVyYWJsZShvdXQpXG4gICAqIGNvbnN0IGNpZCA9IGF3YWl0IHN0b3JhZ2Uuc3RvcmVDYXIoY2FyUmVhZGVyKVxuICAgKiBjb25zb2xlLmFzc2VydChjaWQgPT09IGV4cGVjdGVkQ2lkKVxuICAgKiBgYGBcbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogYGBgXG4gICAqIGltcG9ydCB7IHBhY2tUb0Jsb2IgfSBmcm9tICdpcGZzLWNhci9wYWNrL2Jsb2InXG4gICAqIGNvbnN0IGRhdGEgPSAnSGVsbG8gd29ybGQnXG4gICAqIGNvbnN0IHsgcm9vdCwgY2FyIH0gPSBhd2FpdCBwYWNrVG9CbG9iKHsgaW5wdXQ6IFtuZXcgVGV4dEVuY29kZXIoKS5lbmNvZGUoZGF0YSldIH0pXG4gICAqIGNvbnN0IGV4cGVjdGVkQ2lkID0gcm9vdC50b1N0cmluZygpXG4gICAqIGNvbnN0IGNpZCA9IGF3YWl0IGNsaWVudC5zdG9yZUNhcihjYXIpXG4gICAqIGNvbnNvbGUuYXNzZXJ0KGNpZCA9PT0gZXhwZWN0ZWRDaWQpXG4gICAqIGBgYFxuICAgKiBAcGFyYW0ge0Jsb2J8Q2FyUmVhZGVyfSBjYXJcbiAgICogQHBhcmFtIHtpbXBvcnQoJy4vbGliL2ludGVyZmFjZS5qcycpLkNhclN0b3Jlck9wdGlvbnN9IFtvcHRpb25zXVxuICAgKi9cbiAgc3RvcmVDYXIoY2FyLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIE5GVFN0b3JhZ2Uuc3RvcmVDYXIodGhpcywgY2FyLCBvcHRpb25zKVxuICB9XG5cbiAgLyoqXG4gICAqIFN0b3JlcyBhIGRpcmVjdG9yeSBvZiBmaWxlcyBhbmQgcmV0dXJucyBhIENJRCBmb3IgdGhlIGRpcmVjdG9yeS5cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogYGBganNcbiAgICogY29uc3QgY2lkID0gYXdhaXQgY2xpZW50LnN0b3JlRGlyZWN0b3J5KFtcbiAgICogICBuZXcgRmlsZShbJ2hlbGxvIHdvcmxkJ10sICdoZWxsby50eHQnKSxcbiAgICogICBuZXcgRmlsZShbSlNPTi5zdHJpbmdpZnkoeydmcm9tJzogJ2luY29nbml0byd9LCBudWxsLCAyKV0sICdtZXRhZGF0YS5qc29uJylcbiAgICogXSlcbiAgICogY2lkIC8vPlxuICAgKiBgYGBcbiAgICpcbiAgICogQXJndW1lbnQgY2FuIGJlIGEgW0ZpbGVMaXN0XShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvRmlsZUxpc3QpXG4gICAqIGluc3RhbmNlIGFzIHdlbGwsIGluIHdoaWNoIGNhc2UgZGlyZWN0b3J5IHN0cnVjdHVyZSB3aWxsIGJlIHJldGFpbmVkLlxuICAgKlxuICAgKiBAcGFyYW0ge0ZpbGVzU291cmNlfSBmaWxlc1xuICAgKiBAcGFyYW0ge1JlcXVlc3RPcHRpb25zfSBbb3B0aW9uc11cbiAgICovXG4gIHN0b3JlRGlyZWN0b3J5KGZpbGVzLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIE5GVFN0b3JhZ2Uuc3RvcmVEaXJlY3RvcnkodGhpcywgZmlsZXMsIG9wdGlvbnMpXG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBjdXJyZW50IHN0YXR1cyBvZiB0aGUgc3RvcmVkIE5GVCBieSBpdHMgQ0lELiBOb3RlIHRoZSBORlQgbXVzdFxuICAgKiBoYXZlIHByZXZpb3VzbHkgYmVlbiBzdG9yZWQgYnkgdGhpcyBhY2NvdW50LlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBgYGBqc1xuICAgKiBjb25zdCBzdGF0dXMgPSBhd2FpdCBjbGllbnQuc3RhdHVzKCd6ZGo3V245RlFBVVJDUDZNYndjV3V6aTd1NjVrQXNYQ2RqTlRraGJKY29hWEJ1c3E5JylcbiAgICogYGBgXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBjaWRcbiAgICogQHBhcmFtIHtSZXF1ZXN0T3B0aW9uc30gW29wdGlvbnNdXG4gICAqL1xuICBzdGF0dXMoY2lkLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIE5GVFN0b3JhZ2Uuc3RhdHVzKHRoaXMsIGNpZCwgb3B0aW9ucylcbiAgfVxuXG4gIC8qKlxuICAgKiBSZW1vdmVzIHN0b3JlZCBjb250ZW50IGJ5IGl0cyBDSUQgZnJvbSB0aGUgc2VydmljZS5cbiAgICpcbiAgICogPiBQbGVhc2Ugbm90ZSB0aGF0IGV2ZW4gaWYgY29udGVudCBpcyByZW1vdmVkIGZyb20gdGhlIHNlcnZpY2Ugb3RoZXIgbm9kZXNcbiAgICogdGhhdCBoYXZlIHJlcGxpY2F0ZWQgaXQgbWlnaHQgc3RpbGwgY29udGludWUgcHJvdmlkaW5nIGl0LlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBgYGBqc1xuICAgKiBhd2FpdCBjbGllbnQuZGVsZXRlKCd6ZGo3V245RlFBVVJDUDZNYndjV3V6aTd1NjVrQXNYQ2RqTlRraGJKY29hWEJ1c3E5JylcbiAgICogYGBgXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBjaWRcbiAgICogQHBhcmFtIHtSZXF1ZXN0T3B0aW9uc30gW29wdGlvbnNdXG4gICAqL1xuICBkZWxldGUoY2lkLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIE5GVFN0b3JhZ2UuZGVsZXRlKHRoaXMsIGNpZCwgb3B0aW9ucylcbiAgfVxuXG4gIC8qKlxuICAgKiBDaGVjayBpZiBhIENJRCBvZiBhbiBORlQgaXMgYmVpbmcgc3RvcmVkIGJ5IG5mdC5zdG9yYWdlLiBUaHJvd3MgaWYgdGhlIE5GVFxuICAgKiB3YXMgbm90IGZvdW5kLlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBgYGBqc1xuICAgKiBjb25zdCBzdGF0dXMgPSBhd2FpdCBjbGllbnQuY2hlY2soJ3pkajdXbjlGUUFVUkNQNk1id2NXdXppN3U2NWtBc1hDZGpOVGtoYkpjb2FYQnVzcTknKVxuICAgKiBgYGBcbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IGNpZFxuICAgKiBAcGFyYW0ge1JlcXVlc3RPcHRpb25zfSBbb3B0aW9uc11cbiAgICovXG4gIGNoZWNrKGNpZCwgb3B0aW9ucykge1xuICAgIHJldHVybiBORlRTdG9yYWdlLmNoZWNrKHRoaXMsIGNpZCwgb3B0aW9ucylcbiAgfVxuXG4gIC8qKlxuICAgKiBTdG9yZXMgdGhlIGdpdmVuIHRva2VuIGFuZCBhbGwgcmVzb3VyY2VzIGl0IHJlZmVyZW5jZXMgKGluIHRoZSBmb3JtIG9mIGFcbiAgICogRmlsZSBvciBhIEJsb2IpIGFsb25nIHdpdGggYSBtZXRhZGF0YSBKU09OIGFzIHNwZWNpZmljZWQgaW5cbiAgICogW0VSQy0xMTU1XShodHRwczovL2VpcHMuZXRoZXJldW0ub3JnL0VJUFMvZWlwLTExNTUjbWV0YWRhdGEpLiBUaGVcbiAgICogYHRva2VuLmltYWdlYCBtdXN0IGJlIGVpdGhlciBhIGBGaWxlYCBvciBhIGBCbG9iYCBpbnN0YW5jZSwgd2hpY2ggd2lsbCBiZVxuICAgKiBzdG9yZWQgYW5kIHRoZSBjb3JyZXNwb25kaW5nIGNvbnRlbnQgYWRkcmVzcyBVUkwgd2lsbCBiZSBzYXZlZCBpbiB0aGVcbiAgICogbWV0YWRhdGEgSlNPTiBmaWxlIHVuZGVyIGBpbWFnZWAgZmllbGQuXG4gICAqXG4gICAqIElmIGB0b2tlbi5wcm9wZXJ0aWVzYCBjb250YWlucyBwcm9wZXJ0aWVzIHdpdGggYEZpbGVgIG9yIGBCbG9iYCB2YWx1ZXMsXG4gICAqIHRob3NlIGFsc28gZ2V0IHN0b3JlZCBhbmQgdGhlaXIgVVJMcyB3aWxsIGJlIHNhdmVkIGluIHRoZSBtZXRhZGF0YSBKU09OXG4gICAqIGZpbGUgaW4gdGhlaXIgcGxhY2UuXG4gICAqXG4gICAqIE5vdGU6IFVSTHMgZm9yIGBGaWxlYCBvYmplY3RzIHdpbGwgcmV0YWluIGZpbGUgbmFtZXMgZS5nLiBpbiBjYXNlIG9mXG4gICAqIGBuZXcgRmlsZShbYnl0ZXNdLCAnY2F0LnBuZycsIHsgdHlwZTogJ2ltYWdlL3BuZycgfSlgIHdpbGwgYmUgdHJhbnNmb3JtZWRcbiAgICogaW50byBhIFVSTCB0aGF0IGxvb2tzIGxpa2UgYGlwZnM6Ly9iYWZ5Li4uaGFzaC9pbWFnZS9jYXQucG5nYC4gRm9yIGBCbG9iYFxuICAgKiBvYmplY3RzLCB0aGUgVVJMIHdpbGwgbm90IGhhdmUgYSBmaWxlIG5hbWUgbmFtZSBvciBtaW1lIHR5cGUsIGluc3RlYWQgaXRcbiAgICogd2lsbCBiZSB0cmFuc2Zvcm1lZCBpbnRvIGEgVVJMIHRoYXQgbG9va3MgbGlrZVxuICAgKiBgaXBmczovL2JhZnkuLi5oYXNoL2ltYWdlL2Jsb2JgLlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBgYGBqc1xuICAgKiBjb25zdCBtZXRhZGF0YSA9IGF3YWl0IGNsaWVudC5zdG9yZSh7XG4gICAqICAgbmFtZTogJ25mdC5zdG9yYWdlIHN0b3JlIHRlc3QnLFxuICAgKiAgIGRlc2NyaXB0aW9uOiAnVGVzdCBFUkMtMTE1NSBjb21wYXRpYmxlIG1ldGFkYXRhLicsXG4gICAqICAgaW1hZ2U6IG5ldyBGaWxlKFsnPERBVEE+J10sICdwaW5waWUuanBnJywgeyB0eXBlOiAnaW1hZ2UvanBnJyB9KSxcbiAgICogICBwcm9wZXJ0aWVzOiB7XG4gICAqICAgICBjdXN0b206ICdDdXN0b20gZGF0YSBjYW4gYXBwZWFyIGhlcmUsIGZpbGVzIGFyZSBhdXRvIHVwbG9hZGVkLicsXG4gICAqICAgICBmaWxlOiBuZXcgRmlsZShbJzxEQVRBPiddLCAnUkVBRE1FLm1kJywgeyB0eXBlOiAndGV4dC9wbGFpbicgfSksXG4gICAqICAgfVxuICAgKiB9KVxuICAgKlxuICAgKiBjb25zb2xlLmxvZygnSVBGUyBVUkwgZm9yIHRoZSBtZXRhZGF0YTonLCBtZXRhZGF0YS51cmwpXG4gICAqIGNvbnNvbGUubG9nKCdtZXRhZGF0YS5qc29uIGNvbnRlbnRzOlxcbicsIG1ldGFkYXRhLmRhdGEpXG4gICAqIGNvbnNvbGUubG9nKCdtZXRhZGF0YS5qc29uIHdpdGggSVBGUyBnYXRld2F5IFVSTHM6XFxuJywgbWV0YWRhdGEuZW1iZWQoKSlcbiAgICogYGBgXG4gICAqXG4gICAqIEB0ZW1wbGF0ZSB7aW1wb3J0KCcuL2xpYi9pbnRlcmZhY2UuanMnKS5Ub2tlbklucHV0fSBUXG4gICAqIEBwYXJhbSB7VH0gdG9rZW5cbiAgICogQHBhcmFtIHtSZXF1ZXN0T3B0aW9uc30gW29wdGlvbnNdXG4gICAqL1xuICBzdG9yZSh0b2tlbiwgb3B0aW9ucykge1xuICAgIHJldHVybiBORlRTdG9yYWdlLnN0b3JlKHRoaXMsIHRva2VuLCBvcHRpb25zKVxuICB9XG59XG5cbi8qKlxuICogQ2FzdCBhbiBpdGVyYWJsZSB0byBhbiBhc3luY0l0ZXJhYmxlXG4gKiBAdGVtcGxhdGUgVFxuICogQHBhcmFtIHtJdGVyYWJsZTxUPn0gaXRlcmFibGVcbiAqIEByZXR1cm5zIHtBc3luY0l0ZXJhYmxlPFQ+fVxuICovXG5leHBvcnQgZnVuY3Rpb24gdG9Bc3luY0l0ZXJhYmxlKGl0ZXJhYmxlKSB7XG4gIHJldHVybiAoYXN5bmMgZnVuY3Rpb24qICgpIHtcbiAgICBmb3IgKGNvbnN0IGl0ZW0gb2YgaXRlcmFibGUpIHtcbiAgICAgIHlpZWxkIGl0ZW1cbiAgICB9XG4gIH0pKClcbn1cblxuLyoqXG4gKiBAdGVtcGxhdGUge2ltcG9ydCgnLi9saWIvaW50ZXJmYWNlLmpzJykuVG9rZW5JbnB1dH0gVFxuICogQHBhcmFtIHtUfSBtZXRhZGF0YVxuICovXG5jb25zdCB2YWxpZGF0ZUVSQzExNTUgPSAoeyBuYW1lLCBkZXNjcmlwdGlvbiwgaW1hZ2UsIGRlY2ltYWxzIH0pID0+IHtcbiAgLy8gSnVzdCB2YWxpZGF0ZSB0aGF0IGV4cGVjdGVkIGZpZWxkcyBhcmUgcHJlc2VudFxuICBpZiAodHlwZW9mIG5hbWUgIT09ICdzdHJpbmcnKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgICdzdHJpbmcgcHJvcGVydHkgYG5hbWVgIGlkZW50aWZ5aW5nIHRoZSBhc3NldCBpcyByZXF1aXJlZCdcbiAgICApXG4gIH1cbiAgaWYgKHR5cGVvZiBkZXNjcmlwdGlvbiAhPT0gJ3N0cmluZycpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgJ3N0cmluZyBwcm9wZXJ0eSBgZGVzY3JpcHRpb25gIGRlc2NyaWJpbmcgYXNzZXQgaXMgcmVxdWlyZWQnXG4gICAgKVxuICB9XG4gIGlmICghKGltYWdlIGluc3RhbmNlb2YgQmxvYikpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdwcm9wZXJ0eSBgaW1hZ2VgIG11c3QgYmUgYSBCbG9iIG9yIEZpbGUgb2JqZWN0JylcbiAgfSBlbHNlIGlmICghaW1hZ2UudHlwZS5zdGFydHNXaXRoKCdpbWFnZS8nKSkge1xuICAgIGNvbnNvbGUud2FybihgQWNjb3JkaW5nIHRvIEVSQzcyMSBNZXRhZGF0YSBKU09OIFNjaGVtYSAnaW1hZ2UnIG11c3QgaGF2ZSAnaW1hZ2UvKicgbWltZSB0eXBlLlxuXG5Gb3IgYmV0dGVyIGludGVyb3BlcmFiaWxpdHkgd2Ugd291bGQgaGlnaGx5IHJlY29tbWVuZCBzdG9yaW5nIGNvbnRlbnQgd2l0aCBkaWZmZXJlbnQgbWltZSB0eXBlIHVuZGVyICdwcm9wZXJ0aWVzJyBuYW1lc3BhY2UgZS5nLiBcXGBwcm9wZXJ0aWVzOiB7IHZpZGVvOiBmaWxlIH1cXGAgYW5kIHVzaW5nICdpbWFnZScgZmllbGQgZm9yIHN0b3JpbmcgYSBwcmV2aWV3IGltYWdlIGZvciBpdCBpbnN0ZWFkLlxuXG5Gb3IgbW9yZSBjb250ZXh0IHBsZWFzZSBzZWUgRVJDLTcyMSBzcGVjaWZpY2F0aW9uIGh0dHBzOi8vZWlwcy5ldGhlcmV1bS5vcmcvRUlQUy9laXAtNzIxYClcbiAgfVxuXG4gIGlmICh0eXBlb2YgZGVjaW1hbHMgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiBkZWNpbWFscyAhPT0gJ251bWJlcicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdwcm9wZXJ0eSBgZGVjaW1hbHNgIG11c3QgYmUgYW4gaW50ZWdlciB2YWx1ZScpXG4gIH1cbn1cblxuLyoqXG4gKiBAcGFyYW0ge2ltcG9ydCgnaXBmcy1jYXIvcGFjaycpLkltcG9ydENhbmRpZGF0ZVN0cmVhbXxBcnJheTx7IHBhdGg6IHN0cmluZywgY29udGVudDogaW1wb3J0KCcuL3BsYXRmb3JtLmpzJykuUmVhZGFibGVTdHJlYW0gfT59IGlucHV0XG4gKiBAcGFyYW0ge29iamVjdH0gW29wdGlvbnNdXG4gKiBAcGFyYW0ge0Jsb2Nrc3RvcmVJfSBbb3B0aW9ucy5ibG9ja3N0b3JlXVxuICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy53cmFwV2l0aERpcmVjdG9yeV1cbiAqL1xuY29uc3QgcGFja0NhciA9IGFzeW5jIChpbnB1dCwgeyBibG9ja3N0b3JlLCB3cmFwV2l0aERpcmVjdG9yeSB9ID0ge30pID0+IHtcbiAgLyogYzggaWdub3JlIG5leHQgMSAqL1xuICBibG9ja3N0b3JlID0gYmxvY2tzdG9yZSB8fCBuZXcgQmxvY2tzdG9yZSgpXG4gIGNvbnN0IHsgcm9vdDogY2lkIH0gPSBhd2FpdCBwYWNrKHsgaW5wdXQsIGJsb2Nrc3RvcmUsIHdyYXBXaXRoRGlyZWN0b3J5IH0pXG4gIGNvbnN0IGNhciA9IG5ldyBCbG9ja3N0b3JlQ2FyUmVhZGVyKDEsIFtjaWRdLCBibG9ja3N0b3JlKVxuICByZXR1cm4geyBjaWQsIGNhciB9XG59XG5cbi8qKlxuICogQHBhcmFtIHtEZWFsW119IGRlYWxzXG4gKiBAcmV0dXJucyB7RGVhbFtdfVxuICovXG5jb25zdCBkZWNvZGVEZWFscyA9IChkZWFscykgPT5cbiAgZGVhbHMubWFwKChkZWFsKSA9PiB7XG4gICAgY29uc3QgeyBkZWFsQWN0aXZhdGlvbiwgZGVhbEV4cGlyYXRpb24sIGxhc3RDaGFuZ2VkIH0gPSB7XG4gICAgICBkZWFsRXhwaXJhdGlvbjogbnVsbCxcbiAgICAgIGRlYWxBY3RpdmF0aW9uOiBudWxsLFxuICAgICAgLi4uZGVhbCxcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgLi4uZGVhbCxcbiAgICAgIGxhc3RDaGFuZ2VkOiBuZXcgRGF0ZShsYXN0Q2hhbmdlZCksXG4gICAgICAuLi4oZGVhbEFjdGl2YXRpb24gJiYgeyBkZWFsQWN0aXZhdGlvbjogbmV3IERhdGUoZGVhbEFjdGl2YXRpb24pIH0pLFxuICAgICAgLi4uKGRlYWxFeHBpcmF0aW9uICYmIHsgZGVhbEV4cGlyYXRpb246IG5ldyBEYXRlKGRlYWxFeHBpcmF0aW9uKSB9KSxcbiAgICB9XG4gIH0pXG5cbi8qKlxuICogQHBhcmFtIHtQaW59IHBpblxuICogQHJldHVybnMge1Bpbn1cbiAqL1xuY29uc3QgZGVjb2RlUGluID0gKHBpbikgPT4gKHsgLi4ucGluLCBjcmVhdGVkOiBuZXcgRGF0ZShwaW4uY3JlYXRlZCkgfSlcblxuLyoqXG4gKiBDb252ZXJ0IHRoZSBwYXNzZWQgYmxvYiB0byBhbiBcImltcG9ydCBjYW5kaWRhdGVcIiAtIGFuIG9iamVjdCBzdWl0YWJsZSBmb3JcbiAqIHBhc3NpbmcgdG8gdGhlIGlwZnMtdW5peGZzLWltcG9ydGVyLiBOb3RlOiBjb250ZW50IGlzIGFuIGFjY2Vzc29yIHNvIHRoYXRcbiAqIHRoZSBzdHJlYW0gaXMgY3JlYXRlZCBvbmx5IHdoZW4gbmVlZGVkLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBwYXRoXG4gKiBAcGFyYW0ge1BpY2s8QmxvYiwgJ3N0cmVhbSc+fHsgc3RyZWFtOiAoKSA9PiBBc3luY0l0ZXJhYmxlPFVpbnQ4QXJyYXk+IH19IGJsb2JcbiAqIEByZXR1cm5zIHtpbXBvcnQoJ2lwZnMtY29yZS10eXBlcy9zcmMvdXRpbHMuanMnKS5JbXBvcnRDYW5kaWRhdGV9XG4gKi9cbmZ1bmN0aW9uIHRvSW1wb3J0Q2FuZGlkYXRlKHBhdGgsIGJsb2IpIHtcbiAgLyoqIEB0eXBlIHtBc3luY0l0ZXJhYmxlPFVpbnQ4QXJyYXk+fSAqL1xuICBsZXQgc3RyZWFtXG4gIHJldHVybiB7XG4gICAgcGF0aCxcbiAgICBnZXQgY29udGVudCgpIHtcbiAgICAgIHN0cmVhbSA9IHN0cmVhbSB8fCBibG9iLnN0cmVhbSgpXG4gICAgICByZXR1cm4gc3RyZWFtXG4gICAgfSxcbiAgfVxufVxuXG5leHBvcnQgeyBORlRTdG9yYWdlLCBGaWxlLCBCbG9iLCBGb3JtRGF0YSwgdG9HYXRld2F5VVJMLCBUb2tlbiB9XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/nft.storage/src/lib.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/nft.storage/src/platform.js":
/*!**************************************************!*\
  !*** ./node_modules/nft.storage/src/platform.js ***!
  \**************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Blob: () => (/* reexport safe */ _web_std_file__WEBPACK_IMPORTED_MODULE_2__.Blob),\n/* harmony export */   Blockstore: () => (/* reexport safe */ ipfs_car_blockstore_fs__WEBPACK_IMPORTED_MODULE_3__.FsBlockStore),\n/* harmony export */   File: () => (/* reexport safe */ _web_std_file__WEBPACK_IMPORTED_MODULE_2__.File),\n/* harmony export */   FormData: () => (/* reexport safe */ _web_std_form_data__WEBPACK_IMPORTED_MODULE_0__.FormData),\n/* harmony export */   Headers: () => (/* reexport safe */ _web_std_fetch__WEBPACK_IMPORTED_MODULE_4__.Headers),\n/* harmony export */   ReadableStream: () => (/* reexport safe */ _web_std_blob__WEBPACK_IMPORTED_MODULE_1__.ReadableStream),\n/* harmony export */   Request: () => (/* reexport safe */ _web_std_fetch__WEBPACK_IMPORTED_MODULE_4__.Request),\n/* harmony export */   Response: () => (/* reexport safe */ _web_std_fetch__WEBPACK_IMPORTED_MODULE_4__.Response),\n/* harmony export */   fetch: () => (/* reexport safe */ _web_std_fetch__WEBPACK_IMPORTED_MODULE_4__[\"default\"])\n/* harmony export */ });\n/* harmony import */ var _web_std_fetch__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @web-std/fetch */ \"(rsc)/./node_modules/@web-std/fetch/src/lib.node.js\");\n/* harmony import */ var _web_std_form_data__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @web-std/form-data */ \"(rsc)/./node_modules/@web-std/form-data/src/lib.node.js\");\n/* harmony import */ var _web_std_blob__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @web-std/blob */ \"(rsc)/./node_modules/@web-std/blob/src/lib.node.js\");\n/* harmony import */ var _web_std_file__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @web-std/file */ \"(rsc)/./node_modules/@web-std/file/src/lib.node.js\");\n/* harmony import */ var ipfs_car_blockstore_fs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ipfs-car/blockstore/fs */ \"(rsc)/./node_modules/ipfs-car/dist/esm/blockstore/fs.js\");\n\n\n\n\n\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbmZ0LnN0b3JhZ2Uvc3JjL3BsYXRmb3JtLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQWtFO0FBQ3JCO0FBQ0M7QUFDSjtBQUN5Qjs7QUFZbEUiLCJzb3VyY2VzIjpbIi9ob21lL2FsdGNvaW4tZGFkZHkvRG93bmxvYWRzL293bmx5L25vZGVfbW9kdWxlcy9uZnQuc3RvcmFnZS9zcmMvcGxhdGZvcm0uanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IGZldGNoLCB7IFJlcXVlc3QsIFJlc3BvbnNlLCBIZWFkZXJzIH0gZnJvbSAnQHdlYi1zdGQvZmV0Y2gnXG5pbXBvcnQgeyBGb3JtRGF0YSB9IGZyb20gJ0B3ZWItc3RkL2Zvcm0tZGF0YSdcbmltcG9ydCB7IFJlYWRhYmxlU3RyZWFtIH0gZnJvbSAnQHdlYi1zdGQvYmxvYidcbmltcG9ydCB7IEZpbGUsIEJsb2IgfSBmcm9tICdAd2ViLXN0ZC9maWxlJ1xuaW1wb3J0IHsgRnNCbG9ja1N0b3JlIGFzIEJsb2Nrc3RvcmUgfSBmcm9tICdpcGZzLWNhci9ibG9ja3N0b3JlL2ZzJ1xuXG5leHBvcnQge1xuICBmZXRjaCxcbiAgUmVxdWVzdCxcbiAgUmVzcG9uc2UsXG4gIEhlYWRlcnMsXG4gIEJsb2IsXG4gIEZvcm1EYXRhLFxuICBGaWxlLFxuICBSZWFkYWJsZVN0cmVhbSxcbiAgQmxvY2tzdG9yZSxcbn1cbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/nft.storage/src/platform.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/nft.storage/src/token.js":
/*!***********************************************!*\
  !*** ./node_modules/nft.storage/src/token.js ***!
  \***********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Token: () => (/* binding */ Token),\n/* harmony export */   decode: () => (/* binding */ decode),\n/* harmony export */   embed: () => (/* binding */ embed),\n/* harmony export */   encode: () => (/* binding */ encode),\n/* harmony export */   mapWith: () => (/* binding */ mapWith)\n/* harmony export */ });\n/* harmony import */ var ipfs_car_pack__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ipfs-car/pack */ \"(rsc)/./node_modules/ipfs-car/dist/esm/pack/index.js\");\n/* harmony import */ var multiformats_cid__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! multiformats/cid */ \"(rsc)/./node_modules/multiformats/esm/src/cid.js\");\n/* harmony import */ var multiformats_block__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! multiformats/block */ \"(rsc)/./node_modules/multiformats/esm/src/block.js\");\n/* harmony import */ var multiformats_hashes_sha2__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! multiformats/hashes/sha2 */ \"(rsc)/./node_modules/multiformats/esm/src/hashes/sha2.js\");\n/* harmony import */ var _ipld_dag_cbor__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @ipld/dag-cbor */ \"(rsc)/./node_modules/@ipld/dag-cbor/esm/index.js\");\n/* harmony import */ var _platform_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./platform.js */ \"(rsc)/./node_modules/nft.storage/src/platform.js\");\n/* harmony import */ var _gateway_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./gateway.js */ \"(rsc)/./node_modules/nft.storage/src/gateway.js\");\n/* harmony import */ var _bs_car_reader_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./bs-car-reader.js */ \"(rsc)/./node_modules/nft.storage/src/bs-car-reader.js\");\n\n\n\n\n\n\n\n\n\n/**\n * @typedef {import('./gateway.js').GatewayURLOptions} EmbedOptions\n * @typedef {import('./lib/interface.js').TokenInput} TokenInput\n * @typedef {import('ipfs-car/blockstore').Blockstore} Blockstore\n */\n\n/**\n * @template T\n * @typedef {import('./lib/interface.js').Encoded<T, [[Blob, URL]]>} EncodedBlobUrl\n */\n\n/**\n * @template G\n * @typedef {import('./lib/interface.js').Encoded<G, [[Blob, Blob]]>} EncodedBlobBlob\n */\n\n/**\n * @template {import('./lib/interface.js').TokenInput} T\n * @typedef {import('./lib/interface.js').Token<T>} TokenType\n */\n\n/**\n * @template {TokenInput} T\n * @implements {TokenType<T>}\n */\nclass Token {\n  /**\n   * @param {import('./lib/interface.js').CIDString} ipnft\n   * @param {import('./lib/interface.js').EncodedURL} url\n   * @param {import('./lib/interface.js').Encoded<T, [[Blob, URL]]>} data\n   */\n  constructor(ipnft, url, data) {\n    /** @readonly */\n    this.ipnft = ipnft\n    /** @readonly */\n    this.url = url\n    /** @readonly */\n    this.data = data\n\n    Object.defineProperties(this, {\n      ipnft: { enumerable: true, writable: false },\n      url: { enumerable: true, writable: false },\n      data: { enumerable: false, writable: false },\n    })\n  }\n  /**\n   * @returns {import('./lib/interface.js').Encoded<T, [[Blob, URL]]>}\n   */\n  embed() {\n    return Token.embed(this)\n  }\n\n  /**\n   * @template {TokenInput} T\n   * @param {{data: import('./lib/interface.js').Encoded<T, [[Blob, URL]]>}} token\n   * @returns {import('./lib/interface.js').Encoded<T, [[Blob, URL]]>}\n   */\n  static embed({ data }) {\n    return embed(data, { gateway: _gateway_js__WEBPACK_IMPORTED_MODULE_6__.GATEWAY })\n  }\n\n  /**\n   * Takes token input, encodes it as a DAG, wraps it in a CAR and creates a new\n   * Token instance from it. Where values are discovered `Blob` (or `File`)\n   * objects in the given input, they are replaced with IPFS URLs (an `ipfs://`\n   * prefixed CID with an optional path).\n   *\n   * @example\n   * ```js\n   * const cat = new File(['...'], 'cat.png')\n   * const kitty = new File(['...'], 'kitty.png')\n   * const { token, car } = await Token.encode({\n   *   name: 'hello'\n   *   image: cat\n   *   properties: {\n   *     extra: {\n   *       image: kitty\n   *     }\n   *   }\n   * })\n   * ```\n   *\n   * @template {TokenInput} T\n   * @param {T} input\n   * @returns {Promise<{ cid: CID, token: TokenType<T>, car: import('./lib/interface.js').CarReader }>}\n   */\n  static async encode(input) {\n    const blockstore = new _platform_js__WEBPACK_IMPORTED_MODULE_5__.Blockstore()\n    const [blobs, meta] = mapTokenInputBlobs(input)\n    /** @type {EncodedBlobUrl<T>} */\n    const data = JSON.parse(JSON.stringify(meta))\n    /** @type {import('./lib/interface.js').Encoded<T, [[Blob, CID]]>} */\n    const dag = JSON.parse(JSON.stringify(meta))\n\n    for (const [dotPath, blob] of blobs.entries()) {\n      /** @type {string|undefined} */\n      // @ts-ignore blob may be a File!\n      const name = blob.name || 'blob'\n      /** @type {import('./platform.js').ReadableStream} */\n      let content\n      // FIXME: should not be necessary to await arrayBuffer()!\n      // Node.js 20 hangs reading the stream (it never ends) but in\n      // older node versions and the browser it is fine to use blob.stream().\n      /* c8 ignore next 5 */\n      if (parseInt(globalThis.process?.versions?.node) > 18) {\n        content = new Uint8Array(await blob.arrayBuffer())\n      } else {\n        content = blob.stream()\n      }\n      const { root: cid } = await (0,ipfs_car_pack__WEBPACK_IMPORTED_MODULE_0__.pack)({\n        input: [{ path: name, content }],\n        blockstore,\n        wrapWithDirectory: true,\n      })\n\n      const href = new URL(`ipfs://${cid}/${name}`)\n      const path = dotPath.split('.')\n      setIn(data, path, href)\n      setIn(dag, path, cid)\n    }\n\n    const { root: metadataJsonCid } = await (0,ipfs_car_pack__WEBPACK_IMPORTED_MODULE_0__.pack)({\n      input: [{ path: 'metadata.json', content: JSON.stringify(data) }],\n      blockstore,\n      wrapWithDirectory: false,\n    })\n\n    const block = await multiformats_block__WEBPACK_IMPORTED_MODULE_2__.encode({\n      value: {\n        ...dag,\n        'metadata.json': metadataJsonCid,\n        type: 'nft',\n      },\n      codec: _ipld_dag_cbor__WEBPACK_IMPORTED_MODULE_4__,\n      hasher: multiformats_hashes_sha2__WEBPACK_IMPORTED_MODULE_3__.sha256,\n    })\n    await blockstore.put(block.cid, block.bytes)\n\n    return {\n      cid: block.cid,\n      token: new Token(\n        block.cid.toString(),\n        `ipfs://${block.cid}/metadata.json`,\n        data\n      ),\n      car: new _bs_car_reader_js__WEBPACK_IMPORTED_MODULE_7__.BlockstoreCarReader(1, [block.cid], blockstore),\n    }\n  }\n}\n\n/**\n * @template T\n * @param {EncodedBlobUrl<T>} input\n * @param {EmbedOptions} options\n * @returns {EncodedBlobUrl<T>}\n */\nconst embed = (input, options) =>\n  mapWith(input, isURL, embedURL, options)\n\n/**\n * @template {TokenInput} T\n * @param {import('./lib/interface.js').EncodedToken<T>} value\n * @param {Set<string>} paths - Paths were to expect EncodedURLs\n * @returns {Token<T>}\n */\nconst decode = ({ ipnft, url, data }, paths) =>\n  new Token(ipnft, url, mapWith(data, isEncodedURL, decodeURL, paths))\n\n/**\n * @param {any} value\n * @returns {value is URL}\n */\nconst isURL = (value) => value instanceof URL\n\n/**\n * @template State\n * @param {State} state\n * @param {import('./lib/interface.js').EncodedURL} url\n * @returns {[State, URL]}\n */\nconst decodeURL = (state, url) => [state, new URL(url)]\n\n/**\n * @param {EmbedOptions} context\n * @param {URL} url\n * @returns {[EmbedOptions, URL]}\n */\nconst embedURL = (context, url) => [context, (0,_gateway_js__WEBPACK_IMPORTED_MODULE_6__.toGatewayURL)(url, context)]\n\n/**\n * @param {any} value\n * @returns {value is object}\n */\nconst isObject = (value) => typeof value === 'object' && value != null\n\n/**\n * @param {any} value\n * @param {Set<string>} assetPaths\n * @param {PropertyKey[]} path\n * @returns {value is import('./lib/interface.js').EncodedURL}\n */\nconst isEncodedURL = (value, assetPaths, path) =>\n  typeof value === 'string' && assetPaths.has(path.join('.'))\n\n/**\n * Takes token input and encodes it into\n * [FormData](https://developer.mozilla.org/en-US/docs/Web/API/FormData)\n * object where form field values are discovered `Blob` (or `File`) objects in\n * the given token and field keys are `.` joined paths where they were discoverd\n * in the token. Additionally encoded `FormData` will also have a field\n * named `meta` containing JSON serialized token with blobs and file values\n * `null` set to null (this allows backend to injest all of the files from\n * `multipart/form-data` request and update provided \"meta\" data with\n * corresponding file ipfs:// URLs)\n *\n * @example\n * ```js\n * const cat = new File([], 'cat.png')\n * const kitty = new File([], 'kitty.png')\n * const form = encode({\n *   name: 'hello'\n *   image: cat\n *   properties: {\n *     extra: {\n *       image: kitty\n *     }\n *   }\n * })\n * [...form.entries()] //>\n * // [\n * //   ['image', cat],\n * //   ['properties.extra.image', kitty],\n * //   ['meta', '{\"name\":\"hello\",image:null,\"properties\":{\"extra\":{\"kitty\": null}}}']\n * // ]\n * ```\n *\n * @template {TokenInput} T\n * @param {EncodedBlobBlob<T>} input\n * @returns {FormData}\n */\nconst encode = (input) => {\n  const [map, meta] = mapValueWith(input, isBlob, encodeBlob, new Map(), [])\n  const form = new _platform_js__WEBPACK_IMPORTED_MODULE_5__.FormData()\n  for (const [k, v] of map.entries()) {\n    form.set(k, v)\n  }\n  form.set('meta', JSON.stringify(meta))\n  return form\n}\n\n/**\n * @param {Map<string, Blob>} data\n * @param {Blob} blob\n * @param {PropertyKey[]} path\n * @returns {[Map<string, Blob>, void]}\n */\nconst encodeBlob = (data, blob, path) => {\n  data.set(path.join('.'), blob)\n  return [data, undefined]\n}\n\n/**\n * @param {any} value\n * @returns {value is Blob}\n */\nconst isBlob = (value) => value instanceof _platform_js__WEBPACK_IMPORTED_MODULE_5__.Blob\n\n/**\n * @template {TokenInput} T\n * @param {EncodedBlobBlob<T>} input\n */\nconst mapTokenInputBlobs = (input) => {\n  return mapValueWith(input, isBlob, encodeBlob, new Map(), [])\n}\n\n/**\n * Substitues values in the given `input` that match `p(value) == true` with\n * `f(value, context, path)` where `context` is whatever you pass (usually\n * a mutable state) and `path` is a array of keys / indexes where the value\n * was encountered.\n *\n * @template T, I, X, O, State\n * @param {import('./lib/interface.js').Encoded<T, [[I, X]]>} input - Arbitrary input.\n * @param {(input:any, state:State, path:PropertyKey[]) => input is X} p - Predicate function to determine\n * which values to swap.\n * @param {(state:State, input:X, path:PropertyKey[]) => [State, O]} f - Function\n * that swaps matching values.\n * @param {State} state - Some additional context you need in the process.\n * likey you'll start with `[]`.\n * @returns {import('./lib/interface.js').Encoded<T, [[I, O]]>}\n */\nconst mapWith = (input, p, f, state) => {\n  const [, output] = mapValueWith(input, p, f, state, [])\n  return output\n}\n\n/**\n * @template T, I, X, O, State\n * @param {import('./lib/interface.js').Encoded<T, [[I, X]]>} input - Arbitrary input.\n * @param {(input:any, state:State, path:PropertyKey[]) => input is X} p - Predicate function to determine\n * which values to swap.\n * @param {(state:State, input:X, path:PropertyKey[]) => [State, O]} f - Function\n * that swaps matching values.\n * @param {State} state - Some additional context you need in the process.\n * @param {PropertyKey[]} path - Path where the value was encountered. Most\n * likey you'll start with `[]`.\n * @returns {[State, import('./lib/interface.js').Encoded<T, [[I, O]]>]}\n */\nconst mapValueWith = (input, p, f, state, path) =>\n  p(input, state, path)\n    ? f(state, input, path)\n    : Array.isArray(input)\n    ? mapArrayWith(input, p, f, state, path)\n    : isObject(input)\n    ? mapObjectWith(input, p, f, state, path)\n    : [state, /** @type {any} */ (input)]\n\n/**\n * Just like `mapWith` except\n *\n * @template State, T, I, X, O\n * @param {import('./lib/interface.js').Encoded<T, [[I, X]]>} input\n * @param {(input:any, state:State, path:PropertyKey[]) => input is X} p\n * @param {(state: State, input:X, path:PropertyKey[]) => [State, O]} f\n * @param {State} init\n * @param {PropertyKey[]} path\n * @returns {[State, import('./lib/interface.js').Encoded<T, [[I, O]]>]}\n */\nconst mapObjectWith = (input, p, f, init, path) => {\n  let state = init\n  const output =\n    /** @type {import('./lib/interface.js').Encoded<T, [[I, O]]>} */ ({})\n  for (const [key, value] of Object.entries(input)) {\n    const [next, out] = mapValueWith(value, p, f, state, [...path, key])\n    // @ts-ignore\n    output[key] = out\n    state = next\n  }\n  return [state, output]\n}\n\n/**\n * Just like `mapWith` except for Arrays.\n *\n * @template I, X, O, State\n * @template {any[]} T\n * @param {T} input\n * @param {(input:any, state:State, path:PropertyKey[]) => input is X} p\n * @param {(state: State, input:X, path:PropertyKey[]) => [State, O]} f\n * @param {State} init\n * @param {PropertyKey[]} path\n * @returns {[State, import('./lib/interface.js').Encoded<T, [[I, O]]>]}\n */\nconst mapArrayWith = (input, p, f, init, path) => {\n  const output = /** @type {unknown[]} */ ([])\n\n  let state = init\n  for (const [index, element] of input.entries()) {\n    const [next, out] = mapValueWith(element, p, f, state, [...path, index])\n    output[index] = out\n    state = next\n  }\n\n  return [\n    state,\n    /** @type {import('./lib/interface.js').Encoded<T, [[I, O]]>} */ (output),\n  ]\n}\n\n/**\n * Sets a given `value` at the given `path` on a passed `object`.\n *\n * @example\n * ```js\n * const obj = { a: { b: { c: 1 }}}\n * setIn(obj, ['a', 'b', 'c'], 5)\n * obj.a.b.c //> 5\n * ```\n *\n * @template V\n * @param {any} object\n * @param {string[]} path\n * @param {V} value\n */\nconst setIn = (object, path, value) => {\n  const n = path.length - 1\n  let target = object\n  for (let [index, key] of path.entries()) {\n    if (index === n) {\n      target[key] = value\n    } else {\n      target = target[key]\n    }\n  }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbmZ0LnN0b3JhZ2Uvc3JjL3Rva2VuLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBb0M7QUFDRTtBQUNLO0FBQ007QUFDUjtBQUNpQjtBQUNOO0FBQ0k7O0FBRXhEO0FBQ0EsYUFBYSwwQ0FBMEM7QUFDdkQsYUFBYSx5Q0FBeUM7QUFDdEQsYUFBYSwwQ0FBMEM7QUFDdkQ7O0FBRUE7QUFDQTtBQUNBLGFBQWEsd0RBQXdEO0FBQ3JFOztBQUVBO0FBQ0E7QUFDQSxhQUFhLHlEQUF5RDtBQUN0RTs7QUFFQTtBQUNBLGNBQWMseUNBQXlDO0FBQ3ZELGFBQWEsdUNBQXVDO0FBQ3BEOztBQUVBO0FBQ0EsY0FBYyxZQUFZO0FBQzFCLGdCQUFnQjtBQUNoQjtBQUNPO0FBQ1A7QUFDQSxhQUFhLHdDQUF3QztBQUNyRCxhQUFhLHlDQUF5QztBQUN0RCxhQUFhLHdEQUF3RDtBQUNyRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZUFBZSxtQ0FBbUM7QUFDbEQsYUFBYSxtQ0FBbUM7QUFDaEQsY0FBYyxvQ0FBb0M7QUFDbEQsS0FBSztBQUNMO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxnQkFBZ0IsWUFBWTtBQUM1QixjQUFjLCtEQUErRDtBQUM3RSxlQUFlO0FBQ2Y7QUFDQSxpQkFBaUIsTUFBTTtBQUN2Qix5QkFBeUIsU0FBUyxnREFBTyxFQUFFO0FBQzNDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxhQUFhO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxnQkFBZ0IsWUFBWTtBQUM1QixhQUFhLEdBQUc7QUFDaEIsZUFBZSxVQUFVLDRFQUE0RTtBQUNyRztBQUNBO0FBQ0EsMkJBQTJCLG9EQUFVO0FBQ3JDO0FBQ0Es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O0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixLQUFLOztBQUU5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsbURBQW1EO0FBQzlELFdBQVcsNERBQTREO0FBQ3ZFLFdBQVcsMkRBQTJEO0FBQ3RFLFdBQVcsT0FBTztBQUNsQixXQUFXLGVBQWU7QUFDMUIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxtREFBbUQsTUFBTTtBQUN4RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxPQUFPO0FBQ3JCLFdBQVcsR0FBRztBQUNkLFdBQVcsNERBQTREO0FBQ3ZFLFdBQVcsMkRBQTJEO0FBQ3RFLFdBQVcsT0FBTztBQUNsQixXQUFXLGVBQWU7QUFDMUIsYUFBYTtBQUNiO0FBQ0E7QUFDQSw0QkFBNEIsV0FBVzs7QUFFdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxlQUFlLG1EQUFtRDtBQUNsRTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsS0FBSyxLQUFLO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEtBQUs7QUFDaEIsV0FBVyxVQUFVO0FBQ3JCLFdBQVcsR0FBRztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyIvaG9tZS9hbHRjb2luLWRhZGR5L0Rvd25sb2Fkcy9vd25seS9ub2RlX21vZHVsZXMvbmZ0LnN0b3JhZ2Uvc3JjL3Rva2VuLmpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IHBhY2sgfSBmcm9tICdpcGZzLWNhci9wYWNrJ1xuaW1wb3J0IHsgQ0lEIH0gZnJvbSAnbXVsdGlmb3JtYXRzL2NpZCdcbmltcG9ydCAqIGFzIEJsb2NrIGZyb20gJ211bHRpZm9ybWF0cy9ibG9jaydcbmltcG9ydCB7IHNoYTI1NiB9IGZyb20gJ211bHRpZm9ybWF0cy9oYXNoZXMvc2hhMidcbmltcG9ydCAqIGFzIGRhZ0Nib3IgZnJvbSAnQGlwbGQvZGFnLWNib3InXG5pbXBvcnQgeyBCbG9iLCBGb3JtRGF0YSwgQmxvY2tzdG9yZSB9IGZyb20gJy4vcGxhdGZvcm0uanMnXG5pbXBvcnQgeyB0b0dhdGV3YXlVUkwsIEdBVEVXQVkgfSBmcm9tICcuL2dhdGV3YXkuanMnXG5pbXBvcnQgeyBCbG9ja3N0b3JlQ2FyUmVhZGVyIH0gZnJvbSAnLi9icy1jYXItcmVhZGVyLmpzJ1xuXG4vKipcbiAqIEB0eXBlZGVmIHtpbXBvcnQoJy4vZ2F0ZXdheS5qcycpLkdhdGV3YXlVUkxPcHRpb25zfSBFbWJlZE9wdGlvbnNcbiAqIEB0eXBlZGVmIHtpbXBvcnQoJy4vbGliL2ludGVyZmFjZS5qcycpLlRva2VuSW5wdXR9IFRva2VuSW5wdXRcbiAqIEB0eXBlZGVmIHtpbXBvcnQoJ2lwZnMtY2FyL2Jsb2Nrc3RvcmUnKS5CbG9ja3N0b3JlfSBCbG9ja3N0b3JlXG4gKi9cblxuLyoqXG4gKiBAdGVtcGxhdGUgVFxuICogQHR5cGVkZWYge2ltcG9ydCgnLi9saWIvaW50ZXJmYWNlLmpzJykuRW5jb2RlZDxULCBbW0Jsb2IsIFVSTF1dPn0gRW5jb2RlZEJsb2JVcmxcbiAqL1xuXG4vKipcbiAqIEB0ZW1wbGF0ZSBHXG4gKiBAdHlwZWRlZiB7aW1wb3J0KCcuL2xpYi9pbnRlcmZhY2UuanMnKS5FbmNvZGVkPEcsIFtbQmxvYiwgQmxvYl1dPn0gRW5jb2RlZEJsb2JCbG9iXG4gKi9cblxuLyoqXG4gKiBAdGVtcGxhdGUge2ltcG9ydCgnLi9saWIvaW50ZXJmYWNlLmpzJykuVG9rZW5JbnB1dH0gVFxuICogQHR5cGVkZWYge2ltcG9ydCgnLi9saWIvaW50ZXJmYWNlLmpzJykuVG9rZW48VD59IFRva2VuVHlwZVxuICovXG5cbi8qKlxuICogQHRlbXBsYXRlIHtUb2tlbklucHV0fSBUXG4gKiBAaW1wbGVtZW50cyB7VG9rZW5UeXBlPFQ+fVxuICovXG5leHBvcnQgY2xhc3MgVG9rZW4ge1xuICAvKipcbiAgICogQHBhcmFtIHtpbXBvcnQoJy4vbGliL2ludGVyZmFjZS5qcycpLkNJRFN0cmluZ30gaXBuZnRcbiAgICogQHBhcmFtIHtpbXBvcnQoJy4vbGliL2ludGVyZmFjZS5qcycpLkVuY29kZWRVUkx9IHVybFxuICAgKiBAcGFyYW0ge2ltcG9ydCgnLi9saWIvaW50ZXJmYWNlLmpzJykuRW5jb2RlZDxULCBbW0Jsb2IsIFVSTF1dPn0gZGF0YVxuICAgKi9cbiAgY29uc3RydWN0b3IoaXBuZnQsIHVybCwgZGF0YSkge1xuICAgIC8qKiBAcmVhZG9ubHkgKi9cbiAgICB0aGlzLmlwbmZ0ID0gaXBuZnRcbiAgICAvKiogQHJlYWRvbmx5ICovXG4gICAgdGhpcy51cmwgPSB1cmxcbiAgICAvKiogQHJlYWRvbmx5ICovXG4gICAgdGhpcy5kYXRhID0gZGF0YVxuXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXModGhpcywge1xuICAgICAgaXBuZnQ6IHsgZW51bWVyYWJsZTogdHJ1ZSwgd3JpdGFibGU6IGZhbHNlIH0sXG4gICAgICB1cmw6IHsgZW51bWVyYWJsZTogdHJ1ZSwgd3JpdGFibGU6IGZhbHNlIH0sXG4gICAgICBkYXRhOiB7IGVudW1lcmFibGU6IGZhbHNlLCB3cml0YWJsZTogZmFsc2UgfSxcbiAgICB9KVxuICB9XG4gIC8qKlxuICAgKiBAcmV0dXJucyB7aW1wb3J0KCcuL2xpYi9pbnRlcmZhY2UuanMnKS5FbmNvZGVkPFQsIFtbQmxvYiwgVVJMXV0+fVxuICAgKi9cbiAgZW1iZWQoKSB7XG4gICAgcmV0dXJuIFRva2VuLmVtYmVkKHRoaXMpXG4gIH1cblxuICAvKipcbiAgICogQHRlbXBsYXRlIHtUb2tlbklucHV0fSBUXG4gICAqIEBwYXJhbSB7e2RhdGE6IGltcG9ydCgnLi9saWIvaW50ZXJmYWNlLmpzJykuRW5jb2RlZDxULCBbW0Jsb2IsIFVSTF1dPn19IHRva2VuXG4gICAqIEByZXR1cm5zIHtpbXBvcnQoJy4vbGliL2ludGVyZmFjZS5qcycpLkVuY29kZWQ8VCwgW1tCbG9iLCBVUkxdXT59XG4gICAqL1xuICBzdGF0aWMgZW1iZWQoeyBkYXRhIH0pIHtcbiAgICByZXR1cm4gZW1iZWQoZGF0YSwgeyBnYXRld2F5OiBHQVRFV0FZIH0pXG4gIH1cblxuICAvKipcbiAgICogVGFrZXMgdG9rZW4gaW5wdXQsIGVuY29kZXMgaXQgYXMgYSBEQUcsIHdyYXBzIGl0IGluIGEgQ0FSIGFuZCBjcmVhdGVzIGEgbmV3XG4gICAqIFRva2VuIGluc3RhbmNlIGZyb20gaXQuIFdoZXJlIHZhbHVlcyBhcmUgZGlzY292ZXJlZCBgQmxvYmAgKG9yIGBGaWxlYClcbiAgICogb2JqZWN0cyBpbiB0aGUgZ2l2ZW4gaW5wdXQsIHRoZXkgYXJlIHJlcGxhY2VkIHdpdGggSVBGUyBVUkxzIChhbiBgaXBmczovL2BcbiAgICogcHJlZml4ZWQgQ0lEIHdpdGggYW4gb3B0aW9uYWwgcGF0aCkuXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIGBgYGpzXG4gICAqIGNvbnN0IGNhdCA9IG5ldyBGaWxlKFsnLi4uJ10sICdjYXQucG5nJylcbiAgICogY29uc3Qga2l0dHkgPSBuZXcgRmlsZShbJy4uLiddLCAna2l0dHkucG5nJylcbiAgICogY29uc3QgeyB0b2tlbiwgY2FyIH0gPSBhd2FpdCBUb2tlbi5lbmNvZGUoe1xuICAgKiAgIG5hbWU6ICdoZWxsbydcbiAgICogICBpbWFnZTogY2F0XG4gICAqICAgcHJvcGVydGllczoge1xuICAgKiAgICAgZXh0cmE6IHtcbiAgICogICAgICAgaW1hZ2U6IGtpdHR5XG4gICAqICAgICB9XG4gICAqICAgfVxuICAgKiB9KVxuICAgKiBgYGBcbiAgICpcbiAgICogQHRlbXBsYXRlIHtUb2tlbklucHV0fSBUXG4gICAqIEBwYXJhbSB7VH0gaW5wdXRcbiAgICogQHJldHVybnMge1Byb21pc2U8eyBjaWQ6IENJRCwgdG9rZW46IFRva2VuVHlwZTxUPiwgY2FyOiBpbXBvcnQoJy4vbGliL2ludGVyZmFjZS5qcycpLkNhclJlYWRlciB9Pn1cbiAgICovXG4gIHN0YXRpYyBhc3luYyBlbmNvZGUoaW5wdXQpIHtcbiAgICBjb25zdCBibG9ja3N0b3JlID0gbmV3IEJsb2Nrc3RvcmUoKVxuICAgIGNvbnN0IFtibG9icywgbWV0YV0gPSBtYXBUb2tlbklucHV0QmxvYnMoaW5wdXQpXG4gICAgLyoqIEB0eXBlIHtFbmNvZGVkQmxvYlVybDxUPn0gKi9cbiAgICBjb25zdCBkYXRhID0gSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeShtZXRhKSlcbiAgICAvKiogQHR5cGUge2ltcG9ydCgnLi9saWIvaW50ZXJmYWNlLmpzJykuRW5jb2RlZDxULCBbW0Jsb2IsIENJRF1dPn0gKi9cbiAgICBjb25zdCBkYWcgPSBKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KG1ldGEpKVxuXG4gICAgZm9yIChjb25zdCBbZG90UGF0aCwgYmxvYl0gb2YgYmxvYnMuZW50cmllcygpKSB7XG4gICAgICAvKiogQHR5cGUge3N0cmluZ3x1bmRlZmluZWR9ICovXG4gICAgICAvLyBAdHMtaWdub3JlIGJsb2IgbWF5IGJlIGEgRmlsZSFcbiAgICAgIGNvbnN0IG5hbWUgPSBibG9iLm5hbWUgfHwgJ2Jsb2InXG4gICAgICAvKiogQHR5cGUge2ltcG9ydCgnLi9wbGF0Zm9ybS5qcycpLlJlYWRhYmxlU3RyZWFtfSAqL1xuICAgICAgbGV0IGNvbnRlbnRcbiAgICAgIC8vIEZJWE1FOiBzaG91bGQgbm90IGJlIG5lY2Vzc2FyeSB0byBhd2FpdCBhcnJheUJ1ZmZlcigpIVxuICAgICAgLy8gTm9kZS5qcyAyMCBoYW5ncyByZWFkaW5nIHRoZSBzdHJlYW0gKGl0IG5ldmVyIGVuZHMpIGJ1dCBpblxuICAgICAgLy8gb2xkZXIgbm9kZSB2ZXJzaW9ucyBhbmQgdGhlIGJyb3dzZXIgaXQgaXMgZmluZSB0byB1c2UgYmxvYi5zdHJlYW0oKS5cbiAgICAgIC8qIGM4IGlnbm9yZSBuZXh0IDUgKi9cbiAgICAgIGlmIChwYXJzZUludChnbG9iYWxUaGlzLnByb2Nlc3M/LnZlcnNpb25zPy5ub2RlKSA+IDE4KSB7XG4gICAgICAgIGNvbnRlbnQgPSBuZXcgVWludDhBcnJheShhd2FpdCBibG9iLmFycmF5QnVmZmVyKCkpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb250ZW50ID0gYmxvYi5zdHJlYW0oKVxuICAgICAgfVxuICAgICAgY29uc3QgeyByb290OiBjaWQgfSA9IGF3YWl0IHBhY2soe1xuICAgICAgICBpbnB1dDogW3sgcGF0aDogbmFtZSwgY29udGVudCB9XSxcbiAgICAgICAgYmxvY2tzdG9yZSxcbiAgICAgICAgd3JhcFdpdGhEaXJlY3Rvcnk6IHRydWUsXG4gICAgICB9KVxuXG4gICAgICBjb25zdCBocmVmID0gbmV3IFVSTChgaXBmczovLyR7Y2lkfS8ke25hbWV9YClcbiAgICAgIGNvbnN0IHBhdGggPSBkb3RQYXRoLnNwbGl0KCcuJylcbiAgICAgIHNldEluKGRhdGEsIHBhdGgsIGhyZWYpXG4gICAgICBzZXRJbihkYWcsIHBhdGgsIGNpZClcbiAgICB9XG5cbiAgICBjb25zdCB7IHJvb3Q6IG1ldGFkYXRhSnNvbkNpZCB9ID0gYXdhaXQgcGFjayh7XG4gICAgICBpbnB1dDogW3sgcGF0aDogJ21ldGFkYXRhLmpzb24nLCBjb250ZW50OiBKU09OLnN0cmluZ2lmeShkYXRhKSB9XSxcbiAgICAgIGJsb2Nrc3RvcmUsXG4gICAgICB3cmFwV2l0aERpcmVjdG9yeTogZmFsc2UsXG4gICAgfSlcblxuICAgIGNvbnN0IGJsb2NrID0gYXdhaXQgQmxvY2suZW5jb2RlKHtcbiAgICAgIHZhbHVlOiB7XG4gICAgICAgIC4uLmRhZyxcbiAgICAgICAgJ21ldGFkYXRhLmpzb24nOiBtZXRhZGF0YUpzb25DaWQsXG4gICAgICAgIHR5cGU6ICduZnQnLFxuICAgICAgfSxcbiAgICAgIGNvZGVjOiBkYWdDYm9yLFxuICAgICAgaGFzaGVyOiBzaGEyNTYsXG4gICAgfSlcbiAgICBhd2FpdCBibG9ja3N0b3JlLnB1dChibG9jay5jaWQsIGJsb2NrLmJ5dGVzKVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIGNpZDogYmxvY2suY2lkLFxuICAgICAgdG9rZW46IG5ldyBUb2tlbihcbiAgICAgICAgYmxvY2suY2lkLnRvU3RyaW5nKCksXG4gICAgICAgIGBpcGZzOi8vJHtibG9jay5jaWR9L21ldGFkYXRhLmpzb25gLFxuICAgICAgICBkYXRhXG4gICAgICApLFxuICAgICAgY2FyOiBuZXcgQmxvY2tzdG9yZUNhclJlYWRlcigxLCBbYmxvY2suY2lkXSwgYmxvY2tzdG9yZSksXG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogQHRlbXBsYXRlIFRcbiAqIEBwYXJhbSB7RW5jb2RlZEJsb2JVcmw8VD59IGlucHV0XG4gKiBAcGFyYW0ge0VtYmVkT3B0aW9uc30gb3B0aW9uc1xuICogQHJldHVybnMge0VuY29kZWRCbG9iVXJsPFQ+fVxuICovXG5leHBvcnQgY29uc3QgZW1iZWQgPSAoaW5wdXQsIG9wdGlvbnMpID0+XG4gIG1hcFdpdGgoaW5wdXQsIGlzVVJMLCBlbWJlZFVSTCwgb3B0aW9ucylcblxuLyoqXG4gKiBAdGVtcGxhdGUge1Rva2VuSW5wdXR9IFRcbiAqIEBwYXJhbSB7aW1wb3J0KCcuL2xpYi9pbnRlcmZhY2UuanMnKS5FbmNvZGVkVG9rZW48VD59IHZhbHVlXG4gKiBAcGFyYW0ge1NldDxzdHJpbmc+fSBwYXRocyAtIFBhdGhzIHdlcmUgdG8gZXhwZWN0IEVuY29kZWRVUkxzXG4gKiBAcmV0dXJucyB7VG9rZW48VD59XG4gKi9cbmV4cG9ydCBjb25zdCBkZWNvZGUgPSAoeyBpcG5mdCwgdXJsLCBkYXRhIH0sIHBhdGhzKSA9PlxuICBuZXcgVG9rZW4oaXBuZnQsIHVybCwgbWFwV2l0aChkYXRhLCBpc0VuY29kZWRVUkwsIGRlY29kZVVSTCwgcGF0aHMpKVxuXG4vKipcbiAqIEBwYXJhbSB7YW55fSB2YWx1ZVxuICogQHJldHVybnMge3ZhbHVlIGlzIFVSTH1cbiAqL1xuY29uc3QgaXNVUkwgPSAodmFsdWUpID0+IHZhbHVlIGluc3RhbmNlb2YgVVJMXG5cbi8qKlxuICogQHRlbXBsYXRlIFN0YXRlXG4gKiBAcGFyYW0ge1N0YXRlfSBzdGF0ZVxuICogQHBhcmFtIHtpbXBvcnQoJy4vbGliL2ludGVyZmFjZS5qcycpLkVuY29kZWRVUkx9IHVybFxuICogQHJldHVybnMge1tTdGF0ZSwgVVJMXX1cbiAqL1xuY29uc3QgZGVjb2RlVVJMID0gKHN0YXRlLCB1cmwpID0+IFtzdGF0ZSwgbmV3IFVSTCh1cmwpXVxuXG4vKipcbiAqIEBwYXJhbSB7RW1iZWRPcHRpb25zfSBjb250ZXh0XG4gKiBAcGFyYW0ge1VSTH0gdXJsXG4gKiBAcmV0dXJucyB7W0VtYmVkT3B0aW9ucywgVVJMXX1cbiAqL1xuY29uc3QgZW1iZWRVUkwgPSAoY29udGV4dCwgdXJsKSA9PiBbY29udGV4dCwgdG9HYXRld2F5VVJMKHVybCwgY29udGV4dCldXG5cbi8qKlxuICogQHBhcmFtIHthbnl9IHZhbHVlXG4gKiBAcmV0dXJucyB7dmFsdWUgaXMgb2JqZWN0fVxuICovXG5jb25zdCBpc09iamVjdCA9ICh2YWx1ZSkgPT4gdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyAmJiB2YWx1ZSAhPSBudWxsXG5cbi8qKlxuICogQHBhcmFtIHthbnl9IHZhbHVlXG4gKiBAcGFyYW0ge1NldDxzdHJpbmc+fSBhc3NldFBhdGhzXG4gKiBAcGFyYW0ge1Byb3BlcnR5S2V5W119IHBhdGhcbiAqIEByZXR1cm5zIHt2YWx1ZSBpcyBpbXBvcnQoJy4vbGliL2ludGVyZmFjZS5qcycpLkVuY29kZWRVUkx9XG4gKi9cbmNvbnN0IGlzRW5jb2RlZFVSTCA9ICh2YWx1ZSwgYXNzZXRQYXRocywgcGF0aCkgPT5cbiAgdHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJyAmJiBhc3NldFBhdGhzLmhhcyhwYXRoLmpvaW4oJy4nKSlcblxuLyoqXG4gKiBUYWtlcyB0b2tlbiBpbnB1dCBhbmQgZW5jb2RlcyBpdCBpbnRvXG4gKiBbRm9ybURhdGFdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9Gb3JtRGF0YSlcbiAqIG9iamVjdCB3aGVyZSBmb3JtIGZpZWxkIHZhbHVlcyBhcmUgZGlzY292ZXJlZCBgQmxvYmAgKG9yIGBGaWxlYCkgb2JqZWN0cyBpblxuICogdGhlIGdpdmVuIHRva2VuIGFuZCBmaWVsZCBrZXlzIGFyZSBgLmAgam9pbmVkIHBhdGhzIHdoZXJlIHRoZXkgd2VyZSBkaXNjb3ZlcmRcbiAqIGluIHRoZSB0b2tlbi4gQWRkaXRpb25hbGx5IGVuY29kZWQgYEZvcm1EYXRhYCB3aWxsIGFsc28gaGF2ZSBhIGZpZWxkXG4gKiBuYW1lZCBgbWV0YWAgY29udGFpbmluZyBKU09OIHNlcmlhbGl6ZWQgdG9rZW4gd2l0aCBibG9icyBhbmQgZmlsZSB2YWx1ZXNcbiAqIGBudWxsYCBzZXQgdG8gbnVsbCAodGhpcyBhbGxvd3MgYmFja2VuZCB0byBpbmplc3QgYWxsIG9mIHRoZSBmaWxlcyBmcm9tXG4gKiBgbXVsdGlwYXJ0L2Zvcm0tZGF0YWAgcmVxdWVzdCBhbmQgdXBkYXRlIHByb3ZpZGVkIFwibWV0YVwiIGRhdGEgd2l0aFxuICogY29ycmVzcG9uZGluZyBmaWxlIGlwZnM6Ly8gVVJMcylcbiAqXG4gKiBAZXhhbXBsZVxuICogYGBganNcbiAqIGNvbnN0IGNhdCA9IG5ldyBGaWxlKFtdLCAnY2F0LnBuZycpXG4gKiBjb25zdCBraXR0eSA9IG5ldyBGaWxlKFtdLCAna2l0dHkucG5nJylcbiAqIGNvbnN0IGZvcm0gPSBlbmNvZGUoe1xuICogICBuYW1lOiAnaGVsbG8nXG4gKiAgIGltYWdlOiBjYXRcbiAqICAgcHJvcGVydGllczoge1xuICogICAgIGV4dHJhOiB7XG4gKiAgICAgICBpbWFnZToga2l0dHlcbiAqICAgICB9XG4gKiAgIH1cbiAqIH0pXG4gKiBbLi4uZm9ybS5lbnRyaWVzKCldIC8vPlxuICogLy8gW1xuICogLy8gICBbJ2ltYWdlJywgY2F0XSxcbiAqIC8vICAgWydwcm9wZXJ0aWVzLmV4dHJhLmltYWdlJywga2l0dHldLFxuICogLy8gICBbJ21ldGEnLCAne1wibmFtZVwiOlwiaGVsbG9cIixpbWFnZTpudWxsLFwicHJvcGVydGllc1wiOntcImV4dHJhXCI6e1wia2l0dHlcIjogbnVsbH19fSddXG4gKiAvLyBdXG4gKiBgYGBcbiAqXG4gKiBAdGVtcGxhdGUge1Rva2VuSW5wdXR9IFRcbiAqIEBwYXJhbSB7RW5jb2RlZEJsb2JCbG9iPFQ+fSBpbnB1dFxuICogQHJldHVybnMge0Zvcm1EYXRhfVxuICovXG5leHBvcnQgY29uc3QgZW5jb2RlID0gKGlucHV0KSA9PiB7XG4gIGNvbnN0IFttYXAsIG1ldGFdID0gbWFwVmFsdWVXaXRoKGlucHV0LCBpc0Jsb2IsIGVuY29kZUJsb2IsIG5ldyBNYXAoKSwgW10pXG4gIGNvbnN0IGZvcm0gPSBuZXcgRm9ybURhdGEoKVxuICBmb3IgKGNvbnN0IFtrLCB2XSBvZiBtYXAuZW50cmllcygpKSB7XG4gICAgZm9ybS5zZXQoaywgdilcbiAgfVxuICBmb3JtLnNldCgnbWV0YScsIEpTT04uc3RyaW5naWZ5KG1ldGEpKVxuICByZXR1cm4gZm9ybVxufVxuXG4vKipcbiAqIEBwYXJhbSB7TWFwPHN0cmluZywgQmxvYj59IGRhdGFcbiAqIEBwYXJhbSB7QmxvYn0gYmxvYlxuICogQHBhcmFtIHtQcm9wZXJ0eUtleVtdfSBwYXRoXG4gKiBAcmV0dXJucyB7W01hcDxzdHJpbmcsIEJsb2I+LCB2b2lkXX1cbiAqL1xuY29uc3QgZW5jb2RlQmxvYiA9IChkYXRhLCBibG9iLCBwYXRoKSA9PiB7XG4gIGRhdGEuc2V0KHBhdGguam9pbignLicpLCBibG9iKVxuICByZXR1cm4gW2RhdGEsIHVuZGVmaW5lZF1cbn1cblxuLyoqXG4gKiBAcGFyYW0ge2FueX0gdmFsdWVcbiAqIEByZXR1cm5zIHt2YWx1ZSBpcyBCbG9ifVxuICovXG5jb25zdCBpc0Jsb2IgPSAodmFsdWUpID0+IHZhbHVlIGluc3RhbmNlb2YgQmxvYlxuXG4vKipcbiAqIEB0ZW1wbGF0ZSB7VG9rZW5JbnB1dH0gVFxuICogQHBhcmFtIHtFbmNvZGVkQmxvYkJsb2I8VD59IGlucHV0XG4gKi9cbmNvbnN0IG1hcFRva2VuSW5wdXRCbG9icyA9IChpbnB1dCkgPT4ge1xuICByZXR1cm4gbWFwVmFsdWVXaXRoKGlucHV0LCBpc0Jsb2IsIGVuY29kZUJsb2IsIG5ldyBNYXAoKSwgW10pXG59XG5cbi8qKlxuICogU3Vic3RpdHVlcyB2YWx1ZXMgaW4gdGhlIGdpdmVuIGBpbnB1dGAgdGhhdCBtYXRjaCBgcCh2YWx1ZSkgPT0gdHJ1ZWAgd2l0aFxuICogYGYodmFsdWUsIGNvbnRleHQsIHBhdGgpYCB3aGVyZSBgY29udGV4dGAgaXMgd2hhdGV2ZXIgeW91IHBhc3MgKHVzdWFsbHlcbiAqIGEgbXV0YWJsZSBzdGF0ZSkgYW5kIGBwYXRoYCBpcyBhIGFycmF5IG9mIGtleXMgLyBpbmRleGVzIHdoZXJlIHRoZSB2YWx1ZVxuICogd2FzIGVuY291bnRlcmVkLlxuICpcbiAqIEB0ZW1wbGF0ZSBULCBJLCBYLCBPLCBTdGF0ZVxuICogQHBhcmFtIHtpbXBvcnQoJy4vbGliL2ludGVyZmFjZS5qcycpLkVuY29kZWQ8VCwgW1tJLCBYXV0+fSBpbnB1dCAtIEFyYml0cmFyeSBpbnB1dC5cbiAqIEBwYXJhbSB7KGlucHV0OmFueSwgc3RhdGU6U3RhdGUsIHBhdGg6UHJvcGVydHlLZXlbXSkgPT4gaW5wdXQgaXMgWH0gcCAtIFByZWRpY2F0ZSBmdW5jdGlvbiB0byBkZXRlcm1pbmVcbiAqIHdoaWNoIHZhbHVlcyB0byBzd2FwLlxuICogQHBhcmFtIHsoc3RhdGU6U3RhdGUsIGlucHV0OlgsIHBhdGg6UHJvcGVydHlLZXlbXSkgPT4gW1N0YXRlLCBPXX0gZiAtIEZ1bmN0aW9uXG4gKiB0aGF0IHN3YXBzIG1hdGNoaW5nIHZhbHVlcy5cbiAqIEBwYXJhbSB7U3RhdGV9IHN0YXRlIC0gU29tZSBhZGRpdGlvbmFsIGNvbnRleHQgeW91IG5lZWQgaW4gdGhlIHByb2Nlc3MuXG4gKiBsaWtleSB5b3UnbGwgc3RhcnQgd2l0aCBgW11gLlxuICogQHJldHVybnMge2ltcG9ydCgnLi9saWIvaW50ZXJmYWNlLmpzJykuRW5jb2RlZDxULCBbW0ksIE9dXT59XG4gKi9cbmV4cG9ydCBjb25zdCBtYXBXaXRoID0gKGlucHV0LCBwLCBmLCBzdGF0ZSkgPT4ge1xuICBjb25zdCBbLCBvdXRwdXRdID0gbWFwVmFsdWVXaXRoKGlucHV0LCBwLCBmLCBzdGF0ZSwgW10pXG4gIHJldHVybiBvdXRwdXRcbn1cblxuLyoqXG4gKiBAdGVtcGxhdGUgVCwgSSwgWCwgTywgU3RhdGVcbiAqIEBwYXJhbSB7aW1wb3J0KCcuL2xpYi9pbnRlcmZhY2UuanMnKS5FbmNvZGVkPFQsIFtbSSwgWF1dPn0gaW5wdXQgLSBBcmJpdHJhcnkgaW5wdXQuXG4gKiBAcGFyYW0geyhpbnB1dDphbnksIHN0YXRlOlN0YXRlLCBwYXRoOlByb3BlcnR5S2V5W10pID0+IGlucHV0IGlzIFh9IHAgLSBQcmVkaWNhdGUgZnVuY3Rpb24gdG8gZGV0ZXJtaW5lXG4gKiB3aGljaCB2YWx1ZXMgdG8gc3dhcC5cbiAqIEBwYXJhbSB7KHN0YXRlOlN0YXRlLCBpbnB1dDpYLCBwYXRoOlByb3BlcnR5S2V5W10pID0+IFtTdGF0ZSwgT119IGYgLSBGdW5jdGlvblxuICogdGhhdCBzd2FwcyBtYXRjaGluZyB2YWx1ZXMuXG4gKiBAcGFyYW0ge1N0YXRlfSBzdGF0ZSAtIFNvbWUgYWRkaXRpb25hbCBjb250ZXh0IHlvdSBuZWVkIGluIHRoZSBwcm9jZXNzLlxuICogQHBhcmFtIHtQcm9wZXJ0eUtleVtdfSBwYXRoIC0gUGF0aCB3aGVyZSB0aGUgdmFsdWUgd2FzIGVuY291bnRlcmVkLiBNb3N0XG4gKiBsaWtleSB5b3UnbGwgc3RhcnQgd2l0aCBgW11gLlxuICogQHJldHVybnMge1tTdGF0ZSwgaW1wb3J0KCcuL2xpYi9pbnRlcmZhY2UuanMnKS5FbmNvZGVkPFQsIFtbSSwgT11dPl19XG4gKi9cbmNvbnN0IG1hcFZhbHVlV2l0aCA9IChpbnB1dCwgcCwgZiwgc3RhdGUsIHBhdGgpID0+XG4gIHAoaW5wdXQsIHN0YXRlLCBwYXRoKVxuICAgID8gZihzdGF0ZSwgaW5wdXQsIHBhdGgpXG4gICAgOiBBcnJheS5pc0FycmF5KGlucHV0KVxuICAgID8gbWFwQXJyYXlXaXRoKGlucHV0LCBwLCBmLCBzdGF0ZSwgcGF0aClcbiAgICA6IGlzT2JqZWN0KGlucHV0KVxuICAgID8gbWFwT2JqZWN0V2l0aChpbnB1dCwgcCwgZiwgc3RhdGUsIHBhdGgpXG4gICAgOiBbc3RhdGUsIC8qKiBAdHlwZSB7YW55fSAqLyAoaW5wdXQpXVxuXG4vKipcbiAqIEp1c3QgbGlrZSBgbWFwV2l0aGAgZXhjZXB0XG4gKlxuICogQHRlbXBsYXRlIFN0YXRlLCBULCBJLCBYLCBPXG4gKiBAcGFyYW0ge2ltcG9ydCgnLi9saWIvaW50ZXJmYWNlLmpzJykuRW5jb2RlZDxULCBbW0ksIFhdXT59IGlucHV0XG4gKiBAcGFyYW0geyhpbnB1dDphbnksIHN0YXRlOlN0YXRlLCBwYXRoOlByb3BlcnR5S2V5W10pID0+IGlucHV0IGlzIFh9IHBcbiAqIEBwYXJhbSB7KHN0YXRlOiBTdGF0ZSwgaW5wdXQ6WCwgcGF0aDpQcm9wZXJ0eUtleVtdKSA9PiBbU3RhdGUsIE9dfSBmXG4gKiBAcGFyYW0ge1N0YXRlfSBpbml0XG4gKiBAcGFyYW0ge1Byb3BlcnR5S2V5W119IHBhdGhcbiAqIEByZXR1cm5zIHtbU3RhdGUsIGltcG9ydCgnLi9saWIvaW50ZXJmYWNlLmpzJykuRW5jb2RlZDxULCBbW0ksIE9dXT5dfVxuICovXG5jb25zdCBtYXBPYmplY3RXaXRoID0gKGlucHV0LCBwLCBmLCBpbml0LCBwYXRoKSA9PiB7XG4gIGxldCBzdGF0ZSA9IGluaXRcbiAgY29uc3Qgb3V0cHV0ID1cbiAgICAvKiogQHR5cGUge2ltcG9ydCgnLi9saWIvaW50ZXJmYWNlLmpzJykuRW5jb2RlZDxULCBbW0ksIE9dXT59ICovICh7fSlcbiAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2YgT2JqZWN0LmVudHJpZXMoaW5wdXQpKSB7XG4gICAgY29uc3QgW25leHQsIG91dF0gPSBtYXBWYWx1ZVdpdGgodmFsdWUsIHAsIGYsIHN0YXRlLCBbLi4ucGF0aCwga2V5XSlcbiAgICAvLyBAdHMtaWdub3JlXG4gICAgb3V0cHV0W2tleV0gPSBvdXRcbiAgICBzdGF0ZSA9IG5leHRcbiAgfVxuICByZXR1cm4gW3N0YXRlLCBvdXRwdXRdXG59XG5cbi8qKlxuICogSnVzdCBsaWtlIGBtYXBXaXRoYCBleGNlcHQgZm9yIEFycmF5cy5cbiAqXG4gKiBAdGVtcGxhdGUgSSwgWCwgTywgU3RhdGVcbiAqIEB0ZW1wbGF0ZSB7YW55W119IFRcbiAqIEBwYXJhbSB7VH0gaW5wdXRcbiAqIEBwYXJhbSB7KGlucHV0OmFueSwgc3RhdGU6U3RhdGUsIHBhdGg6UHJvcGVydHlLZXlbXSkgPT4gaW5wdXQgaXMgWH0gcFxuICogQHBhcmFtIHsoc3RhdGU6IFN0YXRlLCBpbnB1dDpYLCBwYXRoOlByb3BlcnR5S2V5W10pID0+IFtTdGF0ZSwgT119IGZcbiAqIEBwYXJhbSB7U3RhdGV9IGluaXRcbiAqIEBwYXJhbSB7UHJvcGVydHlLZXlbXX0gcGF0aFxuICogQHJldHVybnMge1tTdGF0ZSwgaW1wb3J0KCcuL2xpYi9pbnRlcmZhY2UuanMnKS5FbmNvZGVkPFQsIFtbSSwgT11dPl19XG4gKi9cbmNvbnN0IG1hcEFycmF5V2l0aCA9IChpbnB1dCwgcCwgZiwgaW5pdCwgcGF0aCkgPT4ge1xuICBjb25zdCBvdXRwdXQgPSAvKiogQHR5cGUge3Vua25vd25bXX0gKi8gKFtdKVxuXG4gIGxldCBzdGF0ZSA9IGluaXRcbiAgZm9yIChjb25zdCBbaW5kZXgsIGVsZW1lbnRdIG9mIGlucHV0LmVudHJpZXMoKSkge1xuICAgIGNvbnN0IFtuZXh0LCBvdXRdID0gbWFwVmFsdWVXaXRoKGVsZW1lbnQsIHAsIGYsIHN0YXRlLCBbLi4ucGF0aCwgaW5kZXhdKVxuICAgIG91dHB1dFtpbmRleF0gPSBvdXRcbiAgICBzdGF0ZSA9IG5leHRcbiAgfVxuXG4gIHJldHVybiBbXG4gICAgc3RhdGUsXG4gICAgLyoqIEB0eXBlIHtpbXBvcnQoJy4vbGliL2ludGVyZmFjZS5qcycpLkVuY29kZWQ8VCwgW1tJLCBPXV0+fSAqLyAob3V0cHV0KSxcbiAgXVxufVxuXG4vKipcbiAqIFNldHMgYSBnaXZlbiBgdmFsdWVgIGF0IHRoZSBnaXZlbiBgcGF0aGAgb24gYSBwYXNzZWQgYG9iamVjdGAuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYGpzXG4gKiBjb25zdCBvYmogPSB7IGE6IHsgYjogeyBjOiAxIH19fVxuICogc2V0SW4ob2JqLCBbJ2EnLCAnYicsICdjJ10sIDUpXG4gKiBvYmouYS5iLmMgLy8+IDVcbiAqIGBgYFxuICpcbiAqIEB0ZW1wbGF0ZSBWXG4gKiBAcGFyYW0ge2FueX0gb2JqZWN0XG4gKiBAcGFyYW0ge3N0cmluZ1tdfSBwYXRoXG4gKiBAcGFyYW0ge1Z9IHZhbHVlXG4gKi9cbmNvbnN0IHNldEluID0gKG9iamVjdCwgcGF0aCwgdmFsdWUpID0+IHtcbiAgY29uc3QgbiA9IHBhdGgubGVuZ3RoIC0gMVxuICBsZXQgdGFyZ2V0ID0gb2JqZWN0XG4gIGZvciAobGV0IFtpbmRleCwga2V5XSBvZiBwYXRoLmVudHJpZXMoKSkge1xuICAgIGlmIChpbmRleCA9PT0gbikge1xuICAgICAgdGFyZ2V0W2tleV0gPSB2YWx1ZVxuICAgIH0gZWxzZSB7XG4gICAgICB0YXJnZXQgPSB0YXJnZXRba2V5XVxuICAgIH1cbiAgfVxufVxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/nft.storage/src/token.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/nft.storage/src/bs-car-reader.js":
/*!*******************************************************!*\
  !*** ./node_modules/nft.storage/src/bs-car-reader.js ***!
  \*******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   BlockstoreCarReader: () => (/* binding */ BlockstoreCarReader)\n/* harmony export */ });\n/**\n * An implementation of the CAR reader interface that is backed by a blockstore.\n *\n * @typedef {import('multiformats').CID} CID\n * @typedef {import('@ipld/car/api').CarReader} CarReader\n * @implements {CarReader}\n */\nclass BlockstoreCarReader {\n  /**\n   * @param {number} version\n   * @param {CID[]} roots\n   * @param {import('ipfs-car/blockstore').Blockstore} blockstore\n   */\n  constructor(version, roots, blockstore) {\n    /**\n     * @private\n     */\n    this._version = version\n    /**\n     * @private\n     */\n    this._roots = roots\n    /**\n     * @private\n     */\n    this._blockstore = blockstore\n  }\n\n  get version() {\n    return this._version\n  }\n\n  get blockstore() {\n    return this._blockstore\n  }\n\n  async getRoots() {\n    return this._roots\n  }\n\n  /**\n   * @param {CID} cid\n   */\n  has(cid) {\n    return this._blockstore.has(cid)\n  }\n\n  /**\n   * @param {CID} cid\n   */\n  async get(cid) {\n    const bytes = await this._blockstore.get(cid)\n    return { cid, bytes }\n  }\n\n  blocks() {\n    return this._blockstore.blocks()\n  }\n\n  async *cids() {\n    for await (const b of this.blocks()) {\n      yield b.cid\n    }\n  }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbmZ0LnN0b3JhZ2Uvc3JjL2JzLWNhci1yZWFkZXIuanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsNEJBQTRCO0FBQ3pDLGFBQWEsbUNBQW1DO0FBQ2hELGdCQUFnQjtBQUNoQjtBQUNPO0FBQ1A7QUFDQSxhQUFhLFFBQVE7QUFDckIsYUFBYSxPQUFPO0FBQ3BCLGFBQWEsMENBQTBDO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGFBQWEsS0FBSztBQUNsQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGFBQWEsS0FBSztBQUNsQjtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiL2hvbWUvYWx0Y29pbi1kYWRkeS9Eb3dubG9hZHMvb3dubHkvbm9kZV9tb2R1bGVzL25mdC5zdG9yYWdlL3NyYy9icy1jYXItcmVhZGVyLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQW4gaW1wbGVtZW50YXRpb24gb2YgdGhlIENBUiByZWFkZXIgaW50ZXJmYWNlIHRoYXQgaXMgYmFja2VkIGJ5IGEgYmxvY2tzdG9yZS5cbiAqXG4gKiBAdHlwZWRlZiB7aW1wb3J0KCdtdWx0aWZvcm1hdHMnKS5DSUR9IENJRFxuICogQHR5cGVkZWYge2ltcG9ydCgnQGlwbGQvY2FyL2FwaScpLkNhclJlYWRlcn0gQ2FyUmVhZGVyXG4gKiBAaW1wbGVtZW50cyB7Q2FyUmVhZGVyfVxuICovXG5leHBvcnQgY2xhc3MgQmxvY2tzdG9yZUNhclJlYWRlciB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge251bWJlcn0gdmVyc2lvblxuICAgKiBAcGFyYW0ge0NJRFtdfSByb290c1xuICAgKiBAcGFyYW0ge2ltcG9ydCgnaXBmcy1jYXIvYmxvY2tzdG9yZScpLkJsb2Nrc3RvcmV9IGJsb2Nrc3RvcmVcbiAgICovXG4gIGNvbnN0cnVjdG9yKHZlcnNpb24sIHJvb3RzLCBibG9ja3N0b3JlKSB7XG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLl92ZXJzaW9uID0gdmVyc2lvblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5fcm9vdHMgPSByb290c1xuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5fYmxvY2tzdG9yZSA9IGJsb2Nrc3RvcmVcbiAgfVxuXG4gIGdldCB2ZXJzaW9uKCkge1xuICAgIHJldHVybiB0aGlzLl92ZXJzaW9uXG4gIH1cblxuICBnZXQgYmxvY2tzdG9yZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fYmxvY2tzdG9yZVxuICB9XG5cbiAgYXN5bmMgZ2V0Um9vdHMoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3Jvb3RzXG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtDSUR9IGNpZFxuICAgKi9cbiAgaGFzKGNpZCkge1xuICAgIHJldHVybiB0aGlzLl9ibG9ja3N0b3JlLmhhcyhjaWQpXG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtDSUR9IGNpZFxuICAgKi9cbiAgYXN5bmMgZ2V0KGNpZCkge1xuICAgIGNvbnN0IGJ5dGVzID0gYXdhaXQgdGhpcy5fYmxvY2tzdG9yZS5nZXQoY2lkKVxuICAgIHJldHVybiB7IGNpZCwgYnl0ZXMgfVxuICB9XG5cbiAgYmxvY2tzKCkge1xuICAgIHJldHVybiB0aGlzLl9ibG9ja3N0b3JlLmJsb2NrcygpXG4gIH1cblxuICBhc3luYyAqY2lkcygpIHtcbiAgICBmb3IgYXdhaXQgKGNvbnN0IGIgb2YgdGhpcy5ibG9ja3MoKSkge1xuICAgICAgeWllbGQgYi5jaWRcbiAgICB9XG4gIH1cbn1cbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/nft.storage/src/bs-car-reader.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/nft.storage/src/gateway.js":
/*!*************************************************!*\
  !*** ./node_modules/nft.storage/src/gateway.js ***!
  \*************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   GATEWAY: () => (/* binding */ GATEWAY),\n/* harmony export */   toGatewayURL: () => (/* binding */ toGatewayURL)\n/* harmony export */ });\nconst GATEWAY = new URL('https://nftstorage.link/')\n\n/**\n * @typedef {string|URL} GatewayURL Base URL of an IPFS Gateway e.g. https://dweb.link/ or https://ipfs.io/\n * @typedef {{ gateway?: GatewayURL }} GatewayURLOptions\n */\n\n/**\n * Convert an IPFS URL (starting ipfs://) to a gateway URL (starting https://)\n * that can be used in a webpage. If the passed URL is not an IPFS URL it is\n * returned as a new URL object with no further changes.\n *\n * @param {string|URL} url An IPFS URL e.g. ipfs://bafy.../path\n * @param {GatewayURLOptions} [options] Options that allow customization of the gateway used.\n * @returns {URL} An IPFS gateway URL e.g. https://nftstorage.link/ipfs/bafy.../path\n */\nconst toGatewayURL = (url, options = {}) => {\n  const gateway = options.gateway || GATEWAY\n  url = new URL(String(url))\n  return url.protocol === 'ipfs:'\n    ? new URL(`/ipfs/${url.href.slice('ipfs://'.length)}`, gateway)\n    : url\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbmZ0LnN0b3JhZ2Uvc3JjL2dhdGV3YXkuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBTzs7QUFFUDtBQUNBLGFBQWEsWUFBWTtBQUN6QixlQUFlLHdCQUF3QjtBQUN2Qzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxZQUFZO0FBQ3ZCLFdBQVcsbUJBQW1CO0FBQzlCLGFBQWEsS0FBSztBQUNsQjtBQUNPLHVDQUF1QztBQUM5QztBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsaUNBQWlDO0FBQ3hEO0FBQ0EiLCJzb3VyY2VzIjpbIi9ob21lL2FsdGNvaW4tZGFkZHkvRG93bmxvYWRzL293bmx5L25vZGVfbW9kdWxlcy9uZnQuc3RvcmFnZS9zcmMvZ2F0ZXdheS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgY29uc3QgR0FURVdBWSA9IG5ldyBVUkwoJ2h0dHBzOi8vbmZ0c3RvcmFnZS5saW5rLycpXG5cbi8qKlxuICogQHR5cGVkZWYge3N0cmluZ3xVUkx9IEdhdGV3YXlVUkwgQmFzZSBVUkwgb2YgYW4gSVBGUyBHYXRld2F5IGUuZy4gaHR0cHM6Ly9kd2ViLmxpbmsvIG9yIGh0dHBzOi8vaXBmcy5pby9cbiAqIEB0eXBlZGVmIHt7IGdhdGV3YXk/OiBHYXRld2F5VVJMIH19IEdhdGV3YXlVUkxPcHRpb25zXG4gKi9cblxuLyoqXG4gKiBDb252ZXJ0IGFuIElQRlMgVVJMIChzdGFydGluZyBpcGZzOi8vKSB0byBhIGdhdGV3YXkgVVJMIChzdGFydGluZyBodHRwczovLylcbiAqIHRoYXQgY2FuIGJlIHVzZWQgaW4gYSB3ZWJwYWdlLiBJZiB0aGUgcGFzc2VkIFVSTCBpcyBub3QgYW4gSVBGUyBVUkwgaXQgaXNcbiAqIHJldHVybmVkIGFzIGEgbmV3IFVSTCBvYmplY3Qgd2l0aCBubyBmdXJ0aGVyIGNoYW5nZXMuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd8VVJMfSB1cmwgQW4gSVBGUyBVUkwgZS5nLiBpcGZzOi8vYmFmeS4uLi9wYXRoXG4gKiBAcGFyYW0ge0dhdGV3YXlVUkxPcHRpb25zfSBbb3B0aW9uc10gT3B0aW9ucyB0aGF0IGFsbG93IGN1c3RvbWl6YXRpb24gb2YgdGhlIGdhdGV3YXkgdXNlZC5cbiAqIEByZXR1cm5zIHtVUkx9IEFuIElQRlMgZ2F0ZXdheSBVUkwgZS5nLiBodHRwczovL25mdHN0b3JhZ2UubGluay9pcGZzL2JhZnkuLi4vcGF0aFxuICovXG5leHBvcnQgY29uc3QgdG9HYXRld2F5VVJMID0gKHVybCwgb3B0aW9ucyA9IHt9KSA9PiB7XG4gIGNvbnN0IGdhdGV3YXkgPSBvcHRpb25zLmdhdGV3YXkgfHwgR0FURVdBWVxuICB1cmwgPSBuZXcgVVJMKFN0cmluZyh1cmwpKVxuICByZXR1cm4gdXJsLnByb3RvY29sID09PSAnaXBmczonXG4gICAgPyBuZXcgVVJMKGAvaXBmcy8ke3VybC5ocmVmLnNsaWNlKCdpcGZzOi8vJy5sZW5ndGgpfWAsIGdhdGV3YXkpXG4gICAgOiB1cmxcbn1cbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/nft.storage/src/gateway.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/nft.storage/src/lib.js":
/*!*********************************************!*\
  !*** ./node_modules/nft.storage/src/lib.js ***!
  \*********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Blob: () => (/* reexport safe */ _platform_js__WEBPACK_IMPORTED_MODULE_7__.Blob),\n/* harmony export */   File: () => (/* reexport safe */ _platform_js__WEBPACK_IMPORTED_MODULE_7__.File),\n/* harmony export */   FormData: () => (/* reexport safe */ _platform_js__WEBPACK_IMPORTED_MODULE_7__.FormData),\n/* harmony export */   NFTStorage: () => (/* binding */ NFTStorage),\n/* harmony export */   Token: () => (/* reexport module object */ _token_js__WEBPACK_IMPORTED_MODULE_6__),\n/* harmony export */   createRateLimiter: () => (/* binding */ createRateLimiter),\n/* harmony export */   toAsyncIterable: () => (/* binding */ toAsyncIterable),\n/* harmony export */   toGatewayURL: () => (/* reexport safe */ _gateway_js__WEBPACK_IMPORTED_MODULE_8__.toGatewayURL)\n/* harmony export */ });\n/* harmony import */ var streaming_iterables__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! streaming-iterables */ \"(ssr)/./node_modules/streaming-iterables/dist/index.mjs\");\n/* harmony import */ var p_retry__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! p-retry */ \"(ssr)/./node_modules/p-retry/index.js\");\n/* harmony import */ var carbites_treewalk__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! carbites/treewalk */ \"(ssr)/./node_modules/carbites/esm/lib/treewalk/index.js\");\n/* harmony import */ var ipfs_car_pack__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ipfs-car/pack */ \"(ssr)/./node_modules/ipfs-car/dist/esm/pack/index.js\");\n/* harmony import */ var multiformats_cid__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! multiformats/cid */ \"(ssr)/./node_modules/multiformats/esm/src/cid.js\");\n/* harmony import */ var throttled_queue__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! throttled-queue */ \"(ssr)/./node_modules/throttled-queue/dist/throttledQueue.js\");\n/* harmony import */ var _token_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./token.js */ \"(ssr)/./node_modules/nft.storage/src/token.js\");\n/* harmony import */ var _platform_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./platform.js */ \"(ssr)/./node_modules/nft.storage/src/platform.js\");\n/* harmony import */ var _gateway_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./gateway.js */ \"(ssr)/./node_modules/nft.storage/src/gateway.js\");\n/* harmony import */ var _bs_car_reader_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./bs-car-reader.js */ \"(ssr)/./node_modules/nft.storage/src/bs-car-reader.js\");\n/* harmony import */ var it_pipe__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! it-pipe */ \"(ssr)/./node_modules/it-pipe/index.js\");\n/**\n * A client library for the https://nft.storage/ service. It provides a convenient\n * interface for working with the [Raw HTTP API](https://nft.storage/#api-docs)\n * from a web browser or [Node.js](https://nodejs.org/) and comes bundled with\n * TS for out-of-the box type inference and better IntelliSense.\n *\n * @example\n * ```js\n * import { NFTStorage, File, Blob } from \"nft.storage\"\n * const client = new NFTStorage({ token: API_TOKEN })\n *\n * const cid = await client.storeBlob(new Blob(['hello world']))\n * ```\n * @module\n */\n\n\n\n\n\n\n\n\n\n\n\n\n\nconst MAX_STORE_RETRIES = 5\nconst MAX_CONCURRENT_UPLOADS = 3\nconst MAX_CHUNK_SIZE = 1024 * 1024 * 50 // chunk to ~50MB CARs\nconst RATE_LIMIT_REQUESTS = 30\nconst RATE_LIMIT_PERIOD = 10 * 1000\n\n/**\n * @typedef {import('./lib/interface.js').Service} Service\n * @typedef {import('./lib/interface.js').CIDString} CIDString\n * @typedef {import('./lib/interface.js').Deal} Deal\n * @typedef {import('./lib/interface.js').FileObject} FileObject\n * @typedef {import('./lib/interface.js').FilesSource} FilesSource\n * @typedef {import('./lib/interface.js').Pin} Pin\n * @typedef {import('./lib/interface.js').CarReader} CarReader\n * @typedef {import('ipfs-car/blockstore').Blockstore} BlockstoreI\n * @typedef {import('./lib/interface.js').RateLimiter} RateLimiter\n * @typedef {import('./lib/interface.js').RequestOptions} RequestOptions\n */\n\n/**\n * @returns {RateLimiter}\n */\nfunction createRateLimiter() {\n  const throttle = throttled_queue__WEBPACK_IMPORTED_MODULE_5__(RATE_LIMIT_REQUESTS, RATE_LIMIT_PERIOD)\n  return () => throttle(() => {})\n}\n\n/**\n * Rate limiter used by static API if no rate limiter is passed. Note that each\n * instance of the NFTStorage class gets it's own limiter if none is passed.\n * This is because rate limits are enforced per API token.\n */\nconst globalRateLimiter = createRateLimiter()\n\n/**\n * @template {import('./lib/interface.js').TokenInput} T\n * @typedef {import('./lib/interface.js').Token<T>} TokenType\n */\n\n/**\n * @implements {Service}\n */\nclass NFTStorage {\n  /**\n   * Constructs a client bound to the given `options.token` and\n   * `options.endpoint`.\n   *\n   * @example\n   * ```js\n   * import { NFTStorage, File, Blob } from \"nft.storage\"\n   * const client = new NFTStorage({ token: API_TOKEN })\n   *\n   * const cid = await client.storeBlob(new Blob(['hello world']))\n   * ```\n   * Optionally you could pass an alternative API endpoint (e.g. for testing)\n   * @example\n   * ```js\n   * import { NFTStorage } from \"nft.storage\"\n   * const client = new NFTStorage({\n   *   token: API_TOKEN\n   *   endpoint: new URL('http://localhost:8080/')\n   * })\n   * ```\n   *\n   * @param {{token: string, endpoint?: URL, rateLimiter?: RateLimiter, did?: string}} options\n   */\n  constructor({\n    token,\n    did,\n    endpoint = new URL('https://api.nft.storage'),\n    rateLimiter,\n  }) {\n    /**\n     * Authorization token.\n     *\n     * @readonly\n     */\n    this.token = token\n    /**\n     * Service API endpoint `URL`.\n     * @readonly\n     */\n    this.endpoint = endpoint\n    /**\n     * @readonly\n     */\n    this.rateLimiter = rateLimiter || createRateLimiter()\n\n    /**\n     * @readonly\n     */\n    this.did = did\n  }\n\n  /**\n   * @hidden\n   * @param {object} options\n   * @param {string} options.token\n   * @param {string} [options.did]\n   */\n  static auth({ token, did }) {\n    if (!token) throw new Error('missing token')\n    return {\n      Authorization: `Bearer ${token}`,\n      'X-Client': 'nft.storage/js',\n      ...(did ? { 'x-agent-did': did } : {}),\n    }\n  }\n\n  /**\n   * Stores a single file and returns its CID.\n   *\n   * @param {Service} service\n   * @param {Blob} blob\n   * @param {RequestOptions} [options]\n   * @returns {Promise<CIDString>}\n   */\n  static async storeBlob(service, blob, options) {\n    const blockstore = new _platform_js__WEBPACK_IMPORTED_MODULE_7__.Blockstore()\n    let cidString\n\n    try {\n      const { cid, car } = await NFTStorage.encodeBlob(blob, { blockstore })\n      await NFTStorage.storeCar(service, car, options)\n      cidString = cid.toString()\n    } finally {\n      await blockstore.close()\n    }\n\n    return cidString\n  }\n\n  /**\n   * Stores a CAR file and returns its root CID.\n   *\n   * @param {Service} service\n   * @param {Blob|CarReader} car\n   * @param {import('./lib/interface.js').CarStorerOptions} [options]\n   * @returns {Promise<CIDString>}\n   */\n  static async storeCar(\n    { endpoint, rateLimiter = globalRateLimiter, ...token },\n    car,\n    { onStoredChunk, maxRetries, maxChunkSize, decoders, signal } = {}\n  ) {\n    const url = new URL('upload/', endpoint)\n    const headers = {\n      ...NFTStorage.auth(token),\n      'Content-Type': 'application/car',\n    }\n    const targetSize = maxChunkSize || MAX_CHUNK_SIZE\n    const splitter =\n      car instanceof _platform_js__WEBPACK_IMPORTED_MODULE_7__.Blob\n        ? await carbites_treewalk__WEBPACK_IMPORTED_MODULE_2__.TreewalkCarSplitter.fromBlob(car, targetSize, { decoders })\n        : new carbites_treewalk__WEBPACK_IMPORTED_MODULE_2__.TreewalkCarSplitter(car, targetSize, { decoders })\n\n    const upload = (0,streaming_iterables__WEBPACK_IMPORTED_MODULE_0__.transform)(\n      MAX_CONCURRENT_UPLOADS,\n      async function (/** @type {AsyncIterable<Uint8Array>} */ car) {\n        const carParts = []\n        for await (const part of car) {\n          carParts.push(part)\n        }\n        const carFile = new _platform_js__WEBPACK_IMPORTED_MODULE_7__.Blob(carParts, { type: 'application/car' })\n        /** @type {Blob|ArrayBuffer} */\n        let body = carFile\n        // FIXME: should not be necessary to await arrayBuffer()!\n        // Node.js 20 hangs reading the stream (it never ends) but in\n        // older node versions and the browser it is fine to pass a blob.\n        /* c8 ignore next 3 */\n        if (parseInt(globalThis.process?.versions?.node) > 18) {\n          body = await body.arrayBuffer()\n        }\n        const cid = await p_retry__WEBPACK_IMPORTED_MODULE_1__(\n          async () => {\n            await rateLimiter()\n            /** @type {Response} */\n            let response\n            try {\n              response = await (0,_platform_js__WEBPACK_IMPORTED_MODULE_7__.fetch)(url.toString(), {\n                method: 'POST',\n                headers,\n                body,\n                signal,\n              })\n            } catch (/** @type {any} */ err) {\n              // TODO: remove me and test when client accepts custom fetch impl\n              /* c8 ignore next 1 */\n              throw signal && signal.aborted ? new p_retry__WEBPACK_IMPORTED_MODULE_1__.AbortError(err) : err\n            }\n            /* c8 ignore next 3 */\n            if (response.status === 429) {\n              throw new Error('rate limited')\n            }\n            const result = await response.json()\n            if (!result.ok) {\n              // do not retry if unauthorized - will not succeed\n              if (response.status === 401) {\n                throw new p_retry__WEBPACK_IMPORTED_MODULE_1__.AbortError(result.error.message)\n              }\n              throw new Error(result.error.message)\n            }\n            return result.value.cid\n          },\n          {\n            retries: maxRetries == null ? MAX_STORE_RETRIES : maxRetries,\n          }\n        )\n        onStoredChunk && onStoredChunk(carFile.size)\n        return cid\n      }\n    )\n\n    let root\n    for await (const cid of upload(splitter.cars())) {\n      root = cid\n    }\n\n    return /** @type {CIDString} */ (root)\n  }\n\n  /**\n   * Stores a directory of files and returns a CID. Provided files **MUST**\n   * be within the same directory, otherwise error is raised e.g. `foo/bar.png`,\n   * `foo/bla/baz.json` is ok but `foo/bar.png`, `bla/baz.json` is not.\n   *\n   * @param {Service} service\n   * @param {FilesSource} filesSource\n   * @param {RequestOptions} [options]\n   * @returns {Promise<CIDString>}\n   */\n  static async storeDirectory(service, filesSource, options) {\n    const blockstore = new _platform_js__WEBPACK_IMPORTED_MODULE_7__.Blockstore()\n    let cidString\n    try {\n      const { cid, car } = await NFTStorage.encodeDirectory(filesSource, {\n        blockstore,\n      })\n      await NFTStorage.storeCar(service, car, options)\n      cidString = cid.toString()\n    } finally {\n      await blockstore.close()\n    }\n\n    return cidString\n  }\n\n  /**\n   * Stores the given token and all resources it references (in the form of a\n   * File or a Blob) along with a metadata JSON as specificed in ERC-1155. The\n   * `token.image` must be either a `File` or a `Blob` instance, which will be\n   * stored and the corresponding content address URL will be saved in the\n   * metadata JSON file under `image` field.\n   *\n   * If `token.properties` contains properties with `File` or `Blob` values,\n   * those also get stored and their URLs will be saved in the metadata JSON\n   * file in their place.\n   *\n   * Note: URLs for `File` objects will retain file names e.g. in case of\n   * `new File([bytes], 'cat.png', { type: 'image/png' })` will be transformed\n   * into a URL that looks like `ipfs://bafy...hash/image/cat.png`. For `Blob`\n   * objects, the URL will not have a file name name or mime type, instead it\n   * will be transformed into a URL that looks like\n   * `ipfs://bafy...hash/image/blob`.\n   *\n   * @template {import('./lib/interface.js').TokenInput} T\n   * @param {Service} service\n   * @param {T} metadata\n   * @param {RequestOptions} [options]\n   * @returns {Promise<TokenType<T>>}\n   */\n  static async store(service, metadata, options) {\n    const { token, car } = await NFTStorage.encodeNFT(metadata)\n    await NFTStorage.storeCar(service, car, options)\n    return token\n  }\n\n  /**\n   * Returns current status of the stored NFT by its CID. Note the NFT must\n   * have previously been stored by this account.\n   *\n   * @param {Service} service\n   * @param {string} cid\n   * @param {RequestOptions} [options]\n   * @returns {Promise<import('./lib/interface.js').StatusResult>}\n   */\n  static async status(\n    { endpoint, rateLimiter = globalRateLimiter, ...token },\n    cid,\n    options\n  ) {\n    const url = new URL(`${cid}/`, endpoint)\n    await rateLimiter()\n    const response = await (0,_platform_js__WEBPACK_IMPORTED_MODULE_7__.fetch)(url.toString(), {\n      method: 'GET',\n      headers: NFTStorage.auth(token),\n      signal: options && options.signal,\n    })\n    /* c8 ignore next 3 */\n    if (response.status === 429) {\n      throw new Error('rate limited')\n    }\n    const result = await response.json()\n\n    if (result.ok) {\n      return {\n        cid: result.value.cid,\n        deals: decodeDeals(result.value.deals),\n        size: result.value.size,\n        pin: decodePin(result.value.pin),\n        created: new Date(result.value.created),\n      }\n    } else {\n      throw new Error(result.error.message)\n    }\n  }\n\n  /**\n   * Check if a CID of an NFT is being stored by NFT.Storage.\n   *\n   * @param {import('./lib/interface.js').PublicService} service\n   * @param {string} cid\n   * @param {RequestOptions} [options]\n   * @returns {Promise<import('./lib/interface.js').CheckResult>}\n   */\n  static async check(\n    { endpoint, rateLimiter = globalRateLimiter },\n    cid,\n    options\n  ) {\n    const url = new URL(`check/${cid}/`, endpoint)\n    await rateLimiter()\n    const response = await (0,_platform_js__WEBPACK_IMPORTED_MODULE_7__.fetch)(url.toString(), {\n      signal: options && options.signal,\n    })\n    /* c8 ignore next 3 */\n    if (response.status === 429) {\n      throw new Error('rate limited')\n    }\n    const result = await response.json()\n\n    if (result.ok) {\n      return {\n        cid: result.value.cid,\n        deals: decodeDeals(result.value.deals),\n        pin: result.value.pin,\n      }\n    } else {\n      throw new Error(result.error.message)\n    }\n  }\n\n  /**\n   * Removes stored content by its CID from this account. Please note that\n   * even if content is removed from the service other nodes that have\n   * replicated it might still continue providing it.\n   *\n   * @param {Service} service\n   * @param {string} cid\n   * @param {RequestOptions} [options]\n   * @returns {Promise<void>}\n   */\n  static async delete(\n    { endpoint, rateLimiter = globalRateLimiter, ...token },\n    cid,\n    options\n  ) {\n    const url = new URL(`${cid}/`, endpoint)\n    await rateLimiter()\n    const response = await (0,_platform_js__WEBPACK_IMPORTED_MODULE_7__.fetch)(url.toString(), {\n      method: 'DELETE',\n      headers: NFTStorage.auth(token),\n      signal: options && options.signal,\n    })\n    /* c8 ignore next 3 */\n    if (response.status === 429) {\n      throw new Error('rate limited')\n    }\n    const result = await response.json()\n    if (!result.ok) {\n      throw new Error(result.error.message)\n    }\n  }\n\n  /**\n   * Encodes the given token and all resources it references (in the form of a\n   * File or a Blob) along with a metadata JSON as specificed in ERC-1155 to a\n   * CAR file. The `token.image` must be either a `File` or a `Blob` instance,\n   * which will be stored and the corresponding content address URL will be\n   * saved in the metadata JSON file under `image` field.\n   *\n   * If `token.properties` contains properties with `File` or `Blob` values,\n   * those also get stored and their URLs will be saved in the metadata JSON\n   * file in their place.\n   *\n   * Note: URLs for `File` objects will retain file names e.g. in case of\n   * `new File([bytes], 'cat.png', { type: 'image/png' })` will be transformed\n   * into a URL that looks like `ipfs://bafy...hash/image/cat.png`. For `Blob`\n   * objects, the URL will not have a file name name or mime type, instead it\n   * will be transformed into a URL that looks like\n   * `ipfs://bafy...hash/image/blob`.\n   *\n   * @example\n   * ```js\n   * const { token, car } = await NFTStorage.encodeNFT({\n   *   name: 'nft.storage store test',\n   *   description: 'Test ERC-1155 compatible metadata.',\n   *   image: new File(['<DATA>'], 'pinpie.jpg', { type: 'image/jpg' }),\n   *   properties: {\n   *     custom: 'Custom data can appear here, files are auto uploaded.',\n   *     file: new File(['<DATA>'], 'README.md', { type: 'text/plain' }),\n   *   }\n   * })\n   *\n   * console.log('IPFS URL for the metadata:', token.url)\n   * console.log('metadata.json contents:\\n', token.data)\n   * console.log('metadata.json with IPFS gateway URLs:\\n', token.embed())\n   *\n   * // Now store the CAR file on NFT.Storage\n   * await client.storeCar(car)\n   * ```\n   *\n   * @template {import('./lib/interface.js').TokenInput} T\n   * @param {T} input\n   * @returns {Promise<{ cid: CID, token: TokenType<T>, car: CarReader }>}\n   */\n  static async encodeNFT(input) {\n    validateERC1155(input)\n    return _token_js__WEBPACK_IMPORTED_MODULE_6__.Token.encode(input)\n  }\n\n  /**\n   * Encodes a single file to a CAR file and also returns its root CID.\n   *\n   * @example\n   * ```js\n   * const content = new Blob(['hello world'])\n   * const { cid, car } = await NFTStorage.encodeBlob(content)\n   *\n   * // Root CID of the file\n   * console.log(cid.toString())\n   *\n   * // Now store the CAR file on NFT.Storage\n   * await client.storeCar(car)\n   * ```\n   *\n   * @param {Blob} blob\n   * @param {object} [options]\n   * @param {BlockstoreI} [options.blockstore]\n   * @returns {Promise<{ cid: CID, car: CarReader }>}\n   */\n  static async encodeBlob(blob, { blockstore } = {}) {\n    if (blob.size === 0) {\n      throw new Error('Content size is 0, make sure to provide some content')\n    }\n    return packCar([toImportCandidate('blob', blob)], {\n      blockstore,\n      wrapWithDirectory: false,\n    })\n  }\n\n  /**\n   * Encodes a directory of files to a CAR file and also returns the root CID.\n   * Provided files **MUST** be within the same directory, otherwise error is\n   * raised e.g. `foo/bar.png`, `foo/bla/baz.json` is ok but `foo/bar.png`,\n   * `bla/baz.json` is not.\n   *\n   * @example\n   * ```js\n   * const { cid, car } = await NFTStorage.encodeDirectory([\n   *   new File(['hello world'], 'hello.txt'),\n   *   new File([JSON.stringify({'from': 'incognito'}, null, 2)], 'metadata.json')\n   * ])\n   *\n   * // Root CID of the directory\n   * console.log(cid.toString())\n   *\n   * // Now store the CAR file on NFT.Storage\n   * await client.storeCar(car)\n   * ```\n   *\n   * @param {FilesSource} files\n   * @param {object} [options]\n   * @param {BlockstoreI} [options.blockstore]\n   * @returns {Promise<{ cid: CID, car: CarReader }>}\n   */\n  static async encodeDirectory(files, { blockstore } = {}) {\n    let size = 0\n    const input = it_pipe__WEBPACK_IMPORTED_MODULE_10__(files, async function* (files) {\n      for await (const file of files) {\n        yield toImportCandidate(file.name, file)\n        size += file.size\n      }\n    })\n    const packed = await packCar(input, {\n      blockstore,\n      wrapWithDirectory: true,\n    })\n    if (size === 0) {\n      throw new Error(\n        'Total size of files should exceed 0, make sure to provide some content'\n      )\n    }\n    return packed\n  }\n\n  // Just a sugar so you don't have to pass around endpoint and token around.\n\n  /**\n   * Stores a single file and returns the corresponding Content Identifier (CID).\n   * Takes a [Blob](https://developer.mozilla.org/en-US/docs/Web/API/Blob/Blob)\n   * or a [File](https://developer.mozilla.org/en-US/docs/Web/API/File). Note\n   * that no file name or file metadata is retained.\n   *\n   * @example\n   * ```js\n   * const content = new Blob(['hello world'])\n   * const cid = await client.storeBlob(content)\n   * cid //> 'zdj7Wn9FQAURCP6MbwcWuzi7u65kAsXCdjNTkhbJcoaXBusq9'\n   * ```\n   *\n   * @param {Blob} blob\n   * @param {RequestOptions} [options]\n   */\n  storeBlob(blob, options) {\n    return NFTStorage.storeBlob(this, blob, options)\n  }\n\n  /**\n   * Stores files encoded as a single [Content Addressed Archive\n   * (CAR)](https://github.com/ipld/specs/blob/master/block-layer/content-addressable-archives.md).\n   *\n   * Takes a [Blob](https://developer.mozilla.org/en-US/docs/Web/API/Blob/Blob)\n   * or a [File](https://developer.mozilla.org/en-US/docs/Web/API/File).\n   *\n   * Returns the corresponding Content Identifier (CID).\n   *\n   * See the [`ipfs-car` docs](https://www.npmjs.com/package/ipfs-car) for more\n   * details on packing a CAR file.\n   *\n   * @example\n   * ```js\n   * import { pack } from 'ipfs-car/pack'\n   * import { CarReader } from '@ipld/car'\n   * const { out, root } = await pack({\n   *  input: fs.createReadStream('pinpie.pdf')\n   * })\n   * const expectedCid = root.toString()\n   * const carReader = await CarReader.fromIterable(out)\n   * const cid = await storage.storeCar(carReader)\n   * console.assert(cid === expectedCid)\n   * ```\n   *\n   * @example\n   * ```\n   * import { packToBlob } from 'ipfs-car/pack/blob'\n   * const data = 'Hello world'\n   * const { root, car } = await packToBlob({ input: [new TextEncoder().encode(data)] })\n   * const expectedCid = root.toString()\n   * const cid = await client.storeCar(car)\n   * console.assert(cid === expectedCid)\n   * ```\n   * @param {Blob|CarReader} car\n   * @param {import('./lib/interface.js').CarStorerOptions} [options]\n   */\n  storeCar(car, options) {\n    return NFTStorage.storeCar(this, car, options)\n  }\n\n  /**\n   * Stores a directory of files and returns a CID for the directory.\n   *\n   * @example\n   * ```js\n   * const cid = await client.storeDirectory([\n   *   new File(['hello world'], 'hello.txt'),\n   *   new File([JSON.stringify({'from': 'incognito'}, null, 2)], 'metadata.json')\n   * ])\n   * cid //>\n   * ```\n   *\n   * Argument can be a [FileList](https://developer.mozilla.org/en-US/docs/Web/API/FileList)\n   * instance as well, in which case directory structure will be retained.\n   *\n   * @param {FilesSource} files\n   * @param {RequestOptions} [options]\n   */\n  storeDirectory(files, options) {\n    return NFTStorage.storeDirectory(this, files, options)\n  }\n\n  /**\n   * Returns current status of the stored NFT by its CID. Note the NFT must\n   * have previously been stored by this account.\n   *\n   * @example\n   * ```js\n   * const status = await client.status('zdj7Wn9FQAURCP6MbwcWuzi7u65kAsXCdjNTkhbJcoaXBusq9')\n   * ```\n   *\n   * @param {string} cid\n   * @param {RequestOptions} [options]\n   */\n  status(cid, options) {\n    return NFTStorage.status(this, cid, options)\n  }\n\n  /**\n   * Removes stored content by its CID from the service.\n   *\n   * > Please note that even if content is removed from the service other nodes\n   * that have replicated it might still continue providing it.\n   *\n   * @example\n   * ```js\n   * await client.delete('zdj7Wn9FQAURCP6MbwcWuzi7u65kAsXCdjNTkhbJcoaXBusq9')\n   * ```\n   *\n   * @param {string} cid\n   * @param {RequestOptions} [options]\n   */\n  delete(cid, options) {\n    return NFTStorage.delete(this, cid, options)\n  }\n\n  /**\n   * Check if a CID of an NFT is being stored by nft.storage. Throws if the NFT\n   * was not found.\n   *\n   * @example\n   * ```js\n   * const status = await client.check('zdj7Wn9FQAURCP6MbwcWuzi7u65kAsXCdjNTkhbJcoaXBusq9')\n   * ```\n   *\n   * @param {string} cid\n   * @param {RequestOptions} [options]\n   */\n  check(cid, options) {\n    return NFTStorage.check(this, cid, options)\n  }\n\n  /**\n   * Stores the given token and all resources it references (in the form of a\n   * File or a Blob) along with a metadata JSON as specificed in\n   * [ERC-1155](https://eips.ethereum.org/EIPS/eip-1155#metadata). The\n   * `token.image` must be either a `File` or a `Blob` instance, which will be\n   * stored and the corresponding content address URL will be saved in the\n   * metadata JSON file under `image` field.\n   *\n   * If `token.properties` contains properties with `File` or `Blob` values,\n   * those also get stored and their URLs will be saved in the metadata JSON\n   * file in their place.\n   *\n   * Note: URLs for `File` objects will retain file names e.g. in case of\n   * `new File([bytes], 'cat.png', { type: 'image/png' })` will be transformed\n   * into a URL that looks like `ipfs://bafy...hash/image/cat.png`. For `Blob`\n   * objects, the URL will not have a file name name or mime type, instead it\n   * will be transformed into a URL that looks like\n   * `ipfs://bafy...hash/image/blob`.\n   *\n   * @example\n   * ```js\n   * const metadata = await client.store({\n   *   name: 'nft.storage store test',\n   *   description: 'Test ERC-1155 compatible metadata.',\n   *   image: new File(['<DATA>'], 'pinpie.jpg', { type: 'image/jpg' }),\n   *   properties: {\n   *     custom: 'Custom data can appear here, files are auto uploaded.',\n   *     file: new File(['<DATA>'], 'README.md', { type: 'text/plain' }),\n   *   }\n   * })\n   *\n   * console.log('IPFS URL for the metadata:', metadata.url)\n   * console.log('metadata.json contents:\\n', metadata.data)\n   * console.log('metadata.json with IPFS gateway URLs:\\n', metadata.embed())\n   * ```\n   *\n   * @template {import('./lib/interface.js').TokenInput} T\n   * @param {T} token\n   * @param {RequestOptions} [options]\n   */\n  store(token, options) {\n    return NFTStorage.store(this, token, options)\n  }\n}\n\n/**\n * Cast an iterable to an asyncIterable\n * @template T\n * @param {Iterable<T>} iterable\n * @returns {AsyncIterable<T>}\n */\nfunction toAsyncIterable(iterable) {\n  return (async function* () {\n    for (const item of iterable) {\n      yield item\n    }\n  })()\n}\n\n/**\n * @template {import('./lib/interface.js').TokenInput} T\n * @param {T} metadata\n */\nconst validateERC1155 = ({ name, description, image, decimals }) => {\n  // Just validate that expected fields are present\n  if (typeof name !== 'string') {\n    throw new TypeError(\n      'string property `name` identifying the asset is required'\n    )\n  }\n  if (typeof description !== 'string') {\n    throw new TypeError(\n      'string property `description` describing asset is required'\n    )\n  }\n  if (!(image instanceof _platform_js__WEBPACK_IMPORTED_MODULE_7__.Blob)) {\n    throw new TypeError('property `image` must be a Blob or File object')\n  } else if (!image.type.startsWith('image/')) {\n    console.warn(`According to ERC721 Metadata JSON Schema 'image' must have 'image/*' mime type.\n\nFor better interoperability we would highly recommend storing content with different mime type under 'properties' namespace e.g. \\`properties: { video: file }\\` and using 'image' field for storing a preview image for it instead.\n\nFor more context please see ERC-721 specification https://eips.ethereum.org/EIPS/eip-721`)\n  }\n\n  if (typeof decimals !== 'undefined' && typeof decimals !== 'number') {\n    throw new TypeError('property `decimals` must be an integer value')\n  }\n}\n\n/**\n * @param {import('ipfs-car/pack').ImportCandidateStream|Array<{ path: string, content: import('./platform.js').ReadableStream }>} input\n * @param {object} [options]\n * @param {BlockstoreI} [options.blockstore]\n * @param {boolean} [options.wrapWithDirectory]\n */\nconst packCar = async (input, { blockstore, wrapWithDirectory } = {}) => {\n  /* c8 ignore next 1 */\n  blockstore = blockstore || new _platform_js__WEBPACK_IMPORTED_MODULE_7__.Blockstore()\n  const { root: cid } = await (0,ipfs_car_pack__WEBPACK_IMPORTED_MODULE_3__.pack)({ input, blockstore, wrapWithDirectory })\n  const car = new _bs_car_reader_js__WEBPACK_IMPORTED_MODULE_9__.BlockstoreCarReader(1, [cid], blockstore)\n  return { cid, car }\n}\n\n/**\n * @param {Deal[]} deals\n * @returns {Deal[]}\n */\nconst decodeDeals = (deals) =>\n  deals.map((deal) => {\n    const { dealActivation, dealExpiration, lastChanged } = {\n      dealExpiration: null,\n      dealActivation: null,\n      ...deal,\n    }\n\n    return {\n      ...deal,\n      lastChanged: new Date(lastChanged),\n      ...(dealActivation && { dealActivation: new Date(dealActivation) }),\n      ...(dealExpiration && { dealExpiration: new Date(dealExpiration) }),\n    }\n  })\n\n/**\n * @param {Pin} pin\n * @returns {Pin}\n */\nconst decodePin = (pin) => ({ ...pin, created: new Date(pin.created) })\n\n/**\n * Convert the passed blob to an \"import candidate\" - an object suitable for\n * passing to the ipfs-unixfs-importer. Note: content is an accessor so that\n * the stream is created only when needed.\n *\n * @param {string} path\n * @param {Pick<Blob, 'stream'>|{ stream: () => AsyncIterable<Uint8Array> }} blob\n * @returns {import('ipfs-core-types/src/utils.js').ImportCandidate}\n */\nfunction toImportCandidate(path, blob) {\n  /** @type {AsyncIterable<Uint8Array>} */\n  let stream\n  return {\n    path,\n    get content() {\n      stream = stream || blob.stream()\n      return stream\n    },\n  }\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbmZ0LnN0b3JhZ2Uvc3JjL2xpYi5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVkseUJBQXlCO0FBQ3JDLG1DQUFtQyxrQkFBa0I7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFK0M7QUFDSDtBQUNXO0FBQ25CO0FBQ0U7QUFDTTtBQUNUO0FBQ29DO0FBQzVCO0FBQ2E7QUFDOUI7O0FBRTFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxhQUFhLHNDQUFzQztBQUNuRCxhQUFhLHdDQUF3QztBQUNyRCxhQUFhLG1DQUFtQztBQUNoRCxhQUFhLHlDQUF5QztBQUN0RCxhQUFhLDBDQUEwQztBQUN2RCxhQUFhLGtDQUFrQztBQUMvQyxhQUFhLHdDQUF3QztBQUNyRCxhQUFhLDBDQUEwQztBQUN2RCxhQUFhLDBDQUEwQztBQUN2RCxhQUFhLDZDQUE2QztBQUMxRDs7QUFFQTtBQUNBLGFBQWE7QUFDYjtBQUNPO0FBQ1AsbUJBQW1CLDRDQUFjO0FBQ2pDLGdDQUFnQztBQUNoQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxjQUFjLHlDQUF5QztBQUN2RCxhQUFhLHVDQUF1QztBQUNwRDs7QUFFQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyx5QkFBeUI7QUFDdkMscUNBQXFDLGtCQUFrQjtBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLGFBQWE7QUFDM0I7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxjQUFjLHlFQUF5RTtBQUN2RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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bmZ0LnN0b3JhZ2Uvc3JjL2xpYi5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEEgY2xpZW50IGxpYnJhcnkgZm9yIHRoZSBodHRwczovL25mdC5zdG9yYWdlLyBzZXJ2aWNlLiBJdCBwcm92aWRlcyBhIGNvbnZlbmllbnRcbiAqIGludGVyZmFjZSBmb3Igd29ya2luZyB3aXRoIHRoZSBbUmF3IEhUVFAgQVBJXShodHRwczovL25mdC5zdG9yYWdlLyNhcGktZG9jcylcbiAqIGZyb20gYSB3ZWIgYnJvd3NlciBvciBbTm9kZS5qc10oaHR0cHM6Ly9ub2RlanMub3JnLykgYW5kIGNvbWVzIGJ1bmRsZWQgd2l0aFxuICogVFMgZm9yIG91dC1vZi10aGUgYm94IHR5cGUgaW5mZXJlbmNlIGFuZCBiZXR0ZXIgSW50ZWxsaVNlbnNlLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGBqc1xuICogaW1wb3J0IHsgTkZUU3RvcmFnZSwgRmlsZSwgQmxvYiB9IGZyb20gXCJuZnQuc3RvcmFnZVwiXG4gKiBjb25zdCBjbGllbnQgPSBuZXcgTkZUU3RvcmFnZSh7IHRva2VuOiBBUElfVE9LRU4gfSlcbiAqXG4gKiBjb25zdCBjaWQgPSBhd2FpdCBjbGllbnQuc3RvcmVCbG9iKG5ldyBCbG9iKFsnaGVsbG8gd29ybGQnXSkpXG4gKiBgYGBcbiAqIEBtb2R1bGVcbiAqL1xuXG5pbXBvcnQgeyB0cmFuc2Zvcm0gfSBmcm9tICdzdHJlYW1pbmctaXRlcmFibGVzJ1xuaW1wb3J0IHBSZXRyeSwgeyBBYm9ydEVycm9yIH0gZnJvbSAncC1yZXRyeSdcbmltcG9ydCB7IFRyZWV3YWxrQ2FyU3BsaXR0ZXIgfSBmcm9tICdjYXJiaXRlcy90cmVld2FsaydcbmltcG9ydCB7IHBhY2sgfSBmcm9tICdpcGZzLWNhci9wYWNrJ1xuaW1wb3J0IHsgQ0lEIH0gZnJvbSAnbXVsdGlmb3JtYXRzL2NpZCdcbmltcG9ydCB0aHJvdHRsZWRRdWV1ZSBmcm9tICd0aHJvdHRsZWQtcXVldWUnXG5pbXBvcnQgKiBhcyBUb2tlbiBmcm9tICcuL3Rva2VuLmpzJ1xuaW1wb3J0IHsgZmV0Y2gsIEZpbGUsIEJsb2IsIEZvcm1EYXRhLCBCbG9ja3N0b3JlIH0gZnJvbSAnLi9wbGF0Zm9ybS5qcydcbmltcG9ydCB7IHRvR2F0ZXdheVVSTCB9IGZyb20gJy4vZ2F0ZXdheS5qcydcbmltcG9ydCB7IEJsb2Nrc3RvcmVDYXJSZWFkZXIgfSBmcm9tICcuL2JzLWNhci1yZWFkZXIuanMnXG5pbXBvcnQgcGlwZSBmcm9tICdpdC1waXBlJ1xuXG5jb25zdCBNQVhfU1RPUkVfUkVUUklFUyA9IDVcbmNvbnN0IE1BWF9DT05DVVJSRU5UX1VQTE9BRFMgPSAzXG5jb25zdCBNQVhfQ0hVTktfU0laRSA9IDEwMjQgKiAxMDI0ICogNTAgLy8gY2h1bmsgdG8gfjUwTUIgQ0FSc1xuY29uc3QgUkFURV9MSU1JVF9SRVFVRVNUUyA9IDMwXG5jb25zdCBSQVRFX0xJTUlUX1BFUklPRCA9IDEwICogMTAwMFxuXG4vKipcbiAqIEB0eXBlZGVmIHtpbXBvcnQoJy4vbGliL2ludGVyZmFjZS5qcycpLlNlcnZpY2V9IFNlcnZpY2VcbiAqIEB0eXBlZGVmIHtpbXBvcnQoJy4vbGliL2ludGVyZmFjZS5qcycpLkNJRFN0cmluZ30gQ0lEU3RyaW5nXG4gKiBAdHlwZWRlZiB7aW1wb3J0KCcuL2xpYi9pbnRlcmZhY2UuanMnKS5EZWFsfSBEZWFsXG4gKiBAdHlwZWRlZiB7aW1wb3J0KCcuL2xpYi9pbnRlcmZhY2UuanMnKS5GaWxlT2JqZWN0fSBGaWxlT2JqZWN0XG4gKiBAdHlwZWRlZiB7aW1wb3J0KCcuL2xpYi9pbnRlcmZhY2UuanMnKS5GaWxlc1NvdXJjZX0gRmlsZXNTb3VyY2VcbiAqIEB0eXBlZGVmIHtpbXBvcnQoJy4vbGliL2ludGVyZmFjZS5qcycpLlBpbn0gUGluXG4gKiBAdHlwZWRlZiB7aW1wb3J0KCcuL2xpYi9pbnRlcmZhY2UuanMnKS5DYXJSZWFkZXJ9IENhclJlYWRlclxuICogQHR5cGVkZWYge2ltcG9ydCgnaXBmcy1jYXIvYmxvY2tzdG9yZScpLkJsb2Nrc3RvcmV9IEJsb2Nrc3RvcmVJXG4gKiBAdHlwZWRlZiB7aW1wb3J0KCcuL2xpYi9pbnRlcmZhY2UuanMnKS5SYXRlTGltaXRlcn0gUmF0ZUxpbWl0ZXJcbiAqIEB0eXBlZGVmIHtpbXBvcnQoJy4vbGliL2ludGVyZmFjZS5qcycpLlJlcXVlc3RPcHRpb25zfSBSZXF1ZXN0T3B0aW9uc1xuICovXG5cbi8qKlxuICogQHJldHVybnMge1JhdGVMaW1pdGVyfVxuICovXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlUmF0ZUxpbWl0ZXIoKSB7XG4gIGNvbnN0IHRocm90dGxlID0gdGhyb3R0bGVkUXVldWUoUkFURV9MSU1JVF9SRVFVRVNUUywgUkFURV9MSU1JVF9QRVJJT0QpXG4gIHJldHVybiAoKSA9PiB0aHJvdHRsZSgoKSA9PiB7fSlcbn1cblxuLyoqXG4gKiBSYXRlIGxpbWl0ZXIgdXNlZCBieSBzdGF0aWMgQVBJIGlmIG5vIHJhdGUgbGltaXRlciBpcyBwYXNzZWQuIE5vdGUgdGhhdCBlYWNoXG4gKiBpbnN0YW5jZSBvZiB0aGUgTkZUU3RvcmFnZSBjbGFzcyBnZXRzIGl0J3Mgb3duIGxpbWl0ZXIgaWYgbm9uZSBpcyBwYXNzZWQuXG4gKiBUaGlzIGlzIGJlY2F1c2UgcmF0ZSBsaW1pdHMgYXJlIGVuZm9yY2VkIHBlciBBUEkgdG9rZW4uXG4gKi9cbmNvbnN0IGdsb2JhbFJhdGVMaW1pdGVyID0gY3JlYXRlUmF0ZUxpbWl0ZXIoKVxuXG4vKipcbiAqIEB0ZW1wbGF0ZSB7aW1wb3J0KCcuL2xpYi9pbnRlcmZhY2UuanMnKS5Ub2tlbklucHV0fSBUXG4gKiBAdHlwZWRlZiB7aW1wb3J0KCcuL2xpYi9pbnRlcmZhY2UuanMnKS5Ub2tlbjxUPn0gVG9rZW5UeXBlXG4gKi9cblxuLyoqXG4gKiBAaW1wbGVtZW50cyB7U2VydmljZX1cbiAqL1xuY2xhc3MgTkZUU3RvcmFnZSB7XG4gIC8qKlxuICAgKiBDb25zdHJ1Y3RzIGEgY2xpZW50IGJvdW5kIHRvIHRoZSBnaXZlbiBgb3B0aW9ucy50b2tlbmAgYW5kXG4gICAqIGBvcHRpb25zLmVuZHBvaW50YC5cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogYGBganNcbiAgICogaW1wb3J0IHsgTkZUU3RvcmFnZSwgRmlsZSwgQmxvYiB9IGZyb20gXCJuZnQuc3RvcmFnZVwiXG4gICAqIGNvbnN0IGNsaWVudCA9IG5ldyBORlRTdG9yYWdlKHsgdG9rZW46IEFQSV9UT0tFTiB9KVxuICAgKlxuICAgKiBjb25zdCBjaWQgPSBhd2FpdCBjbGllbnQuc3RvcmVCbG9iKG5ldyBCbG9iKFsnaGVsbG8gd29ybGQnXSkpXG4gICAqIGBgYFxuICAgKiBPcHRpb25hbGx5IHlvdSBjb3VsZCBwYXNzIGFuIGFsdGVybmF0aXZlIEFQSSBlbmRwb2ludCAoZS5nLiBmb3IgdGVzdGluZylcbiAgICogQGV4YW1wbGVcbiAgICogYGBganNcbiAgICogaW1wb3J0IHsgTkZUU3RvcmFnZSB9IGZyb20gXCJuZnQuc3RvcmFnZVwiXG4gICAqIGNvbnN0IGNsaWVudCA9IG5ldyBORlRTdG9yYWdlKHtcbiAgICogICB0b2tlbjogQVBJX1RPS0VOXG4gICAqICAgZW5kcG9pbnQ6IG5ldyBVUkwoJ2h0dHA6Ly9sb2NhbGhvc3Q6ODA4MC8nKVxuICAgKiB9KVxuICAgKiBgYGBcbiAgICpcbiAgICogQHBhcmFtIHt7dG9rZW46IHN0cmluZywgZW5kcG9pbnQ/OiBVUkwsIHJhdGVMaW1pdGVyPzogUmF0ZUxpbWl0ZXIsIGRpZD86IHN0cmluZ319IG9wdGlvbnNcbiAgICovXG4gIGNvbnN0cnVjdG9yKHtcbiAgICB0b2tlbixcbiAgICBkaWQsXG4gICAgZW5kcG9pbnQgPSBuZXcgVVJMKCdodHRwczovL2FwaS5uZnQuc3RvcmFnZScpLFxuICAgIHJhdGVMaW1pdGVyLFxuICB9KSB7XG4gICAgLyoqXG4gICAgICogQXV0aG9yaXphdGlvbiB0b2tlbi5cbiAgICAgKlxuICAgICAqIEByZWFkb25seVxuICAgICAqL1xuICAgIHRoaXMudG9rZW4gPSB0b2tlblxuICAgIC8qKlxuICAgICAqIFNlcnZpY2UgQVBJIGVuZHBvaW50IGBVUkxgLlxuICAgICAqIEByZWFkb25seVxuICAgICAqL1xuICAgIHRoaXMuZW5kcG9pbnQgPSBlbmRwb2ludFxuICAgIC8qKlxuICAgICAqIEByZWFkb25seVxuICAgICAqL1xuICAgIHRoaXMucmF0ZUxpbWl0ZXIgPSByYXRlTGltaXRlciB8fCBjcmVhdGVSYXRlTGltaXRlcigpXG5cbiAgICAvKipcbiAgICAgKiBAcmVhZG9ubHlcbiAgICAgKi9cbiAgICB0aGlzLmRpZCA9IGRpZFxuICB9XG5cbiAgLyoqXG4gICAqIEBoaWRkZW5cbiAgICogQHBhcmFtIHtvYmplY3R9IG9wdGlvbnNcbiAgICogQHBhcmFtIHtzdHJpbmd9IG9wdGlvbnMudG9rZW5cbiAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLmRpZF1cbiAgICovXG4gIHN0YXRpYyBhdXRoKHsgdG9rZW4sIGRpZCB9KSB7XG4gICAgaWYgKCF0b2tlbikgdGhyb3cgbmV3IEVycm9yKCdtaXNzaW5nIHRva2VuJylcbiAgICByZXR1cm4ge1xuICAgICAgQXV0aG9yaXphdGlvbjogYEJlYXJlciAke3Rva2VufWAsXG4gICAgICAnWC1DbGllbnQnOiAnbmZ0LnN0b3JhZ2UvanMnLFxuICAgICAgLi4uKGRpZCA/IHsgJ3gtYWdlbnQtZGlkJzogZGlkIH0gOiB7fSksXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFN0b3JlcyBhIHNpbmdsZSBmaWxlIGFuZCByZXR1cm5zIGl0cyBDSUQuXG4gICAqXG4gICAqIEBwYXJhbSB7U2VydmljZX0gc2VydmljZVxuICAgKiBAcGFyYW0ge0Jsb2J9IGJsb2JcbiAgICogQHBhcmFtIHtSZXF1ZXN0T3B0aW9uc30gW29wdGlvbnNdXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPENJRFN0cmluZz59XG4gICAqL1xuICBzdGF0aWMgYXN5bmMgc3RvcmVCbG9iKHNlcnZpY2UsIGJsb2IsIG9wdGlvbnMpIHtcbiAgICBjb25zdCBibG9ja3N0b3JlID0gbmV3IEJsb2Nrc3RvcmUoKVxuICAgIGxldCBjaWRTdHJpbmdcblxuICAgIHRyeSB7XG4gICAgICBjb25zdCB7IGNpZCwgY2FyIH0gPSBhd2FpdCBORlRTdG9yYWdlLmVuY29kZUJsb2IoYmxvYiwgeyBibG9ja3N0b3JlIH0pXG4gICAgICBhd2FpdCBORlRTdG9yYWdlLnN0b3JlQ2FyKHNlcnZpY2UsIGNhciwgb3B0aW9ucylcbiAgICAgIGNpZFN0cmluZyA9IGNpZC50b1N0cmluZygpXG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIGF3YWl0IGJsb2Nrc3RvcmUuY2xvc2UoKVxuICAgIH1cblxuICAgIHJldHVybiBjaWRTdHJpbmdcbiAgfVxuXG4gIC8qKlxuICAgKiBTdG9yZXMgYSBDQVIgZmlsZSBhbmQgcmV0dXJucyBpdHMgcm9vdCBDSUQuXG4gICAqXG4gICAqIEBwYXJhbSB7U2VydmljZX0gc2VydmljZVxuICAgKiBAcGFyYW0ge0Jsb2J8Q2FyUmVhZGVyfSBjYXJcbiAgICogQHBhcmFtIHtpbXBvcnQoJy4vbGliL2ludGVyZmFjZS5qcycpLkNhclN0b3Jlck9wdGlvbnN9IFtvcHRpb25zXVxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxDSURTdHJpbmc+fVxuICAgKi9cbiAgc3RhdGljIGFzeW5jIHN0b3JlQ2FyKFxuICAgIHsgZW5kcG9pbnQsIHJhdGVMaW1pdGVyID0gZ2xvYmFsUmF0ZUxpbWl0ZXIsIC4uLnRva2VuIH0sXG4gICAgY2FyLFxuICAgIHsgb25TdG9yZWRDaHVuaywgbWF4UmV0cmllcywgbWF4Q2h1bmtTaXplLCBkZWNvZGVycywgc2lnbmFsIH0gPSB7fVxuICApIHtcbiAgICBjb25zdCB1cmwgPSBuZXcgVVJMKCd1cGxvYWQvJywgZW5kcG9pbnQpXG4gICAgY29uc3QgaGVhZGVycyA9IHtcbiAgICAgIC4uLk5GVFN0b3JhZ2UuYXV0aCh0b2tlbiksXG4gICAgICAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2NhcicsXG4gICAgfVxuICAgIGNvbnN0IHRhcmdldFNpemUgPSBtYXhDaHVua1NpemUgfHwgTUFYX0NIVU5LX1NJWkVcbiAgICBjb25zdCBzcGxpdHRlciA9XG4gICAgICBjYXIgaW5zdGFuY2VvZiBCbG9iXG4gICAgICAgID8gYXdhaXQgVHJlZXdhbGtDYXJTcGxpdHRlci5mcm9tQmxvYihjYXIsIHRhcmdldFNpemUsIHsgZGVjb2RlcnMgfSlcbiAgICAgICAgOiBuZXcgVHJlZXdhbGtDYXJTcGxpdHRlcihjYXIsIHRhcmdldFNpemUsIHsgZGVjb2RlcnMgfSlcblxuICAgIGNvbnN0IHVwbG9hZCA9IHRyYW5zZm9ybShcbiAgICAgIE1BWF9DT05DVVJSRU5UX1VQTE9BRFMsXG4gICAgICBhc3luYyBmdW5jdGlvbiAoLyoqIEB0eXBlIHtBc3luY0l0ZXJhYmxlPFVpbnQ4QXJyYXk+fSAqLyBjYXIpIHtcbiAgICAgICAgY29uc3QgY2FyUGFydHMgPSBbXVxuICAgICAgICBmb3IgYXdhaXQgKGNvbnN0IHBhcnQgb2YgY2FyKSB7XG4gICAgICAgICAgY2FyUGFydHMucHVzaChwYXJ0KVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGNhckZpbGUgPSBuZXcgQmxvYihjYXJQYXJ0cywgeyB0eXBlOiAnYXBwbGljYXRpb24vY2FyJyB9KVxuICAgICAgICAvKiogQHR5cGUge0Jsb2J8QXJyYXlCdWZmZXJ9ICovXG4gICAgICAgIGxldCBib2R5ID0gY2FyRmlsZVxuICAgICAgICAvLyBGSVhNRTogc2hvdWxkIG5vdCBiZSBuZWNlc3NhcnkgdG8gYXdhaXQgYXJyYXlCdWZmZXIoKSFcbiAgICAgICAgLy8gTm9kZS5qcyAyMCBoYW5ncyByZWFkaW5nIHRoZSBzdHJlYW0gKGl0IG5ldmVyIGVuZHMpIGJ1dCBpblxuICAgICAgICAvLyBvbGRlciBub2RlIHZlcnNpb25zIGFuZCB0aGUgYnJvd3NlciBpdCBpcyBmaW5lIHRvIHBhc3MgYSBibG9iLlxuICAgICAgICAvKiBjOCBpZ25vcmUgbmV4dCAzICovXG4gICAgICAgIGlmIChwYXJzZUludChnbG9iYWxUaGlzLnByb2Nlc3M/LnZlcnNpb25zPy5ub2RlKSA+IDE4KSB7XG4gICAgICAgICAgYm9keSA9IGF3YWl0IGJvZHkuYXJyYXlCdWZmZXIoKVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGNpZCA9IGF3YWl0IHBSZXRyeShcbiAgICAgICAgICBhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICBhd2FpdCByYXRlTGltaXRlcigpXG4gICAgICAgICAgICAvKiogQHR5cGUge1Jlc3BvbnNlfSAqL1xuICAgICAgICAgICAgbGV0IHJlc3BvbnNlXG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICByZXNwb25zZSA9IGF3YWl0IGZldGNoKHVybC50b1N0cmluZygpLCB7XG4gICAgICAgICAgICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICAgICAgICAgICAgaGVhZGVycyxcbiAgICAgICAgICAgICAgICBib2R5LFxuICAgICAgICAgICAgICAgIHNpZ25hbCxcbiAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIH0gY2F0Y2ggKC8qKiBAdHlwZSB7YW55fSAqLyBlcnIpIHtcbiAgICAgICAgICAgICAgLy8gVE9ETzogcmVtb3ZlIG1lIGFuZCB0ZXN0IHdoZW4gY2xpZW50IGFjY2VwdHMgY3VzdG9tIGZldGNoIGltcGxcbiAgICAgICAgICAgICAgLyogYzggaWdub3JlIG5leHQgMSAqL1xuICAgICAgICAgICAgICB0aHJvdyBzaWduYWwgJiYgc2lnbmFsLmFib3J0ZWQgPyBuZXcgQWJvcnRFcnJvcihlcnIpIDogZXJyXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvKiBjOCBpZ25vcmUgbmV4dCAzICovXG4gICAgICAgICAgICBpZiAocmVzcG9uc2Uuc3RhdHVzID09PSA0MjkpIHtcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdyYXRlIGxpbWl0ZWQnKVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgcmVzcG9uc2UuanNvbigpXG4gICAgICAgICAgICBpZiAoIXJlc3VsdC5vaykge1xuICAgICAgICAgICAgICAvLyBkbyBub3QgcmV0cnkgaWYgdW5hdXRob3JpemVkIC0gd2lsbCBub3Qgc3VjY2VlZFxuICAgICAgICAgICAgICBpZiAocmVzcG9uc2Uuc3RhdHVzID09PSA0MDEpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgQWJvcnRFcnJvcihyZXN1bHQuZXJyb3IubWVzc2FnZSlcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IocmVzdWx0LmVycm9yLm1lc3NhZ2UpXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0LnZhbHVlLmNpZFxuICAgICAgICAgIH0sXG4gICAgICAgICAge1xuICAgICAgICAgICAgcmV0cmllczogbWF4UmV0cmllcyA9PSBudWxsID8gTUFYX1NUT1JFX1JFVFJJRVMgOiBtYXhSZXRyaWVzLFxuICAgICAgICAgIH1cbiAgICAgICAgKVxuICAgICAgICBvblN0b3JlZENodW5rICYmIG9uU3RvcmVkQ2h1bmsoY2FyRmlsZS5zaXplKVxuICAgICAgICByZXR1cm4gY2lkXG4gICAgICB9XG4gICAgKVxuXG4gICAgbGV0IHJvb3RcbiAgICBmb3IgYXdhaXQgKGNvbnN0IGNpZCBvZiB1cGxvYWQoc3BsaXR0ZXIuY2FycygpKSkge1xuICAgICAgcm9vdCA9IGNpZFxuICAgIH1cblxuICAgIHJldHVybiAvKiogQHR5cGUge0NJRFN0cmluZ30gKi8gKHJvb3QpXG4gIH1cblxuICAvKipcbiAgICogU3RvcmVzIGEgZGlyZWN0b3J5IG9mIGZpbGVzIGFuZCByZXR1cm5zIGEgQ0lELiBQcm92aWRlZCBmaWxlcyAqKk1VU1QqKlxuICAgKiBiZSB3aXRoaW4gdGhlIHNhbWUgZGlyZWN0b3J5LCBvdGhlcndpc2UgZXJyb3IgaXMgcmFpc2VkIGUuZy4gYGZvby9iYXIucG5nYCxcbiAgICogYGZvby9ibGEvYmF6Lmpzb25gIGlzIG9rIGJ1dCBgZm9vL2Jhci5wbmdgLCBgYmxhL2Jhei5qc29uYCBpcyBub3QuXG4gICAqXG4gICAqIEBwYXJhbSB7U2VydmljZX0gc2VydmljZVxuICAgKiBAcGFyYW0ge0ZpbGVzU291cmNlfSBmaWxlc1NvdXJjZVxuICAgKiBAcGFyYW0ge1JlcXVlc3RPcHRpb25zfSBbb3B0aW9uc11cbiAgICogQHJldHVybnMge1Byb21pc2U8Q0lEU3RyaW5nPn1cbiAgICovXG4gIHN0YXRpYyBhc3luYyBzdG9yZURpcmVjdG9yeShzZXJ2aWNlLCBmaWxlc1NvdXJjZSwgb3B0aW9ucykge1xuICAgIGNvbnN0IGJsb2Nrc3RvcmUgPSBuZXcgQmxvY2tzdG9yZSgpXG4gICAgbGV0IGNpZFN0cmluZ1xuICAgIHRyeSB7XG4gICAgICBjb25zdCB7IGNpZCwgY2FyIH0gPSBhd2FpdCBORlRTdG9yYWdlLmVuY29kZURpcmVjdG9yeShmaWxlc1NvdXJjZSwge1xuICAgICAgICBibG9ja3N0b3JlLFxuICAgICAgfSlcbiAgICAgIGF3YWl0IE5GVFN0b3JhZ2Uuc3RvcmVDYXIoc2VydmljZSwgY2FyLCBvcHRpb25zKVxuICAgICAgY2lkU3RyaW5nID0gY2lkLnRvU3RyaW5nKClcbiAgICB9IGZpbmFsbHkge1xuICAgICAgYXdhaXQgYmxvY2tzdG9yZS5jbG9zZSgpXG4gICAgfVxuXG4gICAgcmV0dXJuIGNpZFN0cmluZ1xuICB9XG5cbiAgLyoqXG4gICAqIFN0b3JlcyB0aGUgZ2l2ZW4gdG9rZW4gYW5kIGFsbCByZXNvdXJjZXMgaXQgcmVmZXJlbmNlcyAoaW4gdGhlIGZvcm0gb2YgYVxuICAgKiBGaWxlIG9yIGEgQmxvYikgYWxvbmcgd2l0aCBhIG1ldGFkYXRhIEpTT04gYXMgc3BlY2lmaWNlZCBpbiBFUkMtMTE1NS4gVGhlXG4gICAqIGB0b2tlbi5pbWFnZWAgbXVzdCBiZSBlaXRoZXIgYSBgRmlsZWAgb3IgYSBgQmxvYmAgaW5zdGFuY2UsIHdoaWNoIHdpbGwgYmVcbiAgICogc3RvcmVkIGFuZCB0aGUgY29ycmVzcG9uZGluZyBjb250ZW50IGFkZHJlc3MgVVJMIHdpbGwgYmUgc2F2ZWQgaW4gdGhlXG4gICAqIG1ldGFkYXRhIEpTT04gZmlsZSB1bmRlciBgaW1hZ2VgIGZpZWxkLlxuICAgKlxuICAgKiBJZiBgdG9rZW4ucHJvcGVydGllc2AgY29udGFpbnMgcHJvcGVydGllcyB3aXRoIGBGaWxlYCBvciBgQmxvYmAgdmFsdWVzLFxuICAgKiB0aG9zZSBhbHNvIGdldCBzdG9yZWQgYW5kIHRoZWlyIFVSTHMgd2lsbCBiZSBzYXZlZCBpbiB0aGUgbWV0YWRhdGEgSlNPTlxuICAgKiBmaWxlIGluIHRoZWlyIHBsYWNlLlxuICAgKlxuICAgKiBOb3RlOiBVUkxzIGZvciBgRmlsZWAgb2JqZWN0cyB3aWxsIHJldGFpbiBmaWxlIG5hbWVzIGUuZy4gaW4gY2FzZSBvZlxuICAgKiBgbmV3IEZpbGUoW2J5dGVzXSwgJ2NhdC5wbmcnLCB7IHR5cGU6ICdpbWFnZS9wbmcnIH0pYCB3aWxsIGJlIHRyYW5zZm9ybWVkXG4gICAqIGludG8gYSBVUkwgdGhhdCBsb29rcyBsaWtlIGBpcGZzOi8vYmFmeS4uLmhhc2gvaW1hZ2UvY2F0LnBuZ2AuIEZvciBgQmxvYmBcbiAgICogb2JqZWN0cywgdGhlIFVSTCB3aWxsIG5vdCBoYXZlIGEgZmlsZSBuYW1lIG5hbWUgb3IgbWltZSB0eXBlLCBpbnN0ZWFkIGl0XG4gICAqIHdpbGwgYmUgdHJhbnNmb3JtZWQgaW50byBhIFVSTCB0aGF0IGxvb2tzIGxpa2VcbiAgICogYGlwZnM6Ly9iYWZ5Li4uaGFzaC9pbWFnZS9ibG9iYC5cbiAgICpcbiAgICogQHRlbXBsYXRlIHtpbXBvcnQoJy4vbGliL2ludGVyZmFjZS5qcycpLlRva2VuSW5wdXR9IFRcbiAgICogQHBhcmFtIHtTZXJ2aWNlfSBzZXJ2aWNlXG4gICAqIEBwYXJhbSB7VH0gbWV0YWRhdGFcbiAgICogQHBhcmFtIHtSZXF1ZXN0T3B0aW9uc30gW29wdGlvbnNdXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPFRva2VuVHlwZTxUPj59XG4gICAqL1xuICBzdGF0aWMgYXN5bmMgc3RvcmUoc2VydmljZSwgbWV0YWRhdGEsIG9wdGlvbnMpIHtcbiAgICBjb25zdCB7IHRva2VuLCBjYXIgfSA9IGF3YWl0IE5GVFN0b3JhZ2UuZW5jb2RlTkZUKG1ldGFkYXRhKVxuICAgIGF3YWl0IE5GVFN0b3JhZ2Uuc3RvcmVDYXIoc2VydmljZSwgY2FyLCBvcHRpb25zKVxuICAgIHJldHVybiB0b2tlblxuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgY3VycmVudCBzdGF0dXMgb2YgdGhlIHN0b3JlZCBORlQgYnkgaXRzIENJRC4gTm90ZSB0aGUgTkZUIG11c3RcbiAgICogaGF2ZSBwcmV2aW91c2x5IGJlZW4gc3RvcmVkIGJ5IHRoaXMgYWNjb3VudC5cbiAgICpcbiAgICogQHBhcmFtIHtTZXJ2aWNlfSBzZXJ2aWNlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBjaWRcbiAgICogQHBhcmFtIHtSZXF1ZXN0T3B0aW9uc30gW29wdGlvbnNdXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPGltcG9ydCgnLi9saWIvaW50ZXJmYWNlLmpzJykuU3RhdHVzUmVzdWx0Pn1cbiAgICovXG4gIHN0YXRpYyBhc3luYyBzdGF0dXMoXG4gICAgeyBlbmRwb2ludCwgcmF0ZUxpbWl0ZXIgPSBnbG9iYWxSYXRlTGltaXRlciwgLi4udG9rZW4gfSxcbiAgICBjaWQsXG4gICAgb3B0aW9uc1xuICApIHtcbiAgICBjb25zdCB1cmwgPSBuZXcgVVJMKGAke2NpZH0vYCwgZW5kcG9pbnQpXG4gICAgYXdhaXQgcmF0ZUxpbWl0ZXIoKVxuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2godXJsLnRvU3RyaW5nKCksIHtcbiAgICAgIG1ldGhvZDogJ0dFVCcsXG4gICAgICBoZWFkZXJzOiBORlRTdG9yYWdlLmF1dGgodG9rZW4pLFxuICAgICAgc2lnbmFsOiBvcHRpb25zICYmIG9wdGlvbnMuc2lnbmFsLFxuICAgIH0pXG4gICAgLyogYzggaWdub3JlIG5leHQgMyAqL1xuICAgIGlmIChyZXNwb25zZS5zdGF0dXMgPT09IDQyOSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdyYXRlIGxpbWl0ZWQnKVxuICAgIH1cbiAgICBjb25zdCByZXN1bHQgPSBhd2FpdCByZXNwb25zZS5qc29uKClcblxuICAgIGlmIChyZXN1bHQub2spIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGNpZDogcmVzdWx0LnZhbHVlLmNpZCxcbiAgICAgICAgZGVhbHM6IGRlY29kZURlYWxzKHJlc3VsdC52YWx1ZS5kZWFscyksXG4gICAgICAgIHNpemU6IHJlc3VsdC52YWx1ZS5zaXplLFxuICAgICAgICBwaW46IGRlY29kZVBpbihyZXN1bHQudmFsdWUucGluKSxcbiAgICAgICAgY3JlYXRlZDogbmV3IERhdGUocmVzdWx0LnZhbHVlLmNyZWF0ZWQpLFxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IocmVzdWx0LmVycm9yLm1lc3NhZ2UpXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIENoZWNrIGlmIGEgQ0lEIG9mIGFuIE5GVCBpcyBiZWluZyBzdG9yZWQgYnkgTkZULlN0b3JhZ2UuXG4gICAqXG4gICAqIEBwYXJhbSB7aW1wb3J0KCcuL2xpYi9pbnRlcmZhY2UuanMnKS5QdWJsaWNTZXJ2aWNlfSBzZXJ2aWNlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBjaWRcbiAgICogQHBhcmFtIHtSZXF1ZXN0T3B0aW9uc30gW29wdGlvbnNdXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPGltcG9ydCgnLi9saWIvaW50ZXJmYWNlLmpzJykuQ2hlY2tSZXN1bHQ+fVxuICAgKi9cbiAgc3RhdGljIGFzeW5jIGNoZWNrKFxuICAgIHsgZW5kcG9pbnQsIHJhdGVMaW1pdGVyID0gZ2xvYmFsUmF0ZUxpbWl0ZXIgfSxcbiAgICBjaWQsXG4gICAgb3B0aW9uc1xuICApIHtcbiAgICBjb25zdCB1cmwgPSBuZXcgVVJMKGBjaGVjay8ke2NpZH0vYCwgZW5kcG9pbnQpXG4gICAgYXdhaXQgcmF0ZUxpbWl0ZXIoKVxuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2godXJsLnRvU3RyaW5nKCksIHtcbiAgICAgIHNpZ25hbDogb3B0aW9ucyAmJiBvcHRpb25zLnNpZ25hbCxcbiAgICB9KVxuICAgIC8qIGM4IGlnbm9yZSBuZXh0IDMgKi9cbiAgICBpZiAocmVzcG9uc2Uuc3RhdHVzID09PSA0MjkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcigncmF0ZSBsaW1pdGVkJylcbiAgICB9XG4gICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgcmVzcG9uc2UuanNvbigpXG5cbiAgICBpZiAocmVzdWx0Lm9rKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBjaWQ6IHJlc3VsdC52YWx1ZS5jaWQsXG4gICAgICAgIGRlYWxzOiBkZWNvZGVEZWFscyhyZXN1bHQudmFsdWUuZGVhbHMpLFxuICAgICAgICBwaW46IHJlc3VsdC52YWx1ZS5waW4sXG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihyZXN1bHQuZXJyb3IubWVzc2FnZSlcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogUmVtb3ZlcyBzdG9yZWQgY29udGVudCBieSBpdHMgQ0lEIGZyb20gdGhpcyBhY2NvdW50LiBQbGVhc2Ugbm90ZSB0aGF0XG4gICAqIGV2ZW4gaWYgY29udGVudCBpcyByZW1vdmVkIGZyb20gdGhlIHNlcnZpY2Ugb3RoZXIgbm9kZXMgdGhhdCBoYXZlXG4gICAqIHJlcGxpY2F0ZWQgaXQgbWlnaHQgc3RpbGwgY29udGludWUgcHJvdmlkaW5nIGl0LlxuICAgKlxuICAgKiBAcGFyYW0ge1NlcnZpY2V9IHNlcnZpY2VcbiAgICogQHBhcmFtIHtzdHJpbmd9IGNpZFxuICAgKiBAcGFyYW0ge1JlcXVlc3RPcHRpb25zfSBbb3B0aW9uc11cbiAgICogQHJldHVybnMge1Byb21pc2U8dm9pZD59XG4gICAqL1xuICBzdGF0aWMgYXN5bmMgZGVsZXRlKFxuICAgIHsgZW5kcG9pbnQsIHJhdGVMaW1pdGVyID0gZ2xvYmFsUmF0ZUxpbWl0ZXIsIC4uLnRva2VuIH0sXG4gICAgY2lkLFxuICAgIG9wdGlvbnNcbiAgKSB7XG4gICAgY29uc3QgdXJsID0gbmV3IFVSTChgJHtjaWR9L2AsIGVuZHBvaW50KVxuICAgIGF3YWl0IHJhdGVMaW1pdGVyKClcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKHVybC50b1N0cmluZygpLCB7XG4gICAgICBtZXRob2Q6ICdERUxFVEUnLFxuICAgICAgaGVhZGVyczogTkZUU3RvcmFnZS5hdXRoKHRva2VuKSxcbiAgICAgIHNpZ25hbDogb3B0aW9ucyAmJiBvcHRpb25zLnNpZ25hbCxcbiAgICB9KVxuICAgIC8qIGM4IGlnbm9yZSBuZXh0IDMgKi9cbiAgICBpZiAocmVzcG9uc2Uuc3RhdHVzID09PSA0MjkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcigncmF0ZSBsaW1pdGVkJylcbiAgICB9XG4gICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgcmVzcG9uc2UuanNvbigpXG4gICAgaWYgKCFyZXN1bHQub2spIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihyZXN1bHQuZXJyb3IubWVzc2FnZSlcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogRW5jb2RlcyB0aGUgZ2l2ZW4gdG9rZW4gYW5kIGFsbCByZXNvdXJjZXMgaXQgcmVmZXJlbmNlcyAoaW4gdGhlIGZvcm0gb2YgYVxuICAgKiBGaWxlIG9yIGEgQmxvYikgYWxvbmcgd2l0aCBhIG1ldGFkYXRhIEpTT04gYXMgc3BlY2lmaWNlZCBpbiBFUkMtMTE1NSB0byBhXG4gICAqIENBUiBmaWxlLiBUaGUgYHRva2VuLmltYWdlYCBtdXN0IGJlIGVpdGhlciBhIGBGaWxlYCBvciBhIGBCbG9iYCBpbnN0YW5jZSxcbiAgICogd2hpY2ggd2lsbCBiZSBzdG9yZWQgYW5kIHRoZSBjb3JyZXNwb25kaW5nIGNvbnRlbnQgYWRkcmVzcyBVUkwgd2lsbCBiZVxuICAgKiBzYXZlZCBpbiB0aGUgbWV0YWRhdGEgSlNPTiBmaWxlIHVuZGVyIGBpbWFnZWAgZmllbGQuXG4gICAqXG4gICAqIElmIGB0b2tlbi5wcm9wZXJ0aWVzYCBjb250YWlucyBwcm9wZXJ0aWVzIHdpdGggYEZpbGVgIG9yIGBCbG9iYCB2YWx1ZXMsXG4gICAqIHRob3NlIGFsc28gZ2V0IHN0b3JlZCBhbmQgdGhlaXIgVVJMcyB3aWxsIGJlIHNhdmVkIGluIHRoZSBtZXRhZGF0YSBKU09OXG4gICAqIGZpbGUgaW4gdGhlaXIgcGxhY2UuXG4gICAqXG4gICAqIE5vdGU6IFVSTHMgZm9yIGBGaWxlYCBvYmplY3RzIHdpbGwgcmV0YWluIGZpbGUgbmFtZXMgZS5nLiBpbiBjYXNlIG9mXG4gICAqIGBuZXcgRmlsZShbYnl0ZXNdLCAnY2F0LnBuZycsIHsgdHlwZTogJ2ltYWdlL3BuZycgfSlgIHdpbGwgYmUgdHJhbnNmb3JtZWRcbiAgICogaW50byBhIFVSTCB0aGF0IGxvb2tzIGxpa2UgYGlwZnM6Ly9iYWZ5Li4uaGFzaC9pbWFnZS9jYXQucG5nYC4gRm9yIGBCbG9iYFxuICAgKiBvYmplY3RzLCB0aGUgVVJMIHdpbGwgbm90IGhhdmUgYSBmaWxlIG5hbWUgbmFtZSBvciBtaW1lIHR5cGUsIGluc3RlYWQgaXRcbiAgICogd2lsbCBiZSB0cmFuc2Zvcm1lZCBpbnRvIGEgVVJMIHRoYXQgbG9va3MgbGlrZVxuICAgKiBgaXBmczovL2JhZnkuLi5oYXNoL2ltYWdlL2Jsb2JgLlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBgYGBqc1xuICAgKiBjb25zdCB7IHRva2VuLCBjYXIgfSA9IGF3YWl0IE5GVFN0b3JhZ2UuZW5jb2RlTkZUKHtcbiAgICogICBuYW1lOiAnbmZ0LnN0b3JhZ2Ugc3RvcmUgdGVzdCcsXG4gICAqICAgZGVzY3JpcHRpb246ICdUZXN0IEVSQy0xMTU1IGNvbXBhdGlibGUgbWV0YWRhdGEuJyxcbiAgICogICBpbWFnZTogbmV3IEZpbGUoWyc8REFUQT4nXSwgJ3BpbnBpZS5qcGcnLCB7IHR5cGU6ICdpbWFnZS9qcGcnIH0pLFxuICAgKiAgIHByb3BlcnRpZXM6IHtcbiAgICogICAgIGN1c3RvbTogJ0N1c3RvbSBkYXRhIGNhbiBhcHBlYXIgaGVyZSwgZmlsZXMgYXJlIGF1dG8gdXBsb2FkZWQuJyxcbiAgICogICAgIGZpbGU6IG5ldyBGaWxlKFsnPERBVEE+J10sICdSRUFETUUubWQnLCB7IHR5cGU6ICd0ZXh0L3BsYWluJyB9KSxcbiAgICogICB9XG4gICAqIH0pXG4gICAqXG4gICAqIGNvbnNvbGUubG9nKCdJUEZTIFVSTCBmb3IgdGhlIG1ldGFkYXRhOicsIHRva2VuLnVybClcbiAgICogY29uc29sZS5sb2coJ21ldGFkYXRhLmpzb24gY29udGVudHM6XFxuJywgdG9rZW4uZGF0YSlcbiAgICogY29uc29sZS5sb2coJ21ldGFkYXRhLmpzb24gd2l0aCBJUEZTIGdhdGV3YXkgVVJMczpcXG4nLCB0b2tlbi5lbWJlZCgpKVxuICAgKlxuICAgKiAvLyBOb3cgc3RvcmUgdGhlIENBUiBmaWxlIG9uIE5GVC5TdG9yYWdlXG4gICAqIGF3YWl0IGNsaWVudC5zdG9yZUNhcihjYXIpXG4gICAqIGBgYFxuICAgKlxuICAgKiBAdGVtcGxhdGUge2ltcG9ydCgnLi9saWIvaW50ZXJmYWNlLmpzJykuVG9rZW5JbnB1dH0gVFxuICAgKiBAcGFyYW0ge1R9IGlucHV0XG4gICAqIEByZXR1cm5zIHtQcm9taXNlPHsgY2lkOiBDSUQsIHRva2VuOiBUb2tlblR5cGU8VD4sIGNhcjogQ2FyUmVhZGVyIH0+fVxuICAgKi9cbiAgc3RhdGljIGFzeW5jIGVuY29kZU5GVChpbnB1dCkge1xuICAgIHZhbGlkYXRlRVJDMTE1NShpbnB1dClcbiAgICByZXR1cm4gVG9rZW4uVG9rZW4uZW5jb2RlKGlucHV0KVxuICB9XG5cbiAgLyoqXG4gICAqIEVuY29kZXMgYSBzaW5nbGUgZmlsZSB0byBhIENBUiBmaWxlIGFuZCBhbHNvIHJldHVybnMgaXRzIHJvb3QgQ0lELlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBgYGBqc1xuICAgKiBjb25zdCBjb250ZW50ID0gbmV3IEJsb2IoWydoZWxsbyB3b3JsZCddKVxuICAgKiBjb25zdCB7IGNpZCwgY2FyIH0gPSBhd2FpdCBORlRTdG9yYWdlLmVuY29kZUJsb2IoY29udGVudClcbiAgICpcbiAgICogLy8gUm9vdCBDSUQgb2YgdGhlIGZpbGVcbiAgICogY29uc29sZS5sb2coY2lkLnRvU3RyaW5nKCkpXG4gICAqXG4gICAqIC8vIE5vdyBzdG9yZSB0aGUgQ0FSIGZpbGUgb24gTkZULlN0b3JhZ2VcbiAgICogYXdhaXQgY2xpZW50LnN0b3JlQ2FyKGNhcilcbiAgICogYGBgXG4gICAqXG4gICAqIEBwYXJhbSB7QmxvYn0gYmxvYlxuICAgKiBAcGFyYW0ge29iamVjdH0gW29wdGlvbnNdXG4gICAqIEBwYXJhbSB7QmxvY2tzdG9yZUl9IFtvcHRpb25zLmJsb2Nrc3RvcmVdXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPHsgY2lkOiBDSUQsIGNhcjogQ2FyUmVhZGVyIH0+fVxuICAgKi9cbiAgc3RhdGljIGFzeW5jIGVuY29kZUJsb2IoYmxvYiwgeyBibG9ja3N0b3JlIH0gPSB7fSkge1xuICAgIGlmIChibG9iLnNpemUgPT09IDApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignQ29udGVudCBzaXplIGlzIDAsIG1ha2Ugc3VyZSB0byBwcm92aWRlIHNvbWUgY29udGVudCcpXG4gICAgfVxuICAgIHJldHVybiBwYWNrQ2FyKFt0b0ltcG9ydENhbmRpZGF0ZSgnYmxvYicsIGJsb2IpXSwge1xuICAgICAgYmxvY2tzdG9yZSxcbiAgICAgIHdyYXBXaXRoRGlyZWN0b3J5OiBmYWxzZSxcbiAgICB9KVxuICB9XG5cbiAgLyoqXG4gICAqIEVuY29kZXMgYSBkaXJlY3Rvcnkgb2YgZmlsZXMgdG8gYSBDQVIgZmlsZSBhbmQgYWxzbyByZXR1cm5zIHRoZSByb290IENJRC5cbiAgICogUHJvdmlkZWQgZmlsZXMgKipNVVNUKiogYmUgd2l0aGluIHRoZSBzYW1lIGRpcmVjdG9yeSwgb3RoZXJ3aXNlIGVycm9yIGlzXG4gICAqIHJhaXNlZCBlLmcuIGBmb28vYmFyLnBuZ2AsIGBmb28vYmxhL2Jhei5qc29uYCBpcyBvayBidXQgYGZvby9iYXIucG5nYCxcbiAgICogYGJsYS9iYXouanNvbmAgaXMgbm90LlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBgYGBqc1xuICAgKiBjb25zdCB7IGNpZCwgY2FyIH0gPSBhd2FpdCBORlRTdG9yYWdlLmVuY29kZURpcmVjdG9yeShbXG4gICAqICAgbmV3IEZpbGUoWydoZWxsbyB3b3JsZCddLCAnaGVsbG8udHh0JyksXG4gICAqICAgbmV3IEZpbGUoW0pTT04uc3RyaW5naWZ5KHsnZnJvbSc6ICdpbmNvZ25pdG8nfSwgbnVsbCwgMildLCAnbWV0YWRhdGEuanNvbicpXG4gICAqIF0pXG4gICAqXG4gICAqIC8vIFJvb3QgQ0lEIG9mIHRoZSBkaXJlY3RvcnlcbiAgICogY29uc29sZS5sb2coY2lkLnRvU3RyaW5nKCkpXG4gICAqXG4gICAqIC8vIE5vdyBzdG9yZSB0aGUgQ0FSIGZpbGUgb24gTkZULlN0b3JhZ2VcbiAgICogYXdhaXQgY2xpZW50LnN0b3JlQ2FyKGNhcilcbiAgICogYGBgXG4gICAqXG4gICAqIEBwYXJhbSB7RmlsZXNTb3VyY2V9IGZpbGVzXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBbb3B0aW9uc11cbiAgICogQHBhcmFtIHtCbG9ja3N0b3JlSX0gW29wdGlvbnMuYmxvY2tzdG9yZV1cbiAgICogQHJldHVybnMge1Byb21pc2U8eyBjaWQ6IENJRCwgY2FyOiBDYXJSZWFkZXIgfT59XG4gICAqL1xuICBzdGF0aWMgYXN5bmMgZW5jb2RlRGlyZWN0b3J5KGZpbGVzLCB7IGJsb2Nrc3RvcmUgfSA9IHt9KSB7XG4gICAgbGV0IHNpemUgPSAwXG4gICAgY29uc3QgaW5wdXQgPSBwaXBlKGZpbGVzLCBhc3luYyBmdW5jdGlvbiogKGZpbGVzKSB7XG4gICAgICBmb3IgYXdhaXQgKGNvbnN0IGZpbGUgb2YgZmlsZXMpIHtcbiAgICAgICAgeWllbGQgdG9JbXBvcnRDYW5kaWRhdGUoZmlsZS5uYW1lLCBmaWxlKVxuICAgICAgICBzaXplICs9IGZpbGUuc2l6ZVxuICAgICAgfVxuICAgIH0pXG4gICAgY29uc3QgcGFja2VkID0gYXdhaXQgcGFja0NhcihpbnB1dCwge1xuICAgICAgYmxvY2tzdG9yZSxcbiAgICAgIHdyYXBXaXRoRGlyZWN0b3J5OiB0cnVlLFxuICAgIH0pXG4gICAgaWYgKHNpemUgPT09IDApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgJ1RvdGFsIHNpemUgb2YgZmlsZXMgc2hvdWxkIGV4Y2VlZCAwLCBtYWtlIHN1cmUgdG8gcHJvdmlkZSBzb21lIGNvbnRlbnQnXG4gICAgICApXG4gICAgfVxuICAgIHJldHVybiBwYWNrZWRcbiAgfVxuXG4gIC8vIEp1c3QgYSBzdWdhciBzbyB5b3UgZG9uJ3QgaGF2ZSB0byBwYXNzIGFyb3VuZCBlbmRwb2ludCBhbmQgdG9rZW4gYXJvdW5kLlxuXG4gIC8qKlxuICAgKiBTdG9yZXMgYSBzaW5nbGUgZmlsZSBhbmQgcmV0dXJucyB0aGUgY29ycmVzcG9uZGluZyBDb250ZW50IElkZW50aWZpZXIgKENJRCkuXG4gICAqIFRha2VzIGEgW0Jsb2JdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9CbG9iL0Jsb2IpXG4gICAqIG9yIGEgW0ZpbGVdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9GaWxlKS4gTm90ZVxuICAgKiB0aGF0IG5vIGZpbGUgbmFtZSBvciBmaWxlIG1ldGFkYXRhIGlzIHJldGFpbmVkLlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBgYGBqc1xuICAgKiBjb25zdCBjb250ZW50ID0gbmV3IEJsb2IoWydoZWxsbyB3b3JsZCddKVxuICAgKiBjb25zdCBjaWQgPSBhd2FpdCBjbGllbnQuc3RvcmVCbG9iKGNvbnRlbnQpXG4gICAqIGNpZCAvLz4gJ3pkajdXbjlGUUFVUkNQNk1id2NXdXppN3U2NWtBc1hDZGpOVGtoYkpjb2FYQnVzcTknXG4gICAqIGBgYFxuICAgKlxuICAgKiBAcGFyYW0ge0Jsb2J9IGJsb2JcbiAgICogQHBhcmFtIHtSZXF1ZXN0T3B0aW9uc30gW29wdGlvbnNdXG4gICAqL1xuICBzdG9yZUJsb2IoYmxvYiwgb3B0aW9ucykge1xuICAgIHJldHVybiBORlRTdG9yYWdlLnN0b3JlQmxvYih0aGlzLCBibG9iLCBvcHRpb25zKVxuICB9XG5cbiAgLyoqXG4gICAqIFN0b3JlcyBmaWxlcyBlbmNvZGVkIGFzIGEgc2luZ2xlIFtDb250ZW50IEFkZHJlc3NlZCBBcmNoaXZlXG4gICAqIChDQVIpXShodHRwczovL2dpdGh1Yi5jb20vaXBsZC9zcGVjcy9ibG9iL21hc3Rlci9ibG9jay1sYXllci9jb250ZW50LWFkZHJlc3NhYmxlLWFyY2hpdmVzLm1kKS5cbiAgICpcbiAgICogVGFrZXMgYSBbQmxvYl0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0Jsb2IvQmxvYilcbiAgICogb3IgYSBbRmlsZV0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0ZpbGUpLlxuICAgKlxuICAgKiBSZXR1cm5zIHRoZSBjb3JyZXNwb25kaW5nIENvbnRlbnQgSWRlbnRpZmllciAoQ0lEKS5cbiAgICpcbiAgICogU2VlIHRoZSBbYGlwZnMtY2FyYCBkb2NzXShodHRwczovL3d3dy5ucG1qcy5jb20vcGFja2FnZS9pcGZzLWNhcikgZm9yIG1vcmVcbiAgICogZGV0YWlscyBvbiBwYWNraW5nIGEgQ0FSIGZpbGUuXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIGBgYGpzXG4gICAqIGltcG9ydCB7IHBhY2sgfSBmcm9tICdpcGZzLWNhci9wYWNrJ1xuICAgKiBpbXBvcnQgeyBDYXJSZWFkZXIgfSBmcm9tICdAaXBsZC9jYXInXG4gICAqIGNvbnN0IHsgb3V0LCByb290IH0gPSBhd2FpdCBwYWNrKHtcbiAgICogIGlucHV0OiBmcy5jcmVhdGVSZWFkU3RyZWFtKCdwaW5waWUucGRmJylcbiAgICogfSlcbiAgICogY29uc3QgZXhwZWN0ZWRDaWQgPSByb290LnRvU3RyaW5nKClcbiAgICogY29uc3QgY2FyUmVhZGVyID0gYXdhaXQgQ2FyUmVhZGVyLmZyb21JdGVyYWJsZShvdXQpXG4gICAqIGNvbnN0IGNpZCA9IGF3YWl0IHN0b3JhZ2Uuc3RvcmVDYXIoY2FyUmVhZGVyKVxuICAgKiBjb25zb2xlLmFzc2VydChjaWQgPT09IGV4cGVjdGVkQ2lkKVxuICAgKiBgYGBcbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogYGBgXG4gICAqIGltcG9ydCB7IHBhY2tUb0Jsb2IgfSBmcm9tICdpcGZzLWNhci9wYWNrL2Jsb2InXG4gICAqIGNvbnN0IGRhdGEgPSAnSGVsbG8gd29ybGQnXG4gICAqIGNvbnN0IHsgcm9vdCwgY2FyIH0gPSBhd2FpdCBwYWNrVG9CbG9iKHsgaW5wdXQ6IFtuZXcgVGV4dEVuY29kZXIoKS5lbmNvZGUoZGF0YSldIH0pXG4gICAqIGNvbnN0IGV4cGVjdGVkQ2lkID0gcm9vdC50b1N0cmluZygpXG4gICAqIGNvbnN0IGNpZCA9IGF3YWl0IGNsaWVudC5zdG9yZUNhcihjYXIpXG4gICAqIGNvbnNvbGUuYXNzZXJ0KGNpZCA9PT0gZXhwZWN0ZWRDaWQpXG4gICAqIGBgYFxuICAgKiBAcGFyYW0ge0Jsb2J8Q2FyUmVhZGVyfSBjYXJcbiAgICogQHBhcmFtIHtpbXBvcnQoJy4vbGliL2ludGVyZmFjZS5qcycpLkNhclN0b3Jlck9wdGlvbnN9IFtvcHRpb25zXVxuICAgKi9cbiAgc3RvcmVDYXIoY2FyLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIE5GVFN0b3JhZ2Uuc3RvcmVDYXIodGhpcywgY2FyLCBvcHRpb25zKVxuICB9XG5cbiAgLyoqXG4gICAqIFN0b3JlcyBhIGRpcmVjdG9yeSBvZiBmaWxlcyBhbmQgcmV0dXJucyBhIENJRCBmb3IgdGhlIGRpcmVjdG9yeS5cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogYGBganNcbiAgICogY29uc3QgY2lkID0gYXdhaXQgY2xpZW50LnN0b3JlRGlyZWN0b3J5KFtcbiAgICogICBuZXcgRmlsZShbJ2hlbGxvIHdvcmxkJ10sICdoZWxsby50eHQnKSxcbiAgICogICBuZXcgRmlsZShbSlNPTi5zdHJpbmdpZnkoeydmcm9tJzogJ2luY29nbml0byd9LCBudWxsLCAyKV0sICdtZXRhZGF0YS5qc29uJylcbiAgICogXSlcbiAgICogY2lkIC8vPlxuICAgKiBgYGBcbiAgICpcbiAgICogQXJndW1lbnQgY2FuIGJlIGEgW0ZpbGVMaXN0XShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvRmlsZUxpc3QpXG4gICAqIGluc3RhbmNlIGFzIHdlbGwsIGluIHdoaWNoIGNhc2UgZGlyZWN0b3J5IHN0cnVjdHVyZSB3aWxsIGJlIHJldGFpbmVkLlxuICAgKlxuICAgKiBAcGFyYW0ge0ZpbGVzU291cmNlfSBmaWxlc1xuICAgKiBAcGFyYW0ge1JlcXVlc3RPcHRpb25zfSBbb3B0aW9uc11cbiAgICovXG4gIHN0b3JlRGlyZWN0b3J5KGZpbGVzLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIE5GVFN0b3JhZ2Uuc3RvcmVEaXJlY3RvcnkodGhpcywgZmlsZXMsIG9wdGlvbnMpXG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBjdXJyZW50IHN0YXR1cyBvZiB0aGUgc3RvcmVkIE5GVCBieSBpdHMgQ0lELiBOb3RlIHRoZSBORlQgbXVzdFxuICAgKiBoYXZlIHByZXZpb3VzbHkgYmVlbiBzdG9yZWQgYnkgdGhpcyBhY2NvdW50LlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBgYGBqc1xuICAgKiBjb25zdCBzdGF0dXMgPSBhd2FpdCBjbGllbnQuc3RhdHVzKCd6ZGo3V245RlFBVVJDUDZNYndjV3V6aTd1NjVrQXNYQ2RqTlRraGJKY29hWEJ1c3E5JylcbiAgICogYGBgXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBjaWRcbiAgICogQHBhcmFtIHtSZXF1ZXN0T3B0aW9uc30gW29wdGlvbnNdXG4gICAqL1xuICBzdGF0dXMoY2lkLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIE5GVFN0b3JhZ2Uuc3RhdHVzKHRoaXMsIGNpZCwgb3B0aW9ucylcbiAgfVxuXG4gIC8qKlxuICAgKiBSZW1vdmVzIHN0b3JlZCBjb250ZW50IGJ5IGl0cyBDSUQgZnJvbSB0aGUgc2VydmljZS5cbiAgICpcbiAgICogPiBQbGVhc2Ugbm90ZSB0aGF0IGV2ZW4gaWYgY29udGVudCBpcyByZW1vdmVkIGZyb20gdGhlIHNlcnZpY2Ugb3RoZXIgbm9kZXNcbiAgICogdGhhdCBoYXZlIHJlcGxpY2F0ZWQgaXQgbWlnaHQgc3RpbGwgY29udGludWUgcHJvdmlkaW5nIGl0LlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBgYGBqc1xuICAgKiBhd2FpdCBjbGllbnQuZGVsZXRlKCd6ZGo3V245RlFBVVJDUDZNYndjV3V6aTd1NjVrQXNYQ2RqTlRraGJKY29hWEJ1c3E5JylcbiAgICogYGBgXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBjaWRcbiAgICogQHBhcmFtIHtSZXF1ZXN0T3B0aW9uc30gW29wdGlvbnNdXG4gICAqL1xuICBkZWxldGUoY2lkLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIE5GVFN0b3JhZ2UuZGVsZXRlKHRoaXMsIGNpZCwgb3B0aW9ucylcbiAgfVxuXG4gIC8qKlxuICAgKiBDaGVjayBpZiBhIENJRCBvZiBhbiBORlQgaXMgYmVpbmcgc3RvcmVkIGJ5IG5mdC5zdG9yYWdlLiBUaHJvd3MgaWYgdGhlIE5GVFxuICAgKiB3YXMgbm90IGZvdW5kLlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBgYGBqc1xuICAgKiBjb25zdCBzdGF0dXMgPSBhd2FpdCBjbGllbnQuY2hlY2soJ3pkajdXbjlGUUFVUkNQNk1id2NXdXppN3U2NWtBc1hDZGpOVGtoYkpjb2FYQnVzcTknKVxuICAgKiBgYGBcbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IGNpZFxuICAgKiBAcGFyYW0ge1JlcXVlc3RPcHRpb25zfSBbb3B0aW9uc11cbiAgICovXG4gIGNoZWNrKGNpZCwgb3B0aW9ucykge1xuICAgIHJldHVybiBORlRTdG9yYWdlLmNoZWNrKHRoaXMsIGNpZCwgb3B0aW9ucylcbiAgfVxuXG4gIC8qKlxuICAgKiBTdG9yZXMgdGhlIGdpdmVuIHRva2VuIGFuZCBhbGwgcmVzb3VyY2VzIGl0IHJlZmVyZW5jZXMgKGluIHRoZSBmb3JtIG9mIGFcbiAgICogRmlsZSBvciBhIEJsb2IpIGFsb25nIHdpdGggYSBtZXRhZGF0YSBKU09OIGFzIHNwZWNpZmljZWQgaW5cbiAgICogW0VSQy0xMTU1XShodHRwczovL2VpcHMuZXRoZXJldW0ub3JnL0VJUFMvZWlwLTExNTUjbWV0YWRhdGEpLiBUaGVcbiAgICogYHRva2VuLmltYWdlYCBtdXN0IGJlIGVpdGhlciBhIGBGaWxlYCBvciBhIGBCbG9iYCBpbnN0YW5jZSwgd2hpY2ggd2lsbCBiZVxuICAgKiBzdG9yZWQgYW5kIHRoZSBjb3JyZXNwb25kaW5nIGNvbnRlbnQgYWRkcmVzcyBVUkwgd2lsbCBiZSBzYXZlZCBpbiB0aGVcbiAgICogbWV0YWRhdGEgSlNPTiBmaWxlIHVuZGVyIGBpbWFnZWAgZmllbGQuXG4gICAqXG4gICAqIElmIGB0b2tlbi5wcm9wZXJ0aWVzYCBjb250YWlucyBwcm9wZXJ0aWVzIHdpdGggYEZpbGVgIG9yIGBCbG9iYCB2YWx1ZXMsXG4gICAqIHRob3NlIGFsc28gZ2V0IHN0b3JlZCBhbmQgdGhlaXIgVVJMcyB3aWxsIGJlIHNhdmVkIGluIHRoZSBtZXRhZGF0YSBKU09OXG4gICAqIGZpbGUgaW4gdGhlaXIgcGxhY2UuXG4gICAqXG4gICAqIE5vdGU6IFVSTHMgZm9yIGBGaWxlYCBvYmplY3RzIHdpbGwgcmV0YWluIGZpbGUgbmFtZXMgZS5nLiBpbiBjYXNlIG9mXG4gICAqIGBuZXcgRmlsZShbYnl0ZXNdLCAnY2F0LnBuZycsIHsgdHlwZTogJ2ltYWdlL3BuZycgfSlgIHdpbGwgYmUgdHJhbnNmb3JtZWRcbiAgICogaW50byBhIFVSTCB0aGF0IGxvb2tzIGxpa2UgYGlwZnM6Ly9iYWZ5Li4uaGFzaC9pbWFnZS9jYXQucG5nYC4gRm9yIGBCbG9iYFxuICAgKiBvYmplY3RzLCB0aGUgVVJMIHdpbGwgbm90IGhhdmUgYSBmaWxlIG5hbWUgbmFtZSBvciBtaW1lIHR5cGUsIGluc3RlYWQgaXRcbiAgICogd2lsbCBiZSB0cmFuc2Zvcm1lZCBpbnRvIGEgVVJMIHRoYXQgbG9va3MgbGlrZVxuICAgKiBgaXBmczovL2JhZnkuLi5oYXNoL2ltYWdlL2Jsb2JgLlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBgYGBqc1xuICAgKiBjb25zdCBtZXRhZGF0YSA9IGF3YWl0IGNsaWVudC5zdG9yZSh7XG4gICAqICAgbmFtZTogJ25mdC5zdG9yYWdlIHN0b3JlIHRlc3QnLFxuICAgKiAgIGRlc2NyaXB0aW9uOiAnVGVzdCBFUkMtMTE1NSBjb21wYXRpYmxlIG1ldGFkYXRhLicsXG4gICAqICAgaW1hZ2U6IG5ldyBGaWxlKFsnPERBVEE+J10sICdwaW5waWUuanBnJywgeyB0eXBlOiAnaW1hZ2UvanBnJyB9KSxcbiAgICogICBwcm9wZXJ0aWVzOiB7XG4gICAqICAgICBjdXN0b206ICdDdXN0b20gZGF0YSBjYW4gYXBwZWFyIGhlcmUsIGZpbGVzIGFyZSBhdXRvIHVwbG9hZGVkLicsXG4gICAqICAgICBmaWxlOiBuZXcgRmlsZShbJzxEQVRBPiddLCAnUkVBRE1FLm1kJywgeyB0eXBlOiAndGV4dC9wbGFpbicgfSksXG4gICAqICAgfVxuICAgKiB9KVxuICAgKlxuICAgKiBjb25zb2xlLmxvZygnSVBGUyBVUkwgZm9yIHRoZSBtZXRhZGF0YTonLCBtZXRhZGF0YS51cmwpXG4gICAqIGNvbnNvbGUubG9nKCdtZXRhZGF0YS5qc29uIGNvbnRlbnRzOlxcbicsIG1ldGFkYXRhLmRhdGEpXG4gICAqIGNvbnNvbGUubG9nKCdtZXRhZGF0YS5qc29uIHdpdGggSVBGUyBnYXRld2F5IFVSTHM6XFxuJywgbWV0YWRhdGEuZW1iZWQoKSlcbiAgICogYGBgXG4gICAqXG4gICAqIEB0ZW1wbGF0ZSB7aW1wb3J0KCcuL2xpYi9pbnRlcmZhY2UuanMnKS5Ub2tlbklucHV0fSBUXG4gICAqIEBwYXJhbSB7VH0gdG9rZW5cbiAgICogQHBhcmFtIHtSZXF1ZXN0T3B0aW9uc30gW29wdGlvbnNdXG4gICAqL1xuICBzdG9yZSh0b2tlbiwgb3B0aW9ucykge1xuICAgIHJldHVybiBORlRTdG9yYWdlLnN0b3JlKHRoaXMsIHRva2VuLCBvcHRpb25zKVxuICB9XG59XG5cbi8qKlxuICogQ2FzdCBhbiBpdGVyYWJsZSB0byBhbiBhc3luY0l0ZXJhYmxlXG4gKiBAdGVtcGxhdGUgVFxuICogQHBhcmFtIHtJdGVyYWJsZTxUPn0gaXRlcmFibGVcbiAqIEByZXR1cm5zIHtBc3luY0l0ZXJhYmxlPFQ+fVxuICovXG5leHBvcnQgZnVuY3Rpb24gdG9Bc3luY0l0ZXJhYmxlKGl0ZXJhYmxlKSB7XG4gIHJldHVybiAoYXN5bmMgZnVuY3Rpb24qICgpIHtcbiAgICBmb3IgKGNvbnN0IGl0ZW0gb2YgaXRlcmFibGUpIHtcbiAgICAgIHlpZWxkIGl0ZW1cbiAgICB9XG4gIH0pKClcbn1cblxuLyoqXG4gKiBAdGVtcGxhdGUge2ltcG9ydCgnLi9saWIvaW50ZXJmYWNlLmpzJykuVG9rZW5JbnB1dH0gVFxuICogQHBhcmFtIHtUfSBtZXRhZGF0YVxuICovXG5jb25zdCB2YWxpZGF0ZUVSQzExNTUgPSAoeyBuYW1lLCBkZXNjcmlwdGlvbiwgaW1hZ2UsIGRlY2ltYWxzIH0pID0+IHtcbiAgLy8gSnVzdCB2YWxpZGF0ZSB0aGF0IGV4cGVjdGVkIGZpZWxkcyBhcmUgcHJlc2VudFxuICBpZiAodHlwZW9mIG5hbWUgIT09ICdzdHJpbmcnKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgICdzdHJpbmcgcHJvcGVydHkgYG5hbWVgIGlkZW50aWZ5aW5nIHRoZSBhc3NldCBpcyByZXF1aXJlZCdcbiAgICApXG4gIH1cbiAgaWYgKHR5cGVvZiBkZXNjcmlwdGlvbiAhPT0gJ3N0cmluZycpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgJ3N0cmluZyBwcm9wZXJ0eSBgZGVzY3JpcHRpb25gIGRlc2NyaWJpbmcgYXNzZXQgaXMgcmVxdWlyZWQnXG4gICAgKVxuICB9XG4gIGlmICghKGltYWdlIGluc3RhbmNlb2YgQmxvYikpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdwcm9wZXJ0eSBgaW1hZ2VgIG11c3QgYmUgYSBCbG9iIG9yIEZpbGUgb2JqZWN0JylcbiAgfSBlbHNlIGlmICghaW1hZ2UudHlwZS5zdGFydHNXaXRoKCdpbWFnZS8nKSkge1xuICAgIGNvbnNvbGUud2FybihgQWNjb3JkaW5nIHRvIEVSQzcyMSBNZXRhZGF0YSBKU09OIFNjaGVtYSAnaW1hZ2UnIG11c3QgaGF2ZSAnaW1hZ2UvKicgbWltZSB0eXBlLlxuXG5Gb3IgYmV0dGVyIGludGVyb3BlcmFiaWxpdHkgd2Ugd291bGQgaGlnaGx5IHJlY29tbWVuZCBzdG9yaW5nIGNvbnRlbnQgd2l0aCBkaWZmZXJlbnQgbWltZSB0eXBlIHVuZGVyICdwcm9wZXJ0aWVzJyBuYW1lc3BhY2UgZS5nLiBcXGBwcm9wZXJ0aWVzOiB7IHZpZGVvOiBmaWxlIH1cXGAgYW5kIHVzaW5nICdpbWFnZScgZmllbGQgZm9yIHN0b3JpbmcgYSBwcmV2aWV3IGltYWdlIGZvciBpdCBpbnN0ZWFkLlxuXG5Gb3IgbW9yZSBjb250ZXh0IHBsZWFzZSBzZWUgRVJDLTcyMSBzcGVjaWZpY2F0aW9uIGh0dHBzOi8vZWlwcy5ldGhlcmV1bS5vcmcvRUlQUy9laXAtNzIxYClcbiAgfVxuXG4gIGlmICh0eXBlb2YgZGVjaW1hbHMgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiBkZWNpbWFscyAhPT0gJ251bWJlcicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdwcm9wZXJ0eSBgZGVjaW1hbHNgIG11c3QgYmUgYW4gaW50ZWdlciB2YWx1ZScpXG4gIH1cbn1cblxuLyoqXG4gKiBAcGFyYW0ge2ltcG9ydCgnaXBmcy1jYXIvcGFjaycpLkltcG9ydENhbmRpZGF0ZVN0cmVhbXxBcnJheTx7IHBhdGg6IHN0cmluZywgY29udGVudDogaW1wb3J0KCcuL3BsYXRmb3JtLmpzJykuUmVhZGFibGVTdHJlYW0gfT59IGlucHV0XG4gKiBAcGFyYW0ge29iamVjdH0gW29wdGlvbnNdXG4gKiBAcGFyYW0ge0Jsb2Nrc3RvcmVJfSBbb3B0aW9ucy5ibG9ja3N0b3JlXVxuICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy53cmFwV2l0aERpcmVjdG9yeV1cbiAqL1xuY29uc3QgcGFja0NhciA9IGFzeW5jIChpbnB1dCwgeyBibG9ja3N0b3JlLCB3cmFwV2l0aERpcmVjdG9yeSB9ID0ge30pID0+IHtcbiAgLyogYzggaWdub3JlIG5leHQgMSAqL1xuICBibG9ja3N0b3JlID0gYmxvY2tzdG9yZSB8fCBuZXcgQmxvY2tzdG9yZSgpXG4gIGNvbnN0IHsgcm9vdDogY2lkIH0gPSBhd2FpdCBwYWNrKHsgaW5wdXQsIGJsb2Nrc3RvcmUsIHdyYXBXaXRoRGlyZWN0b3J5IH0pXG4gIGNvbnN0IGNhciA9IG5ldyBCbG9ja3N0b3JlQ2FyUmVhZGVyKDEsIFtjaWRdLCBibG9ja3N0b3JlKVxuICByZXR1cm4geyBjaWQsIGNhciB9XG59XG5cbi8qKlxuICogQHBhcmFtIHtEZWFsW119IGRlYWxzXG4gKiBAcmV0dXJucyB7RGVhbFtdfVxuICovXG5jb25zdCBkZWNvZGVEZWFscyA9IChkZWFscykgPT5cbiAgZGVhbHMubWFwKChkZWFsKSA9PiB7XG4gICAgY29uc3QgeyBkZWFsQWN0aXZhdGlvbiwgZGVhbEV4cGlyYXRpb24sIGxhc3RDaGFuZ2VkIH0gPSB7XG4gICAgICBkZWFsRXhwaXJhdGlvbjogbnVsbCxcbiAgICAgIGRlYWxBY3RpdmF0aW9uOiBudWxsLFxuICAgICAgLi4uZGVhbCxcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgLi4uZGVhbCxcbiAgICAgIGxhc3RDaGFuZ2VkOiBuZXcgRGF0ZShsYXN0Q2hhbmdlZCksXG4gICAgICAuLi4oZGVhbEFjdGl2YXRpb24gJiYgeyBkZWFsQWN0aXZhdGlvbjogbmV3IERhdGUoZGVhbEFjdGl2YXRpb24pIH0pLFxuICAgICAgLi4uKGRlYWxFeHBpcmF0aW9uICYmIHsgZGVhbEV4cGlyYXRpb246IG5ldyBEYXRlKGRlYWxFeHBpcmF0aW9uKSB9KSxcbiAgICB9XG4gIH0pXG5cbi8qKlxuICogQHBhcmFtIHtQaW59IHBpblxuICogQHJldHVybnMge1Bpbn1cbiAqL1xuY29uc3QgZGVjb2RlUGluID0gKHBpbikgPT4gKHsgLi4ucGluLCBjcmVhdGVkOiBuZXcgRGF0ZShwaW4uY3JlYXRlZCkgfSlcblxuLyoqXG4gKiBDb252ZXJ0IHRoZSBwYXNzZWQgYmxvYiB0byBhbiBcImltcG9ydCBjYW5kaWRhdGVcIiAtIGFuIG9iamVjdCBzdWl0YWJsZSBmb3JcbiAqIHBhc3NpbmcgdG8gdGhlIGlwZnMtdW5peGZzLWltcG9ydGVyLiBOb3RlOiBjb250ZW50IGlzIGFuIGFjY2Vzc29yIHNvIHRoYXRcbiAqIHRoZSBzdHJlYW0gaXMgY3JlYXRlZCBvbmx5IHdoZW4gbmVlZGVkLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBwYXRoXG4gKiBAcGFyYW0ge1BpY2s8QmxvYiwgJ3N0cmVhbSc+fHsgc3RyZWFtOiAoKSA9PiBBc3luY0l0ZXJhYmxlPFVpbnQ4QXJyYXk+IH19IGJsb2JcbiAqIEByZXR1cm5zIHtpbXBvcnQoJ2lwZnMtY29yZS10eXBlcy9zcmMvdXRpbHMuanMnKS5JbXBvcnRDYW5kaWRhdGV9XG4gKi9cbmZ1bmN0aW9uIHRvSW1wb3J0Q2FuZGlkYXRlKHBhdGgsIGJsb2IpIHtcbiAgLyoqIEB0eXBlIHtBc3luY0l0ZXJhYmxlPFVpbnQ4QXJyYXk+fSAqL1xuICBsZXQgc3RyZWFtXG4gIHJldHVybiB7XG4gICAgcGF0aCxcbiAgICBnZXQgY29udGVudCgpIHtcbiAgICAgIHN0cmVhbSA9IHN0cmVhbSB8fCBibG9iLnN0cmVhbSgpXG4gICAgICByZXR1cm4gc3RyZWFtXG4gICAgfSxcbiAgfVxufVxuXG5leHBvcnQgeyBORlRTdG9yYWdlLCBGaWxlLCBCbG9iLCBGb3JtRGF0YSwgdG9HYXRld2F5VVJMLCBUb2tlbiB9XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/nft.storage/src/lib.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/nft.storage/src/platform.js":
/*!**************************************************!*\
  !*** ./node_modules/nft.storage/src/platform.js ***!
  \**************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Blob: () => (/* reexport safe */ _web_std_file__WEBPACK_IMPORTED_MODULE_2__.Blob),\n/* harmony export */   Blockstore: () => (/* reexport safe */ ipfs_car_blockstore_fs__WEBPACK_IMPORTED_MODULE_3__.FsBlockStore),\n/* harmony export */   File: () => (/* reexport safe */ _web_std_file__WEBPACK_IMPORTED_MODULE_2__.File),\n/* harmony export */   FormData: () => (/* reexport safe */ _web_std_form_data__WEBPACK_IMPORTED_MODULE_0__.FormData),\n/* harmony export */   Headers: () => (/* reexport safe */ _web_std_fetch__WEBPACK_IMPORTED_MODULE_4__.Headers),\n/* harmony export */   ReadableStream: () => (/* reexport safe */ _web_std_blob__WEBPACK_IMPORTED_MODULE_1__.ReadableStream),\n/* harmony export */   Request: () => (/* reexport safe */ _web_std_fetch__WEBPACK_IMPORTED_MODULE_4__.Request),\n/* harmony export */   Response: () => (/* reexport safe */ _web_std_fetch__WEBPACK_IMPORTED_MODULE_4__.Response),\n/* harmony export */   fetch: () => (/* reexport safe */ _web_std_fetch__WEBPACK_IMPORTED_MODULE_4__[\"default\"])\n/* harmony export */ });\n/* harmony import */ var _web_std_fetch__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @web-std/fetch */ \"(ssr)/./node_modules/@web-std/fetch/src/lib.node.js\");\n/* harmony import */ var _web_std_form_data__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @web-std/form-data */ \"(ssr)/./node_modules/@web-std/form-data/src/lib.node.js\");\n/* harmony import */ var _web_std_blob__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @web-std/blob */ \"(ssr)/./node_modules/@web-std/blob/src/lib.node.js\");\n/* harmony import */ var _web_std_file__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @web-std/file */ \"(ssr)/./node_modules/@web-std/file/src/lib.node.js\");\n/* harmony import */ var ipfs_car_blockstore_fs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ipfs-car/blockstore/fs */ \"(ssr)/./node_modules/ipfs-car/dist/esm/blockstore/fs.js\");\n\n\n\n\n\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbmZ0LnN0b3JhZ2Uvc3JjL3BsYXRmb3JtLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQWtFO0FBQ3JCO0FBQ0M7QUFDSjtBQUN5Qjs7QUFZbEUiLCJzb3VyY2VzIjpbIi9ob21lL2FsdGNvaW4tZGFkZHkvRG93bmxvYWRzL293bmx5L25vZGVfbW9kdWxlcy9uZnQuc3RvcmFnZS9zcmMvcGxhdGZvcm0uanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IGZldGNoLCB7IFJlcXVlc3QsIFJlc3BvbnNlLCBIZWFkZXJzIH0gZnJvbSAnQHdlYi1zdGQvZmV0Y2gnXG5pbXBvcnQgeyBGb3JtRGF0YSB9IGZyb20gJ0B3ZWItc3RkL2Zvcm0tZGF0YSdcbmltcG9ydCB7IFJlYWRhYmxlU3RyZWFtIH0gZnJvbSAnQHdlYi1zdGQvYmxvYidcbmltcG9ydCB7IEZpbGUsIEJsb2IgfSBmcm9tICdAd2ViLXN0ZC9maWxlJ1xuaW1wb3J0IHsgRnNCbG9ja1N0b3JlIGFzIEJsb2Nrc3RvcmUgfSBmcm9tICdpcGZzLWNhci9ibG9ja3N0b3JlL2ZzJ1xuXG5leHBvcnQge1xuICBmZXRjaCxcbiAgUmVxdWVzdCxcbiAgUmVzcG9uc2UsXG4gIEhlYWRlcnMsXG4gIEJsb2IsXG4gIEZvcm1EYXRhLFxuICBGaWxlLFxuICBSZWFkYWJsZVN0cmVhbSxcbiAgQmxvY2tzdG9yZSxcbn1cbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/nft.storage/src/platform.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/nft.storage/src/token.js":
/*!***********************************************!*\
  !*** ./node_modules/nft.storage/src/token.js ***!
  \***********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Token: () => (/* binding */ Token),\n/* harmony export */   decode: () => (/* binding */ decode),\n/* harmony export */   embed: () => (/* binding */ embed),\n/* harmony export */   encode: () => (/* binding */ encode),\n/* harmony export */   mapWith: () => (/* binding */ mapWith)\n/* harmony export */ });\n/* harmony import */ var ipfs_car_pack__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ipfs-car/pack */ \"(ssr)/./node_modules/ipfs-car/dist/esm/pack/index.js\");\n/* harmony import */ var multiformats_cid__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! multiformats/cid */ \"(ssr)/./node_modules/multiformats/esm/src/cid.js\");\n/* harmony import */ var multiformats_block__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! multiformats/block */ \"(ssr)/./node_modules/multiformats/esm/src/block.js\");\n/* harmony import */ var multiformats_hashes_sha2__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! multiformats/hashes/sha2 */ \"(ssr)/./node_modules/multiformats/esm/src/hashes/sha2.js\");\n/* harmony import */ var _ipld_dag_cbor__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @ipld/dag-cbor */ \"(ssr)/./node_modules/@ipld/dag-cbor/esm/index.js\");\n/* harmony import */ var _platform_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./platform.js */ \"(ssr)/./node_modules/nft.storage/src/platform.js\");\n/* harmony import */ var _gateway_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./gateway.js */ \"(ssr)/./node_modules/nft.storage/src/gateway.js\");\n/* harmony import */ var _bs_car_reader_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./bs-car-reader.js */ \"(ssr)/./node_modules/nft.storage/src/bs-car-reader.js\");\n\n\n\n\n\n\n\n\n\n/**\n * @typedef {import('./gateway.js').GatewayURLOptions} EmbedOptions\n * @typedef {import('./lib/interface.js').TokenInput} TokenInput\n * @typedef {import('ipfs-car/blockstore').Blockstore} Blockstore\n */\n\n/**\n * @template T\n * @typedef {import('./lib/interface.js').Encoded<T, [[Blob, URL]]>} EncodedBlobUrl\n */\n\n/**\n * @template G\n * @typedef {import('./lib/interface.js').Encoded<G, [[Blob, Blob]]>} EncodedBlobBlob\n */\n\n/**\n * @template {import('./lib/interface.js').TokenInput} T\n * @typedef {import('./lib/interface.js').Token<T>} TokenType\n */\n\n/**\n * @template {TokenInput} T\n * @implements {TokenType<T>}\n */\nclass Token {\n  /**\n   * @param {import('./lib/interface.js').CIDString} ipnft\n   * @param {import('./lib/interface.js').EncodedURL} url\n   * @param {import('./lib/interface.js').Encoded<T, [[Blob, URL]]>} data\n   */\n  constructor(ipnft, url, data) {\n    /** @readonly */\n    this.ipnft = ipnft\n    /** @readonly */\n    this.url = url\n    /** @readonly */\n    this.data = data\n\n    Object.defineProperties(this, {\n      ipnft: { enumerable: true, writable: false },\n      url: { enumerable: true, writable: false },\n      data: { enumerable: false, writable: false },\n    })\n  }\n  /**\n   * @returns {import('./lib/interface.js').Encoded<T, [[Blob, URL]]>}\n   */\n  embed() {\n    return Token.embed(this)\n  }\n\n  /**\n   * @template {TokenInput} T\n   * @param {{data: import('./lib/interface.js').Encoded<T, [[Blob, URL]]>}} token\n   * @returns {import('./lib/interface.js').Encoded<T, [[Blob, URL]]>}\n   */\n  static embed({ data }) {\n    return embed(data, { gateway: _gateway_js__WEBPACK_IMPORTED_MODULE_6__.GATEWAY })\n  }\n\n  /**\n   * Takes token input, encodes it as a DAG, wraps it in a CAR and creates a new\n   * Token instance from it. Where values are discovered `Blob` (or `File`)\n   * objects in the given input, they are replaced with IPFS URLs (an `ipfs://`\n   * prefixed CID with an optional path).\n   *\n   * @example\n   * ```js\n   * const cat = new File(['...'], 'cat.png')\n   * const kitty = new File(['...'], 'kitty.png')\n   * const { token, car } = await Token.encode({\n   *   name: 'hello'\n   *   image: cat\n   *   properties: {\n   *     extra: {\n   *       image: kitty\n   *     }\n   *   }\n   * })\n   * ```\n   *\n   * @template {TokenInput} T\n   * @param {T} input\n   * @returns {Promise<{ cid: CID, token: TokenType<T>, car: import('./lib/interface.js').CarReader }>}\n   */\n  static async encode(input) {\n    const blockstore = new _platform_js__WEBPACK_IMPORTED_MODULE_5__.Blockstore()\n    const [blobs, meta] = mapTokenInputBlobs(input)\n    /** @type {EncodedBlobUrl<T>} */\n    const data = JSON.parse(JSON.stringify(meta))\n    /** @type {import('./lib/interface.js').Encoded<T, [[Blob, CID]]>} */\n    const dag = JSON.parse(JSON.stringify(meta))\n\n    for (const [dotPath, blob] of blobs.entries()) {\n      /** @type {string|undefined} */\n      // @ts-ignore blob may be a File!\n      const name = blob.name || 'blob'\n      /** @type {import('./platform.js').ReadableStream} */\n      let content\n      // FIXME: should not be necessary to await arrayBuffer()!\n      // Node.js 20 hangs reading the stream (it never ends) but in\n      // older node versions and the browser it is fine to use blob.stream().\n      /* c8 ignore next 5 */\n      if (parseInt(globalThis.process?.versions?.node) > 18) {\n        content = new Uint8Array(await blob.arrayBuffer())\n      } else {\n        content = blob.stream()\n      }\n      const { root: cid } = await (0,ipfs_car_pack__WEBPACK_IMPORTED_MODULE_0__.pack)({\n        input: [{ path: name, content }],\n        blockstore,\n        wrapWithDirectory: true,\n      })\n\n      const href = new URL(`ipfs://${cid}/${name}`)\n      const path = dotPath.split('.')\n      setIn(data, path, href)\n      setIn(dag, path, cid)\n    }\n\n    const { root: metadataJsonCid } = await (0,ipfs_car_pack__WEBPACK_IMPORTED_MODULE_0__.pack)({\n      input: [{ path: 'metadata.json', content: JSON.stringify(data) }],\n      blockstore,\n      wrapWithDirectory: false,\n    })\n\n    const block = await multiformats_block__WEBPACK_IMPORTED_MODULE_2__.encode({\n      value: {\n        ...dag,\n        'metadata.json': metadataJsonCid,\n        type: 'nft',\n      },\n      codec: _ipld_dag_cbor__WEBPACK_IMPORTED_MODULE_4__,\n      hasher: multiformats_hashes_sha2__WEBPACK_IMPORTED_MODULE_3__.sha256,\n    })\n    await blockstore.put(block.cid, block.bytes)\n\n    return {\n      cid: block.cid,\n      token: new Token(\n        block.cid.toString(),\n        `ipfs://${block.cid}/metadata.json`,\n        data\n      ),\n      car: new _bs_car_reader_js__WEBPACK_IMPORTED_MODULE_7__.BlockstoreCarReader(1, [block.cid], blockstore),\n    }\n  }\n}\n\n/**\n * @template T\n * @param {EncodedBlobUrl<T>} input\n * @param {EmbedOptions} options\n * @returns {EncodedBlobUrl<T>}\n */\nconst embed = (input, options) =>\n  mapWith(input, isURL, embedURL, options)\n\n/**\n * @template {TokenInput} T\n * @param {import('./lib/interface.js').EncodedToken<T>} value\n * @param {Set<string>} paths - Paths were to expect EncodedURLs\n * @returns {Token<T>}\n */\nconst decode = ({ ipnft, url, data }, paths) =>\n  new Token(ipnft, url, mapWith(data, isEncodedURL, decodeURL, paths))\n\n/**\n * @param {any} value\n * @returns {value is URL}\n */\nconst isURL = (value) => value instanceof URL\n\n/**\n * @template State\n * @param {State} state\n * @param {import('./lib/interface.js').EncodedURL} url\n * @returns {[State, URL]}\n */\nconst decodeURL = (state, url) => [state, new URL(url)]\n\n/**\n * @param {EmbedOptions} context\n * @param {URL} url\n * @returns {[EmbedOptions, URL]}\n */\nconst embedURL = (context, url) => [context, (0,_gateway_js__WEBPACK_IMPORTED_MODULE_6__.toGatewayURL)(url, context)]\n\n/**\n * @param {any} value\n * @returns {value is object}\n */\nconst isObject = (value) => typeof value === 'object' && value != null\n\n/**\n * @param {any} value\n * @param {Set<string>} assetPaths\n * @param {PropertyKey[]} path\n * @returns {value is import('./lib/interface.js').EncodedURL}\n */\nconst isEncodedURL = (value, assetPaths, path) =>\n  typeof value === 'string' && assetPaths.has(path.join('.'))\n\n/**\n * Takes token input and encodes it into\n * [FormData](https://developer.mozilla.org/en-US/docs/Web/API/FormData)\n * object where form field values are discovered `Blob` (or `File`) objects in\n * the given token and field keys are `.` joined paths where they were discoverd\n * in the token. Additionally encoded `FormData` will also have a field\n * named `meta` containing JSON serialized token with blobs and file values\n * `null` set to null (this allows backend to injest all of the files from\n * `multipart/form-data` request and update provided \"meta\" data with\n * corresponding file ipfs:// URLs)\n *\n * @example\n * ```js\n * const cat = new File([], 'cat.png')\n * const kitty = new File([], 'kitty.png')\n * const form = encode({\n *   name: 'hello'\n *   image: cat\n *   properties: {\n *     extra: {\n *       image: kitty\n *     }\n *   }\n * })\n * [...form.entries()] //>\n * // [\n * //   ['image', cat],\n * //   ['properties.extra.image', kitty],\n * //   ['meta', '{\"name\":\"hello\",image:null,\"properties\":{\"extra\":{\"kitty\": null}}}']\n * // ]\n * ```\n *\n * @template {TokenInput} T\n * @param {EncodedBlobBlob<T>} input\n * @returns {FormData}\n */\nconst encode = (input) => {\n  const [map, meta] = mapValueWith(input, isBlob, encodeBlob, new Map(), [])\n  const form = new _platform_js__WEBPACK_IMPORTED_MODULE_5__.FormData()\n  for (const [k, v] of map.entries()) {\n    form.set(k, v)\n  }\n  form.set('meta', JSON.stringify(meta))\n  return form\n}\n\n/**\n * @param {Map<string, Blob>} data\n * @param {Blob} blob\n * @param {PropertyKey[]} path\n * @returns {[Map<string, Blob>, void]}\n */\nconst encodeBlob = (data, blob, path) => {\n  data.set(path.join('.'), blob)\n  return [data, undefined]\n}\n\n/**\n * @param {any} value\n * @returns {value is Blob}\n */\nconst isBlob = (value) => value instanceof _platform_js__WEBPACK_IMPORTED_MODULE_5__.Blob\n\n/**\n * @template {TokenInput} T\n * @param {EncodedBlobBlob<T>} input\n */\nconst mapTokenInputBlobs = (input) => {\n  return mapValueWith(input, isBlob, encodeBlob, new Map(), [])\n}\n\n/**\n * Substitues values in the given `input` that match `p(value) == true` with\n * `f(value, context, path)` where `context` is whatever you pass (usually\n * a mutable state) and `path` is a array of keys / indexes where the value\n * was encountered.\n *\n * @template T, I, X, O, State\n * @param {import('./lib/interface.js').Encoded<T, [[I, X]]>} input - Arbitrary input.\n * @param {(input:any, state:State, path:PropertyKey[]) => input is X} p - Predicate function to determine\n * which values to swap.\n * @param {(state:State, input:X, path:PropertyKey[]) => [State, O]} f - Function\n * that swaps matching values.\n * @param {State} state - Some additional context you need in the process.\n * likey you'll start with `[]`.\n * @returns {import('./lib/interface.js').Encoded<T, [[I, O]]>}\n */\nconst mapWith = (input, p, f, state) => {\n  const [, output] = mapValueWith(input, p, f, state, [])\n  return output\n}\n\n/**\n * @template T, I, X, O, State\n * @param {import('./lib/interface.js').Encoded<T, [[I, X]]>} input - Arbitrary input.\n * @param {(input:any, state:State, path:PropertyKey[]) => input is X} p - Predicate function to determine\n * which values to swap.\n * @param {(state:State, input:X, path:PropertyKey[]) => [State, O]} f - Function\n * that swaps matching values.\n * @param {State} state - Some additional context you need in the process.\n * @param {PropertyKey[]} path - Path where the value was encountered. Most\n * likey you'll start with `[]`.\n * @returns {[State, import('./lib/interface.js').Encoded<T, [[I, O]]>]}\n */\nconst mapValueWith = (input, p, f, state, path) =>\n  p(input, state, path)\n    ? f(state, input, path)\n    : Array.isArray(input)\n    ? mapArrayWith(input, p, f, state, path)\n    : isObject(input)\n    ? mapObjectWith(input, p, f, state, path)\n    : [state, /** @type {any} */ (input)]\n\n/**\n * Just like `mapWith` except\n *\n * @template State, T, I, X, O\n * @param {import('./lib/interface.js').Encoded<T, [[I, X]]>} input\n * @param {(input:any, state:State, path:PropertyKey[]) => input is X} p\n * @param {(state: State, input:X, path:PropertyKey[]) => [State, O]} f\n * @param {State} init\n * @param {PropertyKey[]} path\n * @returns {[State, import('./lib/interface.js').Encoded<T, [[I, O]]>]}\n */\nconst mapObjectWith = (input, p, f, init, path) => {\n  let state = init\n  const output =\n    /** @type {import('./lib/interface.js').Encoded<T, [[I, O]]>} */ ({})\n  for (const [key, value] of Object.entries(input)) {\n    const [next, out] = mapValueWith(value, p, f, state, [...path, key])\n    // @ts-ignore\n    output[key] = out\n    state = next\n  }\n  return [state, output]\n}\n\n/**\n * Just like `mapWith` except for Arrays.\n *\n * @template I, X, O, State\n * @template {any[]} T\n * @param {T} input\n * @param {(input:any, state:State, path:PropertyKey[]) => input is X} p\n * @param {(state: State, input:X, path:PropertyKey[]) => [State, O]} f\n * @param {State} init\n * @param {PropertyKey[]} path\n * @returns {[State, import('./lib/interface.js').Encoded<T, [[I, O]]>]}\n */\nconst mapArrayWith = (input, p, f, init, path) => {\n  const output = /** @type {unknown[]} */ ([])\n\n  let state = init\n  for (const [index, element] of input.entries()) {\n    const [next, out] = mapValueWith(element, p, f, state, [...path, index])\n    output[index] = out\n    state = next\n  }\n\n  return [\n    state,\n    /** @type {import('./lib/interface.js').Encoded<T, [[I, O]]>} */ (output),\n  ]\n}\n\n/**\n * Sets a given `value` at the given `path` on a passed `object`.\n *\n * @example\n * ```js\n * const obj = { a: { b: { c: 1 }}}\n * setIn(obj, ['a', 'b', 'c'], 5)\n * obj.a.b.c //> 5\n * ```\n *\n * @template V\n * @param {any} object\n * @param {string[]} path\n * @param {V} value\n */\nconst setIn = (object, path, value) => {\n  const n = path.length - 1\n  let target = object\n  for (let [index, key] of path.entries()) {\n    if (index === n) {\n      target[key] = value\n    } else {\n      target = target[key]\n    }\n  }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbmZ0LnN0b3JhZ2Uvc3JjL3Rva2VuLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBb0M7QUFDRTtBQUNLO0FBQ007QUFDUjtBQUNpQjtBQUNOO0FBQ0k7O0FBRXhEO0FBQ0EsYUFBYSwwQ0FBMEM7QUFDdkQsYUFBYSx5Q0FBeUM7QUFDdEQsYUFBYSwwQ0FBMEM7QUFDdkQ7O0FBRUE7QUFDQTtBQUNBLGFBQWEsd0RBQXdEO0FBQ3JFOztBQUVBO0FBQ0E7QUFDQSxhQUFhLHlEQUF5RDtBQUN0RTs7QUFFQTtBQUNBLGNBQWMseUNBQXlDO0FBQ3ZELGFBQWEsdUNBQXVDO0FBQ3BEOztBQUVBO0FBQ0EsY0FBYyxZQUFZO0FBQzFCLGdCQUFnQjtBQUNoQjtBQUNPO0FBQ1A7QUFDQSxhQUFhLHdDQUF3QztBQUNyRCxhQUFhLHlDQUF5QztBQUN0RCxhQUFhLHdEQUF3RDtBQUNyRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZUFBZSxtQ0FBbUM7QUFDbEQsYUFBYSxtQ0FBbUM7QUFDaEQsY0FBYyxvQ0FBb0M7QUFDbEQsS0FBSztBQUNMO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxnQkFBZ0IsWUFBWTtBQUM1QixjQUFjLCtEQUErRDtBQUM3RSxlQUFlO0FBQ2Y7QUFDQSxpQkFBaUIsTUFBTTtBQUN2Qix5QkFBeUIsU0FBUyxnREFBTyxFQUFFO0FBQzNDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxhQUFhO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxnQkFBZ0IsWUFBWTtBQUM1QixhQUFhLEdBQUc7QUFDaEIsZUFBZSxVQUFVLDRFQUE0RTtBQUNyRztBQUNBO0FBQ0EsMkJBQTJCLG9EQUFVO0FBQ3JDO0FBQ0Es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O0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixLQUFLOztBQUU5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsbURBQW1EO0FBQzlELFdBQVcsNERBQTREO0FBQ3ZFLFdBQVcsMkRBQTJEO0FBQ3RFLFdBQVcsT0FBTztBQUNsQixXQUFXLGVBQWU7QUFDMUIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxtREFBbUQsTUFBTTtBQUN4RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxPQUFPO0FBQ3JCLFdBQVcsR0FBRztBQUNkLFdBQVcsNERBQTREO0FBQ3ZFLFdBQVcsMkRBQTJEO0FBQ3RFLFdBQVcsT0FBTztBQUNsQixXQUFXLGVBQWU7QUFDMUIsYUFBYTtBQUNiO0FBQ0E7QUFDQSw0QkFBNEIsV0FBVzs7QUFFdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxlQUFlLG1EQUFtRDtBQUNsRTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsS0FBSyxLQUFLO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEtBQUs7QUFDaEIsV0FBVyxVQUFVO0FBQ3JCLFdBQVcsR0FBRztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyIvaG9tZS9hbHRjb2luLWRhZGR5L0Rvd25sb2Fkcy9vd25seS9ub2RlX21vZHVsZXMvbmZ0LnN0b3JhZ2Uvc3JjL3Rva2VuLmpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IHBhY2sgfSBmcm9tICdpcGZzLWNhci9wYWNrJ1xuaW1wb3J0IHsgQ0lEIH0gZnJvbSAnbXVsdGlmb3JtYXRzL2NpZCdcbmltcG9ydCAqIGFzIEJsb2NrIGZyb20gJ211bHRpZm9ybWF0cy9ibG9jaydcbmltcG9ydCB7IHNoYTI1NiB9IGZyb20gJ211bHRpZm9ybWF0cy9oYXNoZXMvc2hhMidcbmltcG9ydCAqIGFzIGRhZ0Nib3IgZnJvbSAnQGlwbGQvZGFnLWNib3InXG5pbXBvcnQgeyBCbG9iLCBGb3JtRGF0YSwgQmxvY2tzdG9yZSB9IGZyb20gJy4vcGxhdGZvcm0uanMnXG5pbXBvcnQgeyB0b0dhdGV3YXlVUkwsIEdBVEVXQVkgfSBmcm9tICcuL2dhdGV3YXkuanMnXG5pbXBvcnQgeyBCbG9ja3N0b3JlQ2FyUmVhZGVyIH0gZnJvbSAnLi9icy1jYXItcmVhZGVyLmpzJ1xuXG4vKipcbiAqIEB0eXBlZGVmIHtpbXBvcnQoJy4vZ2F0ZXdheS5qcycpLkdhdGV3YXlVUkxPcHRpb25zfSBFbWJlZE9wdGlvbnNcbiAqIEB0eXBlZGVmIHtpbXBvcnQoJy4vbGliL2ludGVyZmFjZS5qcycpLlRva2VuSW5wdXR9IFRva2VuSW5wdXRcbiAqIEB0eXBlZGVmIHtpbXBvcnQoJ2lwZnMtY2FyL2Jsb2Nrc3RvcmUnKS5CbG9ja3N0b3JlfSBCbG9ja3N0b3JlXG4gKi9cblxuLyoqXG4gKiBAdGVtcGxhdGUgVFxuICogQHR5cGVkZWYge2ltcG9ydCgnLi9saWIvaW50ZXJmYWNlLmpzJykuRW5jb2RlZDxULCBbW0Jsb2IsIFVSTF1dPn0gRW5jb2RlZEJsb2JVcmxcbiAqL1xuXG4vKipcbiAqIEB0ZW1wbGF0ZSBHXG4gKiBAdHlwZWRlZiB7aW1wb3J0KCcuL2xpYi9pbnRlcmZhY2UuanMnKS5FbmNvZGVkPEcsIFtbQmxvYiwgQmxvYl1dPn0gRW5jb2RlZEJsb2JCbG9iXG4gKi9cblxuLyoqXG4gKiBAdGVtcGxhdGUge2ltcG9ydCgnLi9saWIvaW50ZXJmYWNlLmpzJykuVG9rZW5JbnB1dH0gVFxuICogQHR5cGVkZWYge2ltcG9ydCgnLi9saWIvaW50ZXJmYWNlLmpzJykuVG9rZW48VD59IFRva2VuVHlwZVxuICovXG5cbi8qKlxuICogQHRlbXBsYXRlIHtUb2tlbklucHV0fSBUXG4gKiBAaW1wbGVtZW50cyB7VG9rZW5UeXBlPFQ+fVxuICovXG5leHBvcnQgY2xhc3MgVG9rZW4ge1xuICAvKipcbiAgICogQHBhcmFtIHtpbXBvcnQoJy4vbGliL2ludGVyZmFjZS5qcycpLkNJRFN0cmluZ30gaXBuZnRcbiAgICogQHBhcmFtIHtpbXBvcnQoJy4vbGliL2ludGVyZmFjZS5qcycpLkVuY29kZWRVUkx9IHVybFxuICAgKiBAcGFyYW0ge2ltcG9ydCgnLi9saWIvaW50ZXJmYWNlLmpzJykuRW5jb2RlZDxULCBbW0Jsb2IsIFVSTF1dPn0gZGF0YVxuICAgKi9cbiAgY29uc3RydWN0b3IoaXBuZnQsIHVybCwgZGF0YSkge1xuICAgIC8qKiBAcmVhZG9ubHkgKi9cbiAgICB0aGlzLmlwbmZ0ID0gaXBuZnRcbiAgICAvKiogQHJlYWRvbmx5ICovXG4gICAgdGhpcy51cmwgPSB1cmxcbiAgICAvKiogQHJlYWRvbmx5ICovXG4gICAgdGhpcy5kYXRhID0gZGF0YVxuXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXModGhpcywge1xuICAgICAgaXBuZnQ6IHsgZW51bWVyYWJsZTogdHJ1ZSwgd3JpdGFibGU6IGZhbHNlIH0sXG4gICAgICB1cmw6IHsgZW51bWVyYWJsZTogdHJ1ZSwgd3JpdGFibGU6IGZhbHNlIH0sXG4gICAgICBkYXRhOiB7IGVudW1lcmFibGU6IGZhbHNlLCB3cml0YWJsZTogZmFsc2UgfSxcbiAgICB9KVxuICB9XG4gIC8qKlxuICAgKiBAcmV0dXJucyB7aW1wb3J0KCcuL2xpYi9pbnRlcmZhY2UuanMnKS5FbmNvZGVkPFQsIFtbQmxvYiwgVVJMXV0+fVxuICAgKi9cbiAgZW1iZWQoKSB7XG4gICAgcmV0dXJuIFRva2VuLmVtYmVkKHRoaXMpXG4gIH1cblxuICAvKipcbiAgICogQHRlbXBsYXRlIHtUb2tlbklucHV0fSBUXG4gICAqIEBwYXJhbSB7e2RhdGE6IGltcG9ydCgnLi9saWIvaW50ZXJmYWNlLmpzJykuRW5jb2RlZDxULCBbW0Jsb2IsIFVSTF1dPn19IHRva2VuXG4gICAqIEByZXR1cm5zIHtpbXBvcnQoJy4vbGliL2ludGVyZmFjZS5qcycpLkVuY29kZWQ8VCwgW1tCbG9iLCBVUkxdXT59XG4gICAqL1xuICBzdGF0aWMgZW1iZWQoeyBkYXRhIH0pIHtcbiAgICByZXR1cm4gZW1iZWQoZGF0YSwgeyBnYXRld2F5OiBHQVRFV0FZIH0pXG4gIH1cblxuICAvKipcbiAgICogVGFrZXMgdG9rZW4gaW5wdXQsIGVuY29kZXMgaXQgYXMgYSBEQUcsIHdyYXBzIGl0IGluIGEgQ0FSIGFuZCBjcmVhdGVzIGEgbmV3XG4gICAqIFRva2VuIGluc3RhbmNlIGZyb20gaXQuIFdoZXJlIHZhbHVlcyBhcmUgZGlzY292ZXJlZCBgQmxvYmAgKG9yIGBGaWxlYClcbiAgICogb2JqZWN0cyBpbiB0aGUgZ2l2ZW4gaW5wdXQsIHRoZXkgYXJlIHJlcGxhY2VkIHdpdGggSVBGUyBVUkxzIChhbiBgaXBmczovL2BcbiAgICogcHJlZml4ZWQgQ0lEIHdpdGggYW4gb3B0aW9uYWwgcGF0aCkuXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIGBgYGpzXG4gICAqIGNvbnN0IGNhdCA9IG5ldyBGaWxlKFsnLi4uJ10sICdjYXQucG5nJylcbiAgICogY29uc3Qga2l0dHkgPSBuZXcgRmlsZShbJy4uLiddLCAna2l0dHkucG5nJylcbiAgICogY29uc3QgeyB0b2tlbiwgY2FyIH0gPSBhd2FpdCBUb2tlbi5lbmNvZGUoe1xuICAgKiAgIG5hbWU6ICdoZWxsbydcbiAgICogICBpbWFnZTogY2F0XG4gICAqICAgcHJvcGVydGllczoge1xuICAgKiAgICAgZXh0cmE6IHtcbiAgICogICAgICAgaW1hZ2U6IGtpdHR5XG4gICAqICAgICB9XG4gICAqICAgfVxuICAgKiB9KVxuICAgKiBgYGBcbiAgICpcbiAgICogQHRlbXBsYXRlIHtUb2tlbklucHV0fSBUXG4gICAqIEBwYXJhbSB7VH0gaW5wdXRcbiAgICogQHJldHVybnMge1Byb21pc2U8eyBjaWQ6IENJRCwgdG9rZW46IFRva2VuVHlwZTxUPiwgY2FyOiBpbXBvcnQoJy4vbGliL2ludGVyZmFjZS5qcycpLkNhclJlYWRlciB9Pn1cbiAgICovXG4gIHN0YXRpYyBhc3luYyBlbmNvZGUoaW5wdXQpIHtcbiAgICBjb25zdCBibG9ja3N0b3JlID0gbmV3IEJsb2Nrc3RvcmUoKVxuICAgIGNvbnN0IFtibG9icywgbWV0YV0gPSBtYXBUb2tlbklucHV0QmxvYnMoaW5wdXQpXG4gICAgLyoqIEB0eXBlIHtFbmNvZGVkQmxvYlVybDxUPn0gKi9cbiAgICBjb25zdCBkYXRhID0gSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeShtZXRhKSlcbiAgICAvKiogQHR5cGUge2ltcG9ydCgnLi9saWIvaW50ZXJmYWNlLmpzJykuRW5jb2RlZDxULCBbW0Jsb2IsIENJRF1dPn0gKi9cbiAgICBjb25zdCBkYWcgPSBKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KG1ldGEpKVxuXG4gICAgZm9yIChjb25zdCBbZG90UGF0aCwgYmxvYl0gb2YgYmxvYnMuZW50cmllcygpKSB7XG4gICAgICAvKiogQHR5cGUge3N0cmluZ3x1bmRlZmluZWR9ICovXG4gICAgICAvLyBAdHMtaWdub3JlIGJsb2IgbWF5IGJlIGEgRmlsZSFcbiAgICAgIGNvbnN0IG5hbWUgPSBibG9iLm5hbWUgfHwgJ2Jsb2InXG4gICAgICAvKiogQHR5cGUge2ltcG9ydCgnLi9wbGF0Zm9ybS5qcycpLlJlYWRhYmxlU3RyZWFtfSAqL1xuICAgICAgbGV0IGNvbnRlbnRcbiAgICAgIC8vIEZJWE1FOiBzaG91bGQgbm90IGJlIG5lY2Vzc2FyeSB0byBhd2FpdCBhcnJheUJ1ZmZlcigpIVxuICAgICAgLy8gTm9kZS5qcyAyMCBoYW5ncyByZWFkaW5nIHRoZSBzdHJlYW0gKGl0IG5ldmVyIGVuZHMpIGJ1dCBpblxuICAgICAgLy8gb2xkZXIgbm9kZSB2ZXJzaW9ucyBhbmQgdGhlIGJyb3dzZXIgaXQgaXMgZmluZSB0byB1c2UgYmxvYi5zdHJlYW0oKS5cbiAgICAgIC8qIGM4IGlnbm9yZSBuZXh0IDUgKi9cbiAgICAgIGlmIChwYXJzZUludChnbG9iYWxUaGlzLnByb2Nlc3M/LnZlcnNpb25zPy5ub2RlKSA+IDE4KSB7XG4gICAgICAgIGNvbnRlbnQgPSBuZXcgVWludDhBcnJheShhd2FpdCBibG9iLmFycmF5QnVmZmVyKCkpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb250ZW50ID0gYmxvYi5zdHJlYW0oKVxuICAgICAgfVxuICAgICAgY29uc3QgeyByb290OiBjaWQgfSA9IGF3YWl0IHBhY2soe1xuICAgICAgICBpbnB1dDogW3sgcGF0aDogbmFtZSwgY29udGVudCB9XSxcbiAgICAgICAgYmxvY2tzdG9yZSxcbiAgICAgICAgd3JhcFdpdGhEaXJlY3Rvcnk6IHRydWUsXG4gICAgICB9KVxuXG4gICAgICBjb25zdCBocmVmID0gbmV3IFVSTChgaXBmczovLyR7Y2lkfS8ke25hbWV9YClcbiAgICAgIGNvbnN0IHBhdGggPSBkb3RQYXRoLnNwbGl0KCcuJylcbiAgICAgIHNldEluKGRhdGEsIHBhdGgsIGhyZWYpXG4gICAgICBzZXRJbihkYWcsIHBhdGgsIGNpZClcbiAgICB9XG5cbiAgICBjb25zdCB7IHJvb3Q6IG1ldGFkYXRhSnNvbkNpZCB9ID0gYXdhaXQgcGFjayh7XG4gICAgICBpbnB1dDogW3sgcGF0aDogJ21ldGFkYXRhLmpzb24nLCBjb250ZW50OiBKU09OLnN0cmluZ2lmeShkYXRhKSB9XSxcbiAgICAgIGJsb2Nrc3RvcmUsXG4gICAgICB3cmFwV2l0aERpcmVjdG9yeTogZmFsc2UsXG4gICAgfSlcblxuICAgIGNvbnN0IGJsb2NrID0gYXdhaXQgQmxvY2suZW5jb2RlKHtcbiAgICAgIHZhbHVlOiB7XG4gICAgICAgIC4uLmRhZyxcbiAgICAgICAgJ21ldGFkYXRhLmpzb24nOiBtZXRhZGF0YUpzb25DaWQsXG4gICAgICAgIHR5cGU6ICduZnQnLFxuICAgICAgfSxcbiAgICAgIGNvZGVjOiBkYWdDYm9yLFxuICAgICAgaGFzaGVyOiBzaGEyNTYsXG4gICAgfSlcbiAgICBhd2FpdCBibG9ja3N0b3JlLnB1dChibG9jay5jaWQsIGJsb2NrLmJ5dGVzKVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIGNpZDogYmxvY2suY2lkLFxuICAgICAgdG9rZW46IG5ldyBUb2tlbihcbiAgICAgICAgYmxvY2suY2lkLnRvU3RyaW5nKCksXG4gICAgICAgIGBpcGZzOi8vJHtibG9jay5jaWR9L21ldGFkYXRhLmpzb25gLFxuICAgICAgICBkYXRhXG4gICAgICApLFxuICAgICAgY2FyOiBuZXcgQmxvY2tzdG9yZUNhclJlYWRlcigxLCBbYmxvY2suY2lkXSwgYmxvY2tzdG9yZSksXG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogQHRlbXBsYXRlIFRcbiAqIEBwYXJhbSB7RW5jb2RlZEJsb2JVcmw8VD59IGlucHV0XG4gKiBAcGFyYW0ge0VtYmVkT3B0aW9uc30gb3B0aW9uc1xuICogQHJldHVybnMge0VuY29kZWRCbG9iVXJsPFQ+fVxuICovXG5leHBvcnQgY29uc3QgZW1iZWQgPSAoaW5wdXQsIG9wdGlvbnMpID0+XG4gIG1hcFdpdGgoaW5wdXQsIGlzVVJMLCBlbWJlZFVSTCwgb3B0aW9ucylcblxuLyoqXG4gKiBAdGVtcGxhdGUge1Rva2VuSW5wdXR9IFRcbiAqIEBwYXJhbSB7aW1wb3J0KCcuL2xpYi9pbnRlcmZhY2UuanMnKS5FbmNvZGVkVG9rZW48VD59IHZhbHVlXG4gKiBAcGFyYW0ge1NldDxzdHJpbmc+fSBwYXRocyAtIFBhdGhzIHdlcmUgdG8gZXhwZWN0IEVuY29kZWRVUkxzXG4gKiBAcmV0dXJucyB7VG9rZW48VD59XG4gKi9cbmV4cG9ydCBjb25zdCBkZWNvZGUgPSAoeyBpcG5mdCwgdXJsLCBkYXRhIH0sIHBhdGhzKSA9PlxuICBuZXcgVG9rZW4oaXBuZnQsIHVybCwgbWFwV2l0aChkYXRhLCBpc0VuY29kZWRVUkwsIGRlY29kZVVSTCwgcGF0aHMpKVxuXG4vKipcbiAqIEBwYXJhbSB7YW55fSB2YWx1ZVxuICogQHJldHVybnMge3ZhbHVlIGlzIFVSTH1cbiAqL1xuY29uc3QgaXNVUkwgPSAodmFsdWUpID0+IHZhbHVlIGluc3RhbmNlb2YgVVJMXG5cbi8qKlxuICogQHRlbXBsYXRlIFN0YXRlXG4gKiBAcGFyYW0ge1N0YXRlfSBzdGF0ZVxuICogQHBhcmFtIHtpbXBvcnQoJy4vbGliL2ludGVyZmFjZS5qcycpLkVuY29kZWRVUkx9IHVybFxuICogQHJldHVybnMge1tTdGF0ZSwgVVJMXX1cbiAqL1xuY29uc3QgZGVjb2RlVVJMID0gKHN0YXRlLCB1cmwpID0+IFtzdGF0ZSwgbmV3IFVSTCh1cmwpXVxuXG4vKipcbiAqIEBwYXJhbSB7RW1iZWRPcHRpb25zfSBjb250ZXh0XG4gKiBAcGFyYW0ge1VSTH0gdXJsXG4gKiBAcmV0dXJucyB7W0VtYmVkT3B0aW9ucywgVVJMXX1cbiAqL1xuY29uc3QgZW1iZWRVUkwgPSAoY29udGV4dCwgdXJsKSA9PiBbY29udGV4dCwgdG9HYXRld2F5VVJMKHVybCwgY29udGV4dCldXG5cbi8qKlxuICogQHBhcmFtIHthbnl9IHZhbHVlXG4gKiBAcmV0dXJucyB7dmFsdWUgaXMgb2JqZWN0fVxuICovXG5jb25zdCBpc09iamVjdCA9ICh2YWx1ZSkgPT4gdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyAmJiB2YWx1ZSAhPSBudWxsXG5cbi8qKlxuICogQHBhcmFtIHthbnl9IHZhbHVlXG4gKiBAcGFyYW0ge1NldDxzdHJpbmc+fSBhc3NldFBhdGhzXG4gKiBAcGFyYW0ge1Byb3BlcnR5S2V5W119IHBhdGhcbiAqIEByZXR1cm5zIHt2YWx1ZSBpcyBpbXBvcnQoJy4vbGliL2ludGVyZmFjZS5qcycpLkVuY29kZWRVUkx9XG4gKi9cbmNvbnN0IGlzRW5jb2RlZFVSTCA9ICh2YWx1ZSwgYXNzZXRQYXRocywgcGF0aCkgPT5cbiAgdHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJyAmJiBhc3NldFBhdGhzLmhhcyhwYXRoLmpvaW4oJy4nKSlcblxuLyoqXG4gKiBUYWtlcyB0b2tlbiBpbnB1dCBhbmQgZW5jb2RlcyBpdCBpbnRvXG4gKiBbRm9ybURhdGFdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9Gb3JtRGF0YSlcbiAqIG9iamVjdCB3aGVyZSBmb3JtIGZpZWxkIHZhbHVlcyBhcmUgZGlzY292ZXJlZCBgQmxvYmAgKG9yIGBGaWxlYCkgb2JqZWN0cyBpblxuICogdGhlIGdpdmVuIHRva2VuIGFuZCBmaWVsZCBrZXlzIGFyZSBgLmAgam9pbmVkIHBhdGhzIHdoZXJlIHRoZXkgd2VyZSBkaXNjb3ZlcmRcbiAqIGluIHRoZSB0b2tlbi4gQWRkaXRpb25hbGx5IGVuY29kZWQgYEZvcm1EYXRhYCB3aWxsIGFsc28gaGF2ZSBhIGZpZWxkXG4gKiBuYW1lZCBgbWV0YWAgY29udGFpbmluZyBKU09OIHNlcmlhbGl6ZWQgdG9rZW4gd2l0aCBibG9icyBhbmQgZmlsZSB2YWx1ZXNcbiAqIGBudWxsYCBzZXQgdG8gbnVsbCAodGhpcyBhbGxvd3MgYmFja2VuZCB0byBpbmplc3QgYWxsIG9mIHRoZSBmaWxlcyBmcm9tXG4gKiBgbXVsdGlwYXJ0L2Zvcm0tZGF0YWAgcmVxdWVzdCBhbmQgdXBkYXRlIHByb3ZpZGVkIFwibWV0YVwiIGRhdGEgd2l0aFxuICogY29ycmVzcG9uZGluZyBmaWxlIGlwZnM6Ly8gVVJMcylcbiAqXG4gKiBAZXhhbXBsZVxuICogYGBganNcbiAqIGNvbnN0IGNhdCA9IG5ldyBGaWxlKFtdLCAnY2F0LnBuZycpXG4gKiBjb25zdCBraXR0eSA9IG5ldyBGaWxlKFtdLCAna2l0dHkucG5nJylcbiAqIGNvbnN0IGZvcm0gPSBlbmNvZGUoe1xuICogICBuYW1lOiAnaGVsbG8nXG4gKiAgIGltYWdlOiBjYXRcbiAqICAgcHJvcGVydGllczoge1xuICogICAgIGV4dHJhOiB7XG4gKiAgICAgICBpbWFnZToga2l0dHlcbiAqICAgICB9XG4gKiAgIH1cbiAqIH0pXG4gKiBbLi4uZm9ybS5lbnRyaWVzKCldIC8vPlxuICogLy8gW1xuICogLy8gICBbJ2ltYWdlJywgY2F0XSxcbiAqIC8vICAgWydwcm9wZXJ0aWVzLmV4dHJhLmltYWdlJywga2l0dHldLFxuICogLy8gICBbJ21ldGEnLCAne1wibmFtZVwiOlwiaGVsbG9cIixpbWFnZTpudWxsLFwicHJvcGVydGllc1wiOntcImV4dHJhXCI6e1wia2l0dHlcIjogbnVsbH19fSddXG4gKiAvLyBdXG4gKiBgYGBcbiAqXG4gKiBAdGVtcGxhdGUge1Rva2VuSW5wdXR9IFRcbiAqIEBwYXJhbSB7RW5jb2RlZEJsb2JCbG9iPFQ+fSBpbnB1dFxuICogQHJldHVybnMge0Zvcm1EYXRhfVxuICovXG5leHBvcnQgY29uc3QgZW5jb2RlID0gKGlucHV0KSA9PiB7XG4gIGNvbnN0IFttYXAsIG1ldGFdID0gbWFwVmFsdWVXaXRoKGlucHV0LCBpc0Jsb2IsIGVuY29kZUJsb2IsIG5ldyBNYXAoKSwgW10pXG4gIGNvbnN0IGZvcm0gPSBuZXcgRm9ybURhdGEoKVxuICBmb3IgKGNvbnN0IFtrLCB2XSBvZiBtYXAuZW50cmllcygpKSB7XG4gICAgZm9ybS5zZXQoaywgdilcbiAgfVxuICBmb3JtLnNldCgnbWV0YScsIEpTT04uc3RyaW5naWZ5KG1ldGEpKVxuICByZXR1cm4gZm9ybVxufVxuXG4vKipcbiAqIEBwYXJhbSB7TWFwPHN0cmluZywgQmxvYj59IGRhdGFcbiAqIEBwYXJhbSB7QmxvYn0gYmxvYlxuICogQHBhcmFtIHtQcm9wZXJ0eUtleVtdfSBwYXRoXG4gKiBAcmV0dXJucyB7W01hcDxzdHJpbmcsIEJsb2I+LCB2b2lkXX1cbiAqL1xuY29uc3QgZW5jb2RlQmxvYiA9IChkYXRhLCBibG9iLCBwYXRoKSA9PiB7XG4gIGRhdGEuc2V0KHBhdGguam9pbignLicpLCBibG9iKVxuICByZXR1cm4gW2RhdGEsIHVuZGVmaW5lZF1cbn1cblxuLyoqXG4gKiBAcGFyYW0ge2FueX0gdmFsdWVcbiAqIEByZXR1cm5zIHt2YWx1ZSBpcyBCbG9ifVxuICovXG5jb25zdCBpc0Jsb2IgPSAodmFsdWUpID0+IHZhbHVlIGluc3RhbmNlb2YgQmxvYlxuXG4vKipcbiAqIEB0ZW1wbGF0ZSB7VG9rZW5JbnB1dH0gVFxuICogQHBhcmFtIHtFbmNvZGVkQmxvYkJsb2I8VD59IGlucHV0XG4gKi9cbmNvbnN0IG1hcFRva2VuSW5wdXRCbG9icyA9IChpbnB1dCkgPT4ge1xuICByZXR1cm4gbWFwVmFsdWVXaXRoKGlucHV0LCBpc0Jsb2IsIGVuY29kZUJsb2IsIG5ldyBNYXAoKSwgW10pXG59XG5cbi8qKlxuICogU3Vic3RpdHVlcyB2YWx1ZXMgaW4gdGhlIGdpdmVuIGBpbnB1dGAgdGhhdCBtYXRjaCBgcCh2YWx1ZSkgPT0gdHJ1ZWAgd2l0aFxuICogYGYodmFsdWUsIGNvbnRleHQsIHBhdGgpYCB3aGVyZSBgY29udGV4dGAgaXMgd2hhdGV2ZXIgeW91IHBhc3MgKHVzdWFsbHlcbiAqIGEgbXV0YWJsZSBzdGF0ZSkgYW5kIGBwYXRoYCBpcyBhIGFycmF5IG9mIGtleXMgLyBpbmRleGVzIHdoZXJlIHRoZSB2YWx1ZVxuICogd2FzIGVuY291bnRlcmVkLlxuICpcbiAqIEB0ZW1wbGF0ZSBULCBJLCBYLCBPLCBTdGF0ZVxuICogQHBhcmFtIHtpbXBvcnQoJy4vbGliL2ludGVyZmFjZS5qcycpLkVuY29kZWQ8VCwgW1tJLCBYXV0+fSBpbnB1dCAtIEFyYml0cmFyeSBpbnB1dC5cbiAqIEBwYXJhbSB7KGlucHV0OmFueSwgc3RhdGU6U3RhdGUsIHBhdGg6UHJvcGVydHlLZXlbXSkgPT4gaW5wdXQgaXMgWH0gcCAtIFByZWRpY2F0ZSBmdW5jdGlvbiB0byBkZXRlcm1pbmVcbiAqIHdoaWNoIHZhbHVlcyB0byBzd2FwLlxuICogQHBhcmFtIHsoc3RhdGU6U3RhdGUsIGlucHV0OlgsIHBhdGg6UHJvcGVydHlLZXlbXSkgPT4gW1N0YXRlLCBPXX0gZiAtIEZ1bmN0aW9uXG4gKiB0aGF0IHN3YXBzIG1hdGNoaW5nIHZhbHVlcy5cbiAqIEBwYXJhbSB7U3RhdGV9IHN0YXRlIC0gU29tZSBhZGRpdGlvbmFsIGNvbnRleHQgeW91IG5lZWQgaW4gdGhlIHByb2Nlc3MuXG4gKiBsaWtleSB5b3UnbGwgc3RhcnQgd2l0aCBgW11gLlxuICogQHJldHVybnMge2ltcG9ydCgnLi9saWIvaW50ZXJmYWNlLmpzJykuRW5jb2RlZDxULCBbW0ksIE9dXT59XG4gKi9cbmV4cG9ydCBjb25zdCBtYXBXaXRoID0gKGlucHV0LCBwLCBmLCBzdGF0ZSkgPT4ge1xuICBjb25zdCBbLCBvdXRwdXRdID0gbWFwVmFsdWVXaXRoKGlucHV0LCBwLCBmLCBzdGF0ZSwgW10pXG4gIHJldHVybiBvdXRwdXRcbn1cblxuLyoqXG4gKiBAdGVtcGxhdGUgVCwgSSwgWCwgTywgU3RhdGVcbiAqIEBwYXJhbSB7aW1wb3J0KCcuL2xpYi9pbnRlcmZhY2UuanMnKS5FbmNvZGVkPFQsIFtbSSwgWF1dPn0gaW5wdXQgLSBBcmJpdHJhcnkgaW5wdXQuXG4gKiBAcGFyYW0geyhpbnB1dDphbnksIHN0YXRlOlN0YXRlLCBwYXRoOlByb3BlcnR5S2V5W10pID0+IGlucHV0IGlzIFh9IHAgLSBQcmVkaWNhdGUgZnVuY3Rpb24gdG8gZGV0ZXJtaW5lXG4gKiB3aGljaCB2YWx1ZXMgdG8gc3dhcC5cbiAqIEBwYXJhbSB7KHN0YXRlOlN0YXRlLCBpbnB1dDpYLCBwYXRoOlByb3BlcnR5S2V5W10pID0+IFtTdGF0ZSwgT119IGYgLSBGdW5jdGlvblxuICogdGhhdCBzd2FwcyBtYXRjaGluZyB2YWx1ZXMuXG4gKiBAcGFyYW0ge1N0YXRlfSBzdGF0ZSAtIFNvbWUgYWRkaXRpb25hbCBjb250ZXh0IHlvdSBuZWVkIGluIHRoZSBwcm9jZXNzLlxuICogQHBhcmFtIHtQcm9wZXJ0eUtleVtdfSBwYXRoIC0gUGF0aCB3aGVyZSB0aGUgdmFsdWUgd2FzIGVuY291bnRlcmVkLiBNb3N0XG4gKiBsaWtleSB5b3UnbGwgc3RhcnQgd2l0aCBgW11gLlxuICogQHJldHVybnMge1tTdGF0ZSwgaW1wb3J0KCcuL2xpYi9pbnRlcmZhY2UuanMnKS5FbmNvZGVkPFQsIFtbSSwgT11dPl19XG4gKi9cbmNvbnN0IG1hcFZhbHVlV2l0aCA9IChpbnB1dCwgcCwgZiwgc3RhdGUsIHBhdGgpID0+XG4gIHAoaW5wdXQsIHN0YXRlLCBwYXRoKVxuICAgID8gZihzdGF0ZSwgaW5wdXQsIHBhdGgpXG4gICAgOiBBcnJheS5pc0FycmF5KGlucHV0KVxuICAgID8gbWFwQXJyYXlXaXRoKGlucHV0LCBwLCBmLCBzdGF0ZSwgcGF0aClcbiAgICA6IGlzT2JqZWN0KGlucHV0KVxuICAgID8gbWFwT2JqZWN0V2l0aChpbnB1dCwgcCwgZiwgc3RhdGUsIHBhdGgpXG4gICAgOiBbc3RhdGUsIC8qKiBAdHlwZSB7YW55fSAqLyAoaW5wdXQpXVxuXG4vKipcbiAqIEp1c3QgbGlrZSBgbWFwV2l0aGAgZXhjZXB0XG4gKlxuICogQHRlbXBsYXRlIFN0YXRlLCBULCBJLCBYLCBPXG4gKiBAcGFyYW0ge2ltcG9ydCgnLi9saWIvaW50ZXJmYWNlLmpzJykuRW5jb2RlZDxULCBbW0ksIFhdXT59IGlucHV0XG4gKiBAcGFyYW0geyhpbnB1dDphbnksIHN0YXRlOlN0YXRlLCBwYXRoOlByb3BlcnR5S2V5W10pID0+IGlucHV0IGlzIFh9IHBcbiAqIEBwYXJhbSB7KHN0YXRlOiBTdGF0ZSwgaW5wdXQ6WCwgcGF0aDpQcm9wZXJ0eUtleVtdKSA9PiBbU3RhdGUsIE9dfSBmXG4gKiBAcGFyYW0ge1N0YXRlfSBpbml0XG4gKiBAcGFyYW0ge1Byb3BlcnR5S2V5W119IHBhdGhcbiAqIEByZXR1cm5zIHtbU3RhdGUsIGltcG9ydCgnLi9saWIvaW50ZXJmYWNlLmpzJykuRW5jb2RlZDxULCBbW0ksIE9dXT5dfVxuICovXG5jb25zdCBtYXBPYmplY3RXaXRoID0gKGlucHV0LCBwLCBmLCBpbml0LCBwYXRoKSA9PiB7XG4gIGxldCBzdGF0ZSA9IGluaXRcbiAgY29uc3Qgb3V0cHV0ID1cbiAgICAvKiogQHR5cGUge2ltcG9ydCgnLi9saWIvaW50ZXJmYWNlLmpzJykuRW5jb2RlZDxULCBbW0ksIE9dXT59ICovICh7fSlcbiAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2YgT2JqZWN0LmVudHJpZXMoaW5wdXQpKSB7XG4gICAgY29uc3QgW25leHQsIG91dF0gPSBtYXBWYWx1ZVdpdGgodmFsdWUsIHAsIGYsIHN0YXRlLCBbLi4ucGF0aCwga2V5XSlcbiAgICAvLyBAdHMtaWdub3JlXG4gICAgb3V0cHV0W2tleV0gPSBvdXRcbiAgICBzdGF0ZSA9IG5leHRcbiAgfVxuICByZXR1cm4gW3N0YXRlLCBvdXRwdXRdXG59XG5cbi8qKlxuICogSnVzdCBsaWtlIGBtYXBXaXRoYCBleGNlcHQgZm9yIEFycmF5cy5cbiAqXG4gKiBAdGVtcGxhdGUgSSwgWCwgTywgU3RhdGVcbiAqIEB0ZW1wbGF0ZSB7YW55W119IFRcbiAqIEBwYXJhbSB7VH0gaW5wdXRcbiAqIEBwYXJhbSB7KGlucHV0OmFueSwgc3RhdGU6U3RhdGUsIHBhdGg6UHJvcGVydHlLZXlbXSkgPT4gaW5wdXQgaXMgWH0gcFxuICogQHBhcmFtIHsoc3RhdGU6IFN0YXRlLCBpbnB1dDpYLCBwYXRoOlByb3BlcnR5S2V5W10pID0+IFtTdGF0ZSwgT119IGZcbiAqIEBwYXJhbSB7U3RhdGV9IGluaXRcbiAqIEBwYXJhbSB7UHJvcGVydHlLZXlbXX0gcGF0aFxuICogQHJldHVybnMge1tTdGF0ZSwgaW1wb3J0KCcuL2xpYi9pbnRlcmZhY2UuanMnKS5FbmNvZGVkPFQsIFtbSSwgT11dPl19XG4gKi9cbmNvbnN0IG1hcEFycmF5V2l0aCA9IChpbnB1dCwgcCwgZiwgaW5pdCwgcGF0aCkgPT4ge1xuICBjb25zdCBvdXRwdXQgPSAvKiogQHR5cGUge3Vua25vd25bXX0gKi8gKFtdKVxuXG4gIGxldCBzdGF0ZSA9IGluaXRcbiAgZm9yIChjb25zdCBbaW5kZXgsIGVsZW1lbnRdIG9mIGlucHV0LmVudHJpZXMoKSkge1xuICAgIGNvbnN0IFtuZXh0LCBvdXRdID0gbWFwVmFsdWVXaXRoKGVsZW1lbnQsIHAsIGYsIHN0YXRlLCBbLi4ucGF0aCwgaW5kZXhdKVxuICAgIG91dHB1dFtpbmRleF0gPSBvdXRcbiAgICBzdGF0ZSA9IG5leHRcbiAgfVxuXG4gIHJldHVybiBbXG4gICAgc3RhdGUsXG4gICAgLyoqIEB0eXBlIHtpbXBvcnQoJy4vbGliL2ludGVyZmFjZS5qcycpLkVuY29kZWQ8VCwgW1tJLCBPXV0+fSAqLyAob3V0cHV0KSxcbiAgXVxufVxuXG4vKipcbiAqIFNldHMgYSBnaXZlbiBgdmFsdWVgIGF0IHRoZSBnaXZlbiBgcGF0aGAgb24gYSBwYXNzZWQgYG9iamVjdGAuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYGpzXG4gKiBjb25zdCBvYmogPSB7IGE6IHsgYjogeyBjOiAxIH19fVxuICogc2V0SW4ob2JqLCBbJ2EnLCAnYicsICdjJ10sIDUpXG4gKiBvYmouYS5iLmMgLy8+IDVcbiAqIGBgYFxuICpcbiAqIEB0ZW1wbGF0ZSBWXG4gKiBAcGFyYW0ge2FueX0gb2JqZWN0XG4gKiBAcGFyYW0ge3N0cmluZ1tdfSBwYXRoXG4gKiBAcGFyYW0ge1Z9IHZhbHVlXG4gKi9cbmNvbnN0IHNldEluID0gKG9iamVjdCwgcGF0aCwgdmFsdWUpID0+IHtcbiAgY29uc3QgbiA9IHBhdGgubGVuZ3RoIC0gMVxuICBsZXQgdGFyZ2V0ID0gb2JqZWN0XG4gIGZvciAobGV0IFtpbmRleCwga2V5XSBvZiBwYXRoLmVudHJpZXMoKSkge1xuICAgIGlmIChpbmRleCA9PT0gbikge1xuICAgICAgdGFyZ2V0W2tleV0gPSB2YWx1ZVxuICAgIH0gZWxzZSB7XG4gICAgICB0YXJnZXQgPSB0YXJnZXRba2V5XVxuICAgIH1cbiAgfVxufVxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/nft.storage/src/token.js\n");

/***/ })

};
;