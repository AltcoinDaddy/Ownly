"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@assemblyscript";
exports.ids = ["vendor-chunks/@assemblyscript"];
exports.modules = {

/***/ "(rsc)/./node_modules/@assemblyscript/loader/index.js":
/*!******************************************************!*\
  !*** ./node_modules/@assemblyscript/loader/index.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\n\n// Runtime header offsets\nconst ID_OFFSET = -8;\nconst SIZE_OFFSET = -4;\n\n// Runtime ids\nconst ARRAYBUFFER_ID = 0;\nconst STRING_ID = 1;\nconst ARRAYBUFFERVIEW_ID = 2;\n\n// Runtime type information\nconst ARRAYBUFFERVIEW = 1 << 0;\nconst ARRAY = 1 << 1;\nconst SET = 1 << 2;\nconst MAP = 1 << 3;\nconst VAL_ALIGN_OFFSET = 5;\nconst VAL_ALIGN = 1 << VAL_ALIGN_OFFSET;\nconst VAL_SIGNED = 1 << 10;\nconst VAL_FLOAT = 1 << 11;\nconst VAL_NULLABLE = 1 << 12;\nconst VAL_MANAGED = 1 << 13;\nconst KEY_ALIGN_OFFSET = 14;\nconst KEY_ALIGN = 1 << KEY_ALIGN_OFFSET;\nconst KEY_SIGNED = 1 << 19;\nconst KEY_FLOAT = 1 << 20;\nconst KEY_NULLABLE = 1 << 21;\nconst KEY_MANAGED = 1 << 22;\n\n// Array(BufferView) layout\nconst ARRAYBUFFERVIEW_BUFFER_OFFSET = 0;\nconst ARRAYBUFFERVIEW_DATASTART_OFFSET = 4;\nconst ARRAYBUFFERVIEW_DATALENGTH_OFFSET = 8;\nconst ARRAYBUFFERVIEW_SIZE = 12;\nconst ARRAY_LENGTH_OFFSET = 12;\nconst ARRAY_SIZE = 16;\n\nconst BIGINT = typeof BigUint64Array !== \"undefined\";\nconst THIS = Symbol();\nconst CHUNKSIZE = 1024;\n\n/** Gets a string from an U32 and an U16 view on a memory. */\nfunction getStringImpl(buffer, ptr) {\n  const U32 = new Uint32Array(buffer);\n  const U16 = new Uint16Array(buffer);\n  var length = U32[(ptr + SIZE_OFFSET) >>> 2] >>> 1;\n  var offset = ptr >>> 1;\n  if (length <= CHUNKSIZE) return String.fromCharCode.apply(String, U16.subarray(offset, offset + length));\n  const parts = [];\n  do {\n    const last = U16[offset + CHUNKSIZE - 1];\n    const size = last >= 0xD800 && last < 0xDC00 ? CHUNKSIZE - 1 : CHUNKSIZE;\n    parts.push(String.fromCharCode.apply(String, U16.subarray(offset, offset += size)));\n    length -= size;\n  } while (length > CHUNKSIZE);\n  return parts.join(\"\") + String.fromCharCode.apply(String, U16.subarray(offset, offset + length));\n}\n\n/** Prepares the base module prior to instantiation. */\nfunction preInstantiate(imports) {\n  const baseModule = {};\n\n  function getString(memory, ptr) {\n    if (!memory) return \"<yet unknown>\";\n    return getStringImpl(memory.buffer, ptr);\n  }\n\n  // add common imports used by stdlib for convenience\n  const env = (imports.env = imports.env || {});\n  env.abort = env.abort || function abort(mesg, file, line, colm) {\n    const memory = baseModule.memory || env.memory; // prefer exported, otherwise try imported\n    throw Error(\"abort: \" + getString(memory, mesg) + \" at \" + getString(memory, file) + \":\" + line + \":\" + colm);\n  }\n  env.trace = env.trace || function trace(mesg, n) {\n    const memory = baseModule.memory || env.memory;\n    console.log(\"trace: \" + getString(memory, mesg) + (n ? \" \" : \"\") + Array.prototype.slice.call(arguments, 2, 2 + n).join(\", \"));\n  }\n  imports.Math = imports.Math || Math;\n  imports.Date = imports.Date || Date;\n\n  return baseModule;\n}\n\n/** Prepares the final module once instantiation is complete. */\nfunction postInstantiate(baseModule, instance) {\n  const rawExports = instance.exports;\n  const memory = rawExports.memory;\n  const table = rawExports.table;\n  const alloc = rawExports[\"__alloc\"];\n  const retain = rawExports[\"__retain\"];\n  const rttiBase = rawExports[\"__rtti_base\"] || ~0; // oob if not present\n\n  /** Gets the runtime type info for the given id. */\n  function getInfo(id) {\n    const U32 = new Uint32Array(memory.buffer);\n    const count = U32[rttiBase >>> 2];\n    if ((id >>>= 0) >= count) throw Error(\"invalid id: \" + id);\n    return U32[(rttiBase + 4 >>> 2) + id * 2];\n  }\n\n  /** Gets the runtime base id for the given id. */\n  function getBase(id) {\n    const U32 = new Uint32Array(memory.buffer);\n    const count = U32[rttiBase >>> 2];\n    if ((id >>>= 0) >= count) throw Error(\"invalid id: \" + id);\n    return U32[(rttiBase + 4 >>> 2) + id * 2 + 1];\n  }\n\n  /** Gets the runtime alignment of a collection's values. */\n  function getValueAlign(info) {\n    return 31 - Math.clz32((info >>> VAL_ALIGN_OFFSET) & 31); // -1 if none\n  }\n\n  /** Gets the runtime alignment of a collection's keys. */\n  function getKeyAlign(info) {\n    return 31 - Math.clz32((info >>> KEY_ALIGN_OFFSET) & 31); // -1 if none\n  }\n\n  /** Allocates a new string in the module's memory and returns its retained pointer. */\n  function __allocString(str) {\n    const length = str.length;\n    const ptr = alloc(length << 1, STRING_ID);\n    const U16 = new Uint16Array(memory.buffer);\n    for (var i = 0, p = ptr >>> 1; i < length; ++i) U16[p + i] = str.charCodeAt(i);\n    return ptr;\n  }\n\n  baseModule.__allocString = __allocString;\n\n  /** Reads a string from the module's memory by its pointer. */\n  function __getString(ptr) {\n    const buffer = memory.buffer;\n    const id = new Uint32Array(buffer)[ptr + ID_OFFSET >>> 2];\n    if (id !== STRING_ID) throw Error(\"not a string: \" + ptr);\n    return getStringImpl(buffer, ptr);\n  }\n\n  baseModule.__getString = __getString;\n\n  /** Gets the view matching the specified alignment, signedness and floatness. */\n  function getView(alignLog2, signed, float) {\n    const buffer = memory.buffer;\n    if (float) {\n      switch (alignLog2) {\n        case 2: return new Float32Array(buffer);\n        case 3: return new Float64Array(buffer);\n      }\n    } else {\n      switch (alignLog2) {\n        case 0: return new (signed ? Int8Array : Uint8Array)(buffer);\n        case 1: return new (signed ? Int16Array : Uint16Array)(buffer);\n        case 2: return new (signed ? Int32Array : Uint32Array)(buffer);\n        case 3: return new (signed ? BigInt64Array : BigUint64Array)(buffer);\n      }\n    }\n    throw Error(\"unsupported align: \" + alignLog2);\n  }\n\n  /** Allocates a new array in the module's memory and returns its retained pointer. */\n  function __allocArray(id, values) {\n    const info = getInfo(id);\n    if (!(info & (ARRAYBUFFERVIEW | ARRAY))) throw Error(\"not an array: \" + id + \" @ \" + info);\n    const align = getValueAlign(info);\n    const length = values.length;\n    const buf = alloc(length << align, ARRAYBUFFER_ID);\n    const arr = alloc(info & ARRAY ? ARRAY_SIZE : ARRAYBUFFERVIEW_SIZE, id);\n    const U32 = new Uint32Array(memory.buffer);\n    U32[arr + ARRAYBUFFERVIEW_BUFFER_OFFSET >>> 2] = retain(buf);\n    U32[arr + ARRAYBUFFERVIEW_DATASTART_OFFSET >>> 2] = buf;\n    U32[arr + ARRAYBUFFERVIEW_DATALENGTH_OFFSET >>> 2] = length << align;\n    if (info & ARRAY) U32[arr + ARRAY_LENGTH_OFFSET >>> 2] = length;\n    const view = getView(align, info & VAL_SIGNED, info & VAL_FLOAT);\n    if (info & VAL_MANAGED) {\n      for (let i = 0; i < length; ++i) view[(buf >>> align) + i] = retain(values[i]);\n    } else {\n      view.set(values, buf >>> align);\n    }\n    return arr;\n  }\n\n  baseModule.__allocArray = __allocArray;\n\n  /** Gets a live view on an array's values in the module's memory. Infers the array type from RTTI. */\n  function __getArrayView(arr) {\n    const U32 = new Uint32Array(memory.buffer);\n    const id = U32[arr + ID_OFFSET >>> 2];\n    const info = getInfo(id);\n    if (!(info & ARRAYBUFFERVIEW)) throw Error(\"not an array: \" + id);\n    const align = getValueAlign(info);\n    var buf = U32[arr + ARRAYBUFFERVIEW_DATASTART_OFFSET >>> 2];\n    const length = info & ARRAY\n      ? U32[arr + ARRAY_LENGTH_OFFSET >>> 2]\n      : U32[buf + SIZE_OFFSET >>> 2] >>> align;\n    return getView(align, info & VAL_SIGNED, info & VAL_FLOAT)\n          .subarray(buf >>>= align, buf + length);\n  }\n\n  baseModule.__getArrayView = __getArrayView;\n\n  /** Copies an array's values from the module's memory. Infers the array type from RTTI. */\n  function __getArray(arr) {\n    const input = __getArrayView(arr);\n    const len = input.length;\n    const out = new Array(len);\n    for (let i = 0; i < len; i++) out[i] = input[i];\n    return out;\n  }\n\n  baseModule.__getArray = __getArray;\n\n  /** Copies an ArrayBuffer's value from the module's memory. */\n  function __getArrayBuffer(ptr) {\n    const buffer = memory.buffer;\n    const length = new Uint32Array(buffer)[ptr + SIZE_OFFSET >>> 2];\n    return buffer.slice(ptr, ptr + length);\n  }\n\n  baseModule.__getArrayBuffer = __getArrayBuffer;\n\n  /** Copies a typed array's values from the module's memory. */\n  function getTypedArray(Type, alignLog2, ptr) {\n    return new Type(getTypedArrayView(Type, alignLog2, ptr));\n  }\n\n  /** Gets a live view on a typed array's values in the module's memory. */\n  function getTypedArrayView(Type, alignLog2, ptr) {\n    const buffer = memory.buffer;\n    const U32 = new Uint32Array(buffer);\n    const bufPtr = U32[ptr + ARRAYBUFFERVIEW_DATASTART_OFFSET >>> 2];\n    return new Type(buffer, bufPtr, U32[bufPtr + SIZE_OFFSET >>> 2] >>> alignLog2);\n  }\n\n  baseModule.__getInt8Array = getTypedArray.bind(null, Int8Array, 0);\n  baseModule.__getInt8ArrayView = getTypedArrayView.bind(null, Int8Array, 0);\n  baseModule.__getUint8Array = getTypedArray.bind(null, Uint8Array, 0);\n  baseModule.__getUint8ArrayView = getTypedArrayView.bind(null, Uint8Array, 0);\n  baseModule.__getUint8ClampedArray = getTypedArray.bind(null, Uint8ClampedArray, 0);\n  baseModule.__getUint8ClampedArrayView = getTypedArrayView.bind(null, Uint8ClampedArray, 0);\n  baseModule.__getInt16Array = getTypedArray.bind(null, Int16Array, 1);\n  baseModule.__getInt16ArrayView = getTypedArrayView.bind(null, Int16Array, 1);\n  baseModule.__getUint16Array = getTypedArray.bind(null, Uint16Array, 1);\n  baseModule.__getUint16ArrayView = getTypedArrayView.bind(null, Uint16Array, 1);\n  baseModule.__getInt32Array = getTypedArray.bind(null, Int32Array, 2);\n  baseModule.__getInt32ArrayView = getTypedArrayView.bind(null, Int32Array, 2);\n  baseModule.__getUint32Array = getTypedArray.bind(null, Uint32Array, 2);\n  baseModule.__getUint32ArrayView = getTypedArrayView.bind(null, Uint32Array, 2);\n  if (BIGINT) {\n    baseModule.__getInt64Array = getTypedArray.bind(null, BigInt64Array, 3);\n    baseModule.__getInt64ArrayView = getTypedArrayView.bind(null, BigInt64Array, 3);\n    baseModule.__getUint64Array = getTypedArray.bind(null, BigUint64Array, 3);\n    baseModule.__getUint64ArrayView = getTypedArrayView.bind(null, BigUint64Array, 3);\n  }\n  baseModule.__getFloat32Array = getTypedArray.bind(null, Float32Array, 2);\n  baseModule.__getFloat32ArrayView = getTypedArrayView.bind(null, Float32Array, 2);\n  baseModule.__getFloat64Array = getTypedArray.bind(null, Float64Array, 3);\n  baseModule.__getFloat64ArrayView = getTypedArrayView.bind(null, Float64Array, 3);\n\n  /** Tests whether an object is an instance of the class represented by the specified base id. */\n  function __instanceof(ptr, baseId) {\n    const U32 = new Uint32Array(memory.buffer);\n    var id = U32[(ptr + ID_OFFSET) >>> 2];\n    if (id <= U32[rttiBase >>> 2]) {\n      do if (id == baseId) return true;\n      while (id = getBase(id));\n    }\n    return false;\n  }\n\n  baseModule.__instanceof = __instanceof;\n\n  // Pull basic exports to baseModule so code in preInstantiate can use them\n  baseModule.memory = baseModule.memory || memory;\n  baseModule.table  = baseModule.table  || table;\n\n  // Demangle exports and provide the usual utility on the prototype\n  return demangle(rawExports, baseModule);\n}\n\nfunction isResponse(o) {\n  return typeof Response !== \"undefined\" && o instanceof Response;\n}\n\n/** Asynchronously instantiates an AssemblyScript module from anything that can be instantiated. */\nasync function instantiate(source, imports) {\n  if (isResponse(source = await source)) return instantiateStreaming(source, imports);\n  return postInstantiate(\n    preInstantiate(imports || (imports = {})),\n    await WebAssembly.instantiate(\n      source instanceof WebAssembly.Module\n        ? source\n        : await WebAssembly.compile(source),\n      imports\n    )\n  );\n}\n\nexports.instantiate = instantiate;\n\n/** Synchronously instantiates an AssemblyScript module from a WebAssembly.Module or binary buffer. */\nfunction instantiateSync(source, imports) {\n  return postInstantiate(\n    preInstantiate(imports || (imports = {})),\n    new WebAssembly.Instance(\n      source instanceof WebAssembly.Module\n        ? source\n        : new WebAssembly.Module(source),\n      imports\n    )\n  )\n}\n\nexports.instantiateSync = instantiateSync;\n\n/** Asynchronously instantiates an AssemblyScript module from a response, i.e. as obtained by `fetch`. */\nasync function instantiateStreaming(source, imports) {\n  if (!WebAssembly.instantiateStreaming) {\n    return instantiate(\n      isResponse(source = await source)\n        ? source.arrayBuffer()\n        : source,\n      imports\n    );\n  }\n  return postInstantiate(\n    preInstantiate(imports || (imports = {})),\n    (await WebAssembly.instantiateStreaming(source, imports)).instance\n  );\n}\n\nexports.instantiateStreaming = instantiateStreaming;\n\n/** Demangles an AssemblyScript module's exports to a friendly object structure. */\nfunction demangle(exports, baseModule) {\n  var module = baseModule ? Object.create(baseModule) : {};\n  var setArgumentsLength = exports[\"__argumentsLength\"]\n    ? function(length) { exports[\"__argumentsLength\"].value = length; }\n    : exports[\"__setArgumentsLength\"] || exports[\"__setargc\"] || function() {};\n  for (let internalName in exports) {\n    if (!Object.prototype.hasOwnProperty.call(exports, internalName)) continue;\n    const elem = exports[internalName];\n    let parts = internalName.split(\".\");\n    let curr = module;\n    while (parts.length > 1) {\n      let part = parts.shift();\n      if (!Object.prototype.hasOwnProperty.call(curr, part)) curr[part] = {};\n      curr = curr[part];\n    }\n    let name = parts[0];\n    let hash = name.indexOf(\"#\");\n    if (hash >= 0) {\n      let className = name.substring(0, hash);\n      let classElem = curr[className];\n      if (typeof classElem === \"undefined\" || !classElem.prototype) {\n        let ctor = function(...args) {\n          return ctor.wrap(ctor.prototype.constructor(0, ...args));\n        };\n        ctor.prototype = {\n          valueOf: function valueOf() {\n            return this[THIS];\n          }\n        };\n        ctor.wrap = function(thisValue) {\n          return Object.create(ctor.prototype, { [THIS]: { value: thisValue, writable: false } });\n        };\n        if (classElem) Object.getOwnPropertyNames(classElem).forEach(name =>\n          Object.defineProperty(ctor, name, Object.getOwnPropertyDescriptor(classElem, name))\n        );\n        curr[className] = ctor;\n      }\n      name = name.substring(hash + 1);\n      curr = curr[className].prototype;\n      if (/^(get|set):/.test(name)) {\n        if (!Object.prototype.hasOwnProperty.call(curr, name = name.substring(4))) {\n          let getter = exports[internalName.replace(\"set:\", \"get:\")];\n          let setter = exports[internalName.replace(\"get:\", \"set:\")];\n          Object.defineProperty(curr, name, {\n            get: function() { return getter(this[THIS]); },\n            set: function(value) { setter(this[THIS], value); },\n            enumerable: true\n          });\n        }\n      } else {\n        if (name === 'constructor') {\n          (curr[name] = (...args) => {\n            setArgumentsLength(args.length);\n            return elem(...args);\n          }).original = elem;\n        } else { // instance method\n          (curr[name] = function(...args) { // !\n            setArgumentsLength(args.length);\n            return elem(this[THIS], ...args);\n          }).original = elem;\n        }\n      }\n    } else {\n      if (/^(get|set):/.test(name)) {\n        if (!Object.prototype.hasOwnProperty.call(curr, name = name.substring(4))) {\n          Object.defineProperty(curr, name, {\n            get: exports[internalName.replace(\"set:\", \"get:\")],\n            set: exports[internalName.replace(\"get:\", \"set:\")],\n            enumerable: true\n          });\n        }\n      } else if (typeof elem === \"function\" && elem !== setArgumentsLength) {\n        (curr[name] = (...args) => {\n          setArgumentsLength(args.length);\n          return elem(...args);\n        }).original = elem;\n      } else {\n        curr[name] = elem;\n      }\n    }\n  }\n  return module;\n}\n\nexports.demangle = demangle;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGFzc2VtYmx5c2NyaXB0L2xvYWRlci9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw4Q0FBOEM7QUFDOUM7QUFDQSxvREFBb0Q7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0RBQW9EOztBQUVwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsOERBQThEO0FBQzlEOztBQUVBO0FBQ0E7QUFDQSw4REFBOEQ7QUFDOUQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyxZQUFZO0FBQy9DO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLFlBQVk7QUFDbEMsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixTQUFTO0FBQzdCO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG1CQUFtQjs7QUFFbkI7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsdUJBQXVCOztBQUV2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDO0FBQzNDO0FBQ0E7QUFDQTs7QUFFQSw0QkFBNEI7O0FBRTVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQsVUFBVSxxQ0FBcUM7QUFDaEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsNEJBQTRCO0FBQzFELG1DQUFtQyw0QkFBNEI7QUFDL0Q7QUFDQSxXQUFXO0FBQ1g7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsVUFBVSxPQUFPO0FBQ2pCLDRDQUE0QztBQUM1QztBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGdCQUFnQiIsInNvdXJjZXMiOlsiL2hvbWUvYWx0Y29pbi1kYWRkeS9Eb3dubG9hZHMvb3dubHkvbm9kZV9tb2R1bGVzL0Bhc3NlbWJseXNjcmlwdC9sb2FkZXIvaW5kZXguanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5cbi8vIFJ1bnRpbWUgaGVhZGVyIG9mZnNldHNcbmNvbnN0IElEX09GRlNFVCA9IC04O1xuY29uc3QgU0laRV9PRkZTRVQgPSAtNDtcblxuLy8gUnVudGltZSBpZHNcbmNvbnN0IEFSUkFZQlVGRkVSX0lEID0gMDtcbmNvbnN0IFNUUklOR19JRCA9IDE7XG5jb25zdCBBUlJBWUJVRkZFUlZJRVdfSUQgPSAyO1xuXG4vLyBSdW50aW1lIHR5cGUgaW5mb3JtYXRpb25cbmNvbnN0IEFSUkFZQlVGRkVSVklFVyA9IDEgPDwgMDtcbmNvbnN0IEFSUkFZID0gMSA8PCAxO1xuY29uc3QgU0VUID0gMSA8PCAyO1xuY29uc3QgTUFQID0gMSA8PCAzO1xuY29uc3QgVkFMX0FMSUdOX09GRlNFVCA9IDU7XG5jb25zdCBWQUxfQUxJR04gPSAxIDw8IFZBTF9BTElHTl9PRkZTRVQ7XG5jb25zdCBWQUxfU0lHTkVEID0gMSA8PCAxMDtcbmNvbnN0IFZBTF9GTE9BVCA9IDEgPDwgMTE7XG5jb25zdCBWQUxfTlVMTEFCTEUgPSAxIDw8IDEyO1xuY29uc3QgVkFMX01BTkFHRUQgPSAxIDw8IDEzO1xuY29uc3QgS0VZX0FMSUdOX09GRlNFVCA9IDE0O1xuY29uc3QgS0VZX0FMSUdOID0gMSA8PCBLRVlfQUxJR05fT0ZGU0VUO1xuY29uc3QgS0VZX1NJR05FRCA9IDEgPDwgMTk7XG5jb25zdCBLRVlfRkxPQVQgPSAxIDw8IDIwO1xuY29uc3QgS0VZX05VTExBQkxFID0gMSA8PCAyMTtcbmNvbnN0IEtFWV9NQU5BR0VEID0gMSA8PCAyMjtcblxuLy8gQXJyYXkoQnVmZmVyVmlldykgbGF5b3V0XG5jb25zdCBBUlJBWUJVRkZFUlZJRVdfQlVGRkVSX09GRlNFVCA9IDA7XG5jb25zdCBBUlJBWUJVRkZFUlZJRVdfREFUQVNUQVJUX09GRlNFVCA9IDQ7XG5jb25zdCBBUlJBWUJVRkZFUlZJRVdfREFUQUxFTkdUSF9PRkZTRVQgPSA4O1xuY29uc3QgQVJSQVlCVUZGRVJWSUVXX1NJWkUgPSAxMjtcbmNvbnN0IEFSUkFZX0xFTkdUSF9PRkZTRVQgPSAxMjtcbmNvbnN0IEFSUkFZX1NJWkUgPSAxNjtcblxuY29uc3QgQklHSU5UID0gdHlwZW9mIEJpZ1VpbnQ2NEFycmF5ICE9PSBcInVuZGVmaW5lZFwiO1xuY29uc3QgVEhJUyA9IFN5bWJvbCgpO1xuY29uc3QgQ0hVTktTSVpFID0gMTAyNDtcblxuLyoqIEdldHMgYSBzdHJpbmcgZnJvbSBhbiBVMzIgYW5kIGFuIFUxNiB2aWV3IG9uIGEgbWVtb3J5LiAqL1xuZnVuY3Rpb24gZ2V0U3RyaW5nSW1wbChidWZmZXIsIHB0cikge1xuICBjb25zdCBVMzIgPSBuZXcgVWludDMyQXJyYXkoYnVmZmVyKTtcbiAgY29uc3QgVTE2ID0gbmV3IFVpbnQxNkFycmF5KGJ1ZmZlcik7XG4gIHZhciBsZW5ndGggPSBVMzJbKHB0ciArIFNJWkVfT0ZGU0VUKSA+Pj4gMl0gPj4+IDE7XG4gIHZhciBvZmZzZXQgPSBwdHIgPj4+IDE7XG4gIGlmIChsZW5ndGggPD0gQ0hVTktTSVpFKSByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShTdHJpbmcsIFUxNi5zdWJhcnJheShvZmZzZXQsIG9mZnNldCArIGxlbmd0aCkpO1xuICBjb25zdCBwYXJ0cyA9IFtdO1xuICBkbyB7XG4gICAgY29uc3QgbGFzdCA9IFUxNltvZmZzZXQgKyBDSFVOS1NJWkUgLSAxXTtcbiAgICBjb25zdCBzaXplID0gbGFzdCA+PSAweEQ4MDAgJiYgbGFzdCA8IDB4REMwMCA/IENIVU5LU0laRSAtIDEgOiBDSFVOS1NJWkU7XG4gICAgcGFydHMucHVzaChTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KFN0cmluZywgVTE2LnN1YmFycmF5KG9mZnNldCwgb2Zmc2V0ICs9IHNpemUpKSk7XG4gICAgbGVuZ3RoIC09IHNpemU7XG4gIH0gd2hpbGUgKGxlbmd0aCA+IENIVU5LU0laRSk7XG4gIHJldHVybiBwYXJ0cy5qb2luKFwiXCIpICsgU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShTdHJpbmcsIFUxNi5zdWJhcnJheShvZmZzZXQsIG9mZnNldCArIGxlbmd0aCkpO1xufVxuXG4vKiogUHJlcGFyZXMgdGhlIGJhc2UgbW9kdWxlIHByaW9yIHRvIGluc3RhbnRpYXRpb24uICovXG5mdW5jdGlvbiBwcmVJbnN0YW50aWF0ZShpbXBvcnRzKSB7XG4gIGNvbnN0IGJhc2VNb2R1bGUgPSB7fTtcblxuICBmdW5jdGlvbiBnZXRTdHJpbmcobWVtb3J5LCBwdHIpIHtcbiAgICBpZiAoIW1lbW9yeSkgcmV0dXJuIFwiPHlldCB1bmtub3duPlwiO1xuICAgIHJldHVybiBnZXRTdHJpbmdJbXBsKG1lbW9yeS5idWZmZXIsIHB0cik7XG4gIH1cblxuICAvLyBhZGQgY29tbW9uIGltcG9ydHMgdXNlZCBieSBzdGRsaWIgZm9yIGNvbnZlbmllbmNlXG4gIGNvbnN0IGVudiA9IChpbXBvcnRzLmVudiA9IGltcG9ydHMuZW52IHx8IHt9KTtcbiAgZW52LmFib3J0ID0gZW52LmFib3J0IHx8IGZ1bmN0aW9uIGFib3J0KG1lc2csIGZpbGUsIGxpbmUsIGNvbG0pIHtcbiAgICBjb25zdCBtZW1vcnkgPSBiYXNlTW9kdWxlLm1lbW9yeSB8fCBlbnYubWVtb3J5OyAvLyBwcmVmZXIgZXhwb3J0ZWQsIG90aGVyd2lzZSB0cnkgaW1wb3J0ZWRcbiAgICB0aHJvdyBFcnJvcihcImFib3J0OiBcIiArIGdldFN0cmluZyhtZW1vcnksIG1lc2cpICsgXCIgYXQgXCIgKyBnZXRTdHJpbmcobWVtb3J5LCBmaWxlKSArIFwiOlwiICsgbGluZSArIFwiOlwiICsgY29sbSk7XG4gIH1cbiAgZW52LnRyYWNlID0gZW52LnRyYWNlIHx8IGZ1bmN0aW9uIHRyYWNlKG1lc2csIG4pIHtcbiAgICBjb25zdCBtZW1vcnkgPSBiYXNlTW9kdWxlLm1lbW9yeSB8fCBlbnYubWVtb3J5O1xuICAgIGNvbnNvbGUubG9nKFwidHJhY2U6IFwiICsgZ2V0U3RyaW5nKG1lbW9yeSwgbWVzZykgKyAobiA/IFwiIFwiIDogXCJcIikgKyBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDIsIDIgKyBuKS5qb2luKFwiLCBcIikpO1xuICB9XG4gIGltcG9ydHMuTWF0aCA9IGltcG9ydHMuTWF0aCB8fCBNYXRoO1xuICBpbXBvcnRzLkRhdGUgPSBpbXBvcnRzLkRhdGUgfHwgRGF0ZTtcblxuICByZXR1cm4gYmFzZU1vZHVsZTtcbn1cblxuLyoqIFByZXBhcmVzIHRoZSBmaW5hbCBtb2R1bGUgb25jZSBpbnN0YW50aWF0aW9uIGlzIGNvbXBsZXRlLiAqL1xuZnVuY3Rpb24gcG9zdEluc3RhbnRpYXRlKGJhc2VNb2R1bGUsIGluc3RhbmNlKSB7XG4gIGNvbnN0IHJhd0V4cG9ydHMgPSBpbnN0YW5jZS5leHBvcnRzO1xuICBjb25zdCBtZW1vcnkgPSByYXdFeHBvcnRzLm1lbW9yeTtcbiAgY29uc3QgdGFibGUgPSByYXdFeHBvcnRzLnRhYmxlO1xuICBjb25zdCBhbGxvYyA9IHJhd0V4cG9ydHNbXCJfX2FsbG9jXCJdO1xuICBjb25zdCByZXRhaW4gPSByYXdFeHBvcnRzW1wiX19yZXRhaW5cIl07XG4gIGNvbnN0IHJ0dGlCYXNlID0gcmF3RXhwb3J0c1tcIl9fcnR0aV9iYXNlXCJdIHx8IH4wOyAvLyBvb2IgaWYgbm90IHByZXNlbnRcblxuICAvKiogR2V0cyB0aGUgcnVudGltZSB0eXBlIGluZm8gZm9yIHRoZSBnaXZlbiBpZC4gKi9cbiAgZnVuY3Rpb24gZ2V0SW5mbyhpZCkge1xuICAgIGNvbnN0IFUzMiA9IG5ldyBVaW50MzJBcnJheShtZW1vcnkuYnVmZmVyKTtcbiAgICBjb25zdCBjb3VudCA9IFUzMltydHRpQmFzZSA+Pj4gMl07XG4gICAgaWYgKChpZCA+Pj49IDApID49IGNvdW50KSB0aHJvdyBFcnJvcihcImludmFsaWQgaWQ6IFwiICsgaWQpO1xuICAgIHJldHVybiBVMzJbKHJ0dGlCYXNlICsgNCA+Pj4gMikgKyBpZCAqIDJdO1xuICB9XG5cbiAgLyoqIEdldHMgdGhlIHJ1bnRpbWUgYmFzZSBpZCBmb3IgdGhlIGdpdmVuIGlkLiAqL1xuICBmdW5jdGlvbiBnZXRCYXNlKGlkKSB7XG4gICAgY29uc3QgVTMyID0gbmV3IFVpbnQzMkFycmF5KG1lbW9yeS5idWZmZXIpO1xuICAgIGNvbnN0IGNvdW50ID0gVTMyW3J0dGlCYXNlID4+PiAyXTtcbiAgICBpZiAoKGlkID4+Pj0gMCkgPj0gY291bnQpIHRocm93IEVycm9yKFwiaW52YWxpZCBpZDogXCIgKyBpZCk7XG4gICAgcmV0dXJuIFUzMlsocnR0aUJhc2UgKyA0ID4+PiAyKSArIGlkICogMiArIDFdO1xuICB9XG5cbiAgLyoqIEdldHMgdGhlIHJ1bnRpbWUgYWxpZ25tZW50IG9mIGEgY29sbGVjdGlvbidzIHZhbHVlcy4gKi9cbiAgZnVuY3Rpb24gZ2V0VmFsdWVBbGlnbihpbmZvKSB7XG4gICAgcmV0dXJuIDMxIC0gTWF0aC5jbHozMigoaW5mbyA+Pj4gVkFMX0FMSUdOX09GRlNFVCkgJiAzMSk7IC8vIC0xIGlmIG5vbmVcbiAgfVxuXG4gIC8qKiBHZXRzIHRoZSBydW50aW1lIGFsaWdubWVudCBvZiBhIGNvbGxlY3Rpb24ncyBrZXlzLiAqL1xuICBmdW5jdGlvbiBnZXRLZXlBbGlnbihpbmZvKSB7XG4gICAgcmV0dXJuIDMxIC0gTWF0aC5jbHozMigoaW5mbyA+Pj4gS0VZX0FMSUdOX09GRlNFVCkgJiAzMSk7IC8vIC0xIGlmIG5vbmVcbiAgfVxuXG4gIC8qKiBBbGxvY2F0ZXMgYSBuZXcgc3RyaW5nIGluIHRoZSBtb2R1bGUncyBtZW1vcnkgYW5kIHJldHVybnMgaXRzIHJldGFpbmVkIHBvaW50ZXIuICovXG4gIGZ1bmN0aW9uIF9fYWxsb2NTdHJpbmcoc3RyKSB7XG4gICAgY29uc3QgbGVuZ3RoID0gc3RyLmxlbmd0aDtcbiAgICBjb25zdCBwdHIgPSBhbGxvYyhsZW5ndGggPDwgMSwgU1RSSU5HX0lEKTtcbiAgICBjb25zdCBVMTYgPSBuZXcgVWludDE2QXJyYXkobWVtb3J5LmJ1ZmZlcik7XG4gICAgZm9yICh2YXIgaSA9IDAsIHAgPSBwdHIgPj4+IDE7IGkgPCBsZW5ndGg7ICsraSkgVTE2W3AgKyBpXSA9IHN0ci5jaGFyQ29kZUF0KGkpO1xuICAgIHJldHVybiBwdHI7XG4gIH1cblxuICBiYXNlTW9kdWxlLl9fYWxsb2NTdHJpbmcgPSBfX2FsbG9jU3RyaW5nO1xuXG4gIC8qKiBSZWFkcyBhIHN0cmluZyBmcm9tIHRoZSBtb2R1bGUncyBtZW1vcnkgYnkgaXRzIHBvaW50ZXIuICovXG4gIGZ1bmN0aW9uIF9fZ2V0U3RyaW5nKHB0cikge1xuICAgIGNvbnN0IGJ1ZmZlciA9IG1lbW9yeS5idWZmZXI7XG4gICAgY29uc3QgaWQgPSBuZXcgVWludDMyQXJyYXkoYnVmZmVyKVtwdHIgKyBJRF9PRkZTRVQgPj4+IDJdO1xuICAgIGlmIChpZCAhPT0gU1RSSU5HX0lEKSB0aHJvdyBFcnJvcihcIm5vdCBhIHN0cmluZzogXCIgKyBwdHIpO1xuICAgIHJldHVybiBnZXRTdHJpbmdJbXBsKGJ1ZmZlciwgcHRyKTtcbiAgfVxuXG4gIGJhc2VNb2R1bGUuX19nZXRTdHJpbmcgPSBfX2dldFN0cmluZztcblxuICAvKiogR2V0cyB0aGUgdmlldyBtYXRjaGluZyB0aGUgc3BlY2lmaWVkIGFsaWdubWVudCwgc2lnbmVkbmVzcyBhbmQgZmxvYXRuZXNzLiAqL1xuICBmdW5jdGlvbiBnZXRWaWV3KGFsaWduTG9nMiwgc2lnbmVkLCBmbG9hdCkge1xuICAgIGNvbnN0IGJ1ZmZlciA9IG1lbW9yeS5idWZmZXI7XG4gICAgaWYgKGZsb2F0KSB7XG4gICAgICBzd2l0Y2ggKGFsaWduTG9nMikge1xuICAgICAgICBjYXNlIDI6IHJldHVybiBuZXcgRmxvYXQzMkFycmF5KGJ1ZmZlcik7XG4gICAgICAgIGNhc2UgMzogcmV0dXJuIG5ldyBGbG9hdDY0QXJyYXkoYnVmZmVyKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgc3dpdGNoIChhbGlnbkxvZzIpIHtcbiAgICAgICAgY2FzZSAwOiByZXR1cm4gbmV3IChzaWduZWQgPyBJbnQ4QXJyYXkgOiBVaW50OEFycmF5KShidWZmZXIpO1xuICAgICAgICBjYXNlIDE6IHJldHVybiBuZXcgKHNpZ25lZCA/IEludDE2QXJyYXkgOiBVaW50MTZBcnJheSkoYnVmZmVyKTtcbiAgICAgICAgY2FzZSAyOiByZXR1cm4gbmV3IChzaWduZWQgPyBJbnQzMkFycmF5IDogVWludDMyQXJyYXkpKGJ1ZmZlcik7XG4gICAgICAgIGNhc2UgMzogcmV0dXJuIG5ldyAoc2lnbmVkID8gQmlnSW50NjRBcnJheSA6IEJpZ1VpbnQ2NEFycmF5KShidWZmZXIpO1xuICAgICAgfVxuICAgIH1cbiAgICB0aHJvdyBFcnJvcihcInVuc3VwcG9ydGVkIGFsaWduOiBcIiArIGFsaWduTG9nMik7XG4gIH1cblxuICAvKiogQWxsb2NhdGVzIGEgbmV3IGFycmF5IGluIHRoZSBtb2R1bGUncyBtZW1vcnkgYW5kIHJldHVybnMgaXRzIHJldGFpbmVkIHBvaW50ZXIuICovXG4gIGZ1bmN0aW9uIF9fYWxsb2NBcnJheShpZCwgdmFsdWVzKSB7XG4gICAgY29uc3QgaW5mbyA9IGdldEluZm8oaWQpO1xuICAgIGlmICghKGluZm8gJiAoQVJSQVlCVUZGRVJWSUVXIHwgQVJSQVkpKSkgdGhyb3cgRXJyb3IoXCJub3QgYW4gYXJyYXk6IFwiICsgaWQgKyBcIiBAIFwiICsgaW5mbyk7XG4gICAgY29uc3QgYWxpZ24gPSBnZXRWYWx1ZUFsaWduKGluZm8pO1xuICAgIGNvbnN0IGxlbmd0aCA9IHZhbHVlcy5sZW5ndGg7XG4gICAgY29uc3QgYnVmID0gYWxsb2MobGVuZ3RoIDw8IGFsaWduLCBBUlJBWUJVRkZFUl9JRCk7XG4gICAgY29uc3QgYXJyID0gYWxsb2MoaW5mbyAmIEFSUkFZID8gQVJSQVlfU0laRSA6IEFSUkFZQlVGRkVSVklFV19TSVpFLCBpZCk7XG4gICAgY29uc3QgVTMyID0gbmV3IFVpbnQzMkFycmF5KG1lbW9yeS5idWZmZXIpO1xuICAgIFUzMlthcnIgKyBBUlJBWUJVRkZFUlZJRVdfQlVGRkVSX09GRlNFVCA+Pj4gMl0gPSByZXRhaW4oYnVmKTtcbiAgICBVMzJbYXJyICsgQVJSQVlCVUZGRVJWSUVXX0RBVEFTVEFSVF9PRkZTRVQgPj4+IDJdID0gYnVmO1xuICAgIFUzMlthcnIgKyBBUlJBWUJVRkZFUlZJRVdfREFUQUxFTkdUSF9PRkZTRVQgPj4+IDJdID0gbGVuZ3RoIDw8IGFsaWduO1xuICAgIGlmIChpbmZvICYgQVJSQVkpIFUzMlthcnIgKyBBUlJBWV9MRU5HVEhfT0ZGU0VUID4+PiAyXSA9IGxlbmd0aDtcbiAgICBjb25zdCB2aWV3ID0gZ2V0VmlldyhhbGlnbiwgaW5mbyAmIFZBTF9TSUdORUQsIGluZm8gJiBWQUxfRkxPQVQpO1xuICAgIGlmIChpbmZvICYgVkFMX01BTkFHRUQpIHtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuZ3RoOyArK2kpIHZpZXdbKGJ1ZiA+Pj4gYWxpZ24pICsgaV0gPSByZXRhaW4odmFsdWVzW2ldKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmlldy5zZXQodmFsdWVzLCBidWYgPj4+IGFsaWduKTtcbiAgICB9XG4gICAgcmV0dXJuIGFycjtcbiAgfVxuXG4gIGJhc2VNb2R1bGUuX19hbGxvY0FycmF5ID0gX19hbGxvY0FycmF5O1xuXG4gIC8qKiBHZXRzIGEgbGl2ZSB2aWV3IG9uIGFuIGFycmF5J3MgdmFsdWVzIGluIHRoZSBtb2R1bGUncyBtZW1vcnkuIEluZmVycyB0aGUgYXJyYXkgdHlwZSBmcm9tIFJUVEkuICovXG4gIGZ1bmN0aW9uIF9fZ2V0QXJyYXlWaWV3KGFycikge1xuICAgIGNvbnN0IFUzMiA9IG5ldyBVaW50MzJBcnJheShtZW1vcnkuYnVmZmVyKTtcbiAgICBjb25zdCBpZCA9IFUzMlthcnIgKyBJRF9PRkZTRVQgPj4+IDJdO1xuICAgIGNvbnN0IGluZm8gPSBnZXRJbmZvKGlkKTtcbiAgICBpZiAoIShpbmZvICYgQVJSQVlCVUZGRVJWSUVXKSkgdGhyb3cgRXJyb3IoXCJub3QgYW4gYXJyYXk6IFwiICsgaWQpO1xuICAgIGNvbnN0IGFsaWduID0gZ2V0VmFsdWVBbGlnbihpbmZvKTtcbiAgICB2YXIgYnVmID0gVTMyW2FyciArIEFSUkFZQlVGRkVSVklFV19EQVRBU1RBUlRfT0ZGU0VUID4+PiAyXTtcbiAgICBjb25zdCBsZW5ndGggPSBpbmZvICYgQVJSQVlcbiAgICAgID8gVTMyW2FyciArIEFSUkFZX0xFTkdUSF9PRkZTRVQgPj4+IDJdXG4gICAgICA6IFUzMltidWYgKyBTSVpFX09GRlNFVCA+Pj4gMl0gPj4+IGFsaWduO1xuICAgIHJldHVybiBnZXRWaWV3KGFsaWduLCBpbmZvICYgVkFMX1NJR05FRCwgaW5mbyAmIFZBTF9GTE9BVClcbiAgICAgICAgICAuc3ViYXJyYXkoYnVmID4+Pj0gYWxpZ24sIGJ1ZiArIGxlbmd0aCk7XG4gIH1cblxuICBiYXNlTW9kdWxlLl9fZ2V0QXJyYXlWaWV3ID0gX19nZXRBcnJheVZpZXc7XG5cbiAgLyoqIENvcGllcyBhbiBhcnJheSdzIHZhbHVlcyBmcm9tIHRoZSBtb2R1bGUncyBtZW1vcnkuIEluZmVycyB0aGUgYXJyYXkgdHlwZSBmcm9tIFJUVEkuICovXG4gIGZ1bmN0aW9uIF9fZ2V0QXJyYXkoYXJyKSB7XG4gICAgY29uc3QgaW5wdXQgPSBfX2dldEFycmF5VmlldyhhcnIpO1xuICAgIGNvbnN0IGxlbiA9IGlucHV0Lmxlbmd0aDtcbiAgICBjb25zdCBvdXQgPSBuZXcgQXJyYXkobGVuKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbjsgaSsrKSBvdXRbaV0gPSBpbnB1dFtpXTtcbiAgICByZXR1cm4gb3V0O1xuICB9XG5cbiAgYmFzZU1vZHVsZS5fX2dldEFycmF5ID0gX19nZXRBcnJheTtcblxuICAvKiogQ29waWVzIGFuIEFycmF5QnVmZmVyJ3MgdmFsdWUgZnJvbSB0aGUgbW9kdWxlJ3MgbWVtb3J5LiAqL1xuICBmdW5jdGlvbiBfX2dldEFycmF5QnVmZmVyKHB0cikge1xuICAgIGNvbnN0IGJ1ZmZlciA9IG1lbW9yeS5idWZmZXI7XG4gICAgY29uc3QgbGVuZ3RoID0gbmV3IFVpbnQzMkFycmF5KGJ1ZmZlcilbcHRyICsgU0laRV9PRkZTRVQgPj4+IDJdO1xuICAgIHJldHVybiBidWZmZXIuc2xpY2UocHRyLCBwdHIgKyBsZW5ndGgpO1xuICB9XG5cbiAgYmFzZU1vZHVsZS5fX2dldEFycmF5QnVmZmVyID0gX19nZXRBcnJheUJ1ZmZlcjtcblxuICAvKiogQ29waWVzIGEgdHlwZWQgYXJyYXkncyB2YWx1ZXMgZnJvbSB0aGUgbW9kdWxlJ3MgbWVtb3J5LiAqL1xuICBmdW5jdGlvbiBnZXRUeXBlZEFycmF5KFR5cGUsIGFsaWduTG9nMiwgcHRyKSB7XG4gICAgcmV0dXJuIG5ldyBUeXBlKGdldFR5cGVkQXJyYXlWaWV3KFR5cGUsIGFsaWduTG9nMiwgcHRyKSk7XG4gIH1cblxuICAvKiogR2V0cyBhIGxpdmUgdmlldyBvbiBhIHR5cGVkIGFycmF5J3MgdmFsdWVzIGluIHRoZSBtb2R1bGUncyBtZW1vcnkuICovXG4gIGZ1bmN0aW9uIGdldFR5cGVkQXJyYXlWaWV3KFR5cGUsIGFsaWduTG9nMiwgcHRyKSB7XG4gICAgY29uc3QgYnVmZmVyID0gbWVtb3J5LmJ1ZmZlcjtcbiAgICBjb25zdCBVMzIgPSBuZXcgVWludDMyQXJyYXkoYnVmZmVyKTtcbiAgICBjb25zdCBidWZQdHIgPSBVMzJbcHRyICsgQVJSQVlCVUZGRVJWSUVXX0RBVEFTVEFSVF9PRkZTRVQgPj4+IDJdO1xuICAgIHJldHVybiBuZXcgVHlwZShidWZmZXIsIGJ1ZlB0ciwgVTMyW2J1ZlB0ciArIFNJWkVfT0ZGU0VUID4+PiAyXSA+Pj4gYWxpZ25Mb2cyKTtcbiAgfVxuXG4gIGJhc2VNb2R1bGUuX19nZXRJbnQ4QXJyYXkgPSBnZXRUeXBlZEFycmF5LmJpbmQobnVsbCwgSW50OEFycmF5LCAwKTtcbiAgYmFzZU1vZHVsZS5fX2dldEludDhBcnJheVZpZXcgPSBnZXRUeXBlZEFycmF5Vmlldy5iaW5kKG51bGwsIEludDhBcnJheSwgMCk7XG4gIGJhc2VNb2R1bGUuX19nZXRVaW50OEFycmF5ID0gZ2V0VHlwZWRBcnJheS5iaW5kKG51bGwsIFVpbnQ4QXJyYXksIDApO1xuICBiYXNlTW9kdWxlLl9fZ2V0VWludDhBcnJheVZpZXcgPSBnZXRUeXBlZEFycmF5Vmlldy5iaW5kKG51bGwsIFVpbnQ4QXJyYXksIDApO1xuICBiYXNlTW9kdWxlLl9fZ2V0VWludDhDbGFtcGVkQXJyYXkgPSBnZXRUeXBlZEFycmF5LmJpbmQobnVsbCwgVWludDhDbGFtcGVkQXJyYXksIDApO1xuICBiYXNlTW9kdWxlLl9fZ2V0VWludDhDbGFtcGVkQXJyYXlWaWV3ID0gZ2V0VHlwZWRBcnJheVZpZXcuYmluZChudWxsLCBVaW50OENsYW1wZWRBcnJheSwgMCk7XG4gIGJhc2VNb2R1bGUuX19nZXRJbnQxNkFycmF5ID0gZ2V0VHlwZWRBcnJheS5iaW5kKG51bGwsIEludDE2QXJyYXksIDEpO1xuICBiYXNlTW9kdWxlLl9fZ2V0SW50MTZBcnJheVZpZXcgPSBnZXRUeXBlZEFycmF5Vmlldy5iaW5kKG51bGwsIEludDE2QXJyYXksIDEpO1xuICBiYXNlTW9kdWxlLl9fZ2V0VWludDE2QXJyYXkgPSBnZXRUeXBlZEFycmF5LmJpbmQobnVsbCwgVWludDE2QXJyYXksIDEpO1xuICBiYXNlTW9kdWxlLl9fZ2V0VWludDE2QXJyYXlWaWV3ID0gZ2V0VHlwZWRBcnJheVZpZXcuYmluZChudWxsLCBVaW50MTZBcnJheSwgMSk7XG4gIGJhc2VNb2R1bGUuX19nZXRJbnQzMkFycmF5ID0gZ2V0VHlwZWRBcnJheS5iaW5kKG51bGwsIEludDMyQXJyYXksIDIpO1xuICBiYXNlTW9kdWxlLl9fZ2V0SW50MzJBcnJheVZpZXcgPSBnZXRUeXBlZEFycmF5Vmlldy5iaW5kKG51bGwsIEludDMyQXJyYXksIDIpO1xuICBiYXNlTW9kdWxlLl9fZ2V0VWludDMyQXJyYXkgPSBnZXRUeXBlZEFycmF5LmJpbmQobnVsbCwgVWludDMyQXJyYXksIDIpO1xuICBiYXNlTW9kdWxlLl9fZ2V0VWludDMyQXJyYXlWaWV3ID0gZ2V0VHlwZWRBcnJheVZpZXcuYmluZChudWxsLCBVaW50MzJBcnJheSwgMik7XG4gIGlmIChCSUdJTlQpIHtcbiAgICBiYXNlTW9kdWxlLl9fZ2V0SW50NjRBcnJheSA9IGdldFR5cGVkQXJyYXkuYmluZChudWxsLCBCaWdJbnQ2NEFycmF5LCAzKTtcbiAgICBiYXNlTW9kdWxlLl9fZ2V0SW50NjRBcnJheVZpZXcgPSBnZXRUeXBlZEFycmF5Vmlldy5iaW5kKG51bGwsIEJpZ0ludDY0QXJyYXksIDMpO1xuICAgIGJhc2VNb2R1bGUuX19nZXRVaW50NjRBcnJheSA9IGdldFR5cGVkQXJyYXkuYmluZChudWxsLCBCaWdVaW50NjRBcnJheSwgMyk7XG4gICAgYmFzZU1vZHVsZS5fX2dldFVpbnQ2NEFycmF5VmlldyA9IGdldFR5cGVkQXJyYXlWaWV3LmJpbmQobnVsbCwgQmlnVWludDY0QXJyYXksIDMpO1xuICB9XG4gIGJhc2VNb2R1bGUuX19nZXRGbG9hdDMyQXJyYXkgPSBnZXRUeXBlZEFycmF5LmJpbmQobnVsbCwgRmxvYXQzMkFycmF5LCAyKTtcbiAgYmFzZU1vZHVsZS5fX2dldEZsb2F0MzJBcnJheVZpZXcgPSBnZXRUeXBlZEFycmF5Vmlldy5iaW5kKG51bGwsIEZsb2F0MzJBcnJheSwgMik7XG4gIGJhc2VNb2R1bGUuX19nZXRGbG9hdDY0QXJyYXkgPSBnZXRUeXBlZEFycmF5LmJpbmQobnVsbCwgRmxvYXQ2NEFycmF5LCAzKTtcbiAgYmFzZU1vZHVsZS5fX2dldEZsb2F0NjRBcnJheVZpZXcgPSBnZXRUeXBlZEFycmF5Vmlldy5iaW5kKG51bGwsIEZsb2F0NjRBcnJheSwgMyk7XG5cbiAgLyoqIFRlc3RzIHdoZXRoZXIgYW4gb2JqZWN0IGlzIGFuIGluc3RhbmNlIG9mIHRoZSBjbGFzcyByZXByZXNlbnRlZCBieSB0aGUgc3BlY2lmaWVkIGJhc2UgaWQuICovXG4gIGZ1bmN0aW9uIF9faW5zdGFuY2VvZihwdHIsIGJhc2VJZCkge1xuICAgIGNvbnN0IFUzMiA9IG5ldyBVaW50MzJBcnJheShtZW1vcnkuYnVmZmVyKTtcbiAgICB2YXIgaWQgPSBVMzJbKHB0ciArIElEX09GRlNFVCkgPj4+IDJdO1xuICAgIGlmIChpZCA8PSBVMzJbcnR0aUJhc2UgPj4+IDJdKSB7XG4gICAgICBkbyBpZiAoaWQgPT0gYmFzZUlkKSByZXR1cm4gdHJ1ZTtcbiAgICAgIHdoaWxlIChpZCA9IGdldEJhc2UoaWQpKTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgYmFzZU1vZHVsZS5fX2luc3RhbmNlb2YgPSBfX2luc3RhbmNlb2Y7XG5cbiAgLy8gUHVsbCBiYXNpYyBleHBvcnRzIHRvIGJhc2VNb2R1bGUgc28gY29kZSBpbiBwcmVJbnN0YW50aWF0ZSBjYW4gdXNlIHRoZW1cbiAgYmFzZU1vZHVsZS5tZW1vcnkgPSBiYXNlTW9kdWxlLm1lbW9yeSB8fCBtZW1vcnk7XG4gIGJhc2VNb2R1bGUudGFibGUgID0gYmFzZU1vZHVsZS50YWJsZSAgfHwgdGFibGU7XG5cbiAgLy8gRGVtYW5nbGUgZXhwb3J0cyBhbmQgcHJvdmlkZSB0aGUgdXN1YWwgdXRpbGl0eSBvbiB0aGUgcHJvdG90eXBlXG4gIHJldHVybiBkZW1hbmdsZShyYXdFeHBvcnRzLCBiYXNlTW9kdWxlKTtcbn1cblxuZnVuY3Rpb24gaXNSZXNwb25zZShvKSB7XG4gIHJldHVybiB0eXBlb2YgUmVzcG9uc2UgIT09IFwidW5kZWZpbmVkXCIgJiYgbyBpbnN0YW5jZW9mIFJlc3BvbnNlO1xufVxuXG4vKiogQXN5bmNocm9ub3VzbHkgaW5zdGFudGlhdGVzIGFuIEFzc2VtYmx5U2NyaXB0IG1vZHVsZSBmcm9tIGFueXRoaW5nIHRoYXQgY2FuIGJlIGluc3RhbnRpYXRlZC4gKi9cbmFzeW5jIGZ1bmN0aW9uIGluc3RhbnRpYXRlKHNvdXJjZSwgaW1wb3J0cykge1xuICBpZiAoaXNSZXNwb25zZShzb3VyY2UgPSBhd2FpdCBzb3VyY2UpKSByZXR1cm4gaW5zdGFudGlhdGVTdHJlYW1pbmcoc291cmNlLCBpbXBvcnRzKTtcbiAgcmV0dXJuIHBvc3RJbnN0YW50aWF0ZShcbiAgICBwcmVJbnN0YW50aWF0ZShpbXBvcnRzIHx8IChpbXBvcnRzID0ge30pKSxcbiAgICBhd2FpdCBXZWJBc3NlbWJseS5pbnN0YW50aWF0ZShcbiAgICAgIHNvdXJjZSBpbnN0YW5jZW9mIFdlYkFzc2VtYmx5Lk1vZHVsZVxuICAgICAgICA/IHNvdXJjZVxuICAgICAgICA6IGF3YWl0IFdlYkFzc2VtYmx5LmNvbXBpbGUoc291cmNlKSxcbiAgICAgIGltcG9ydHNcbiAgICApXG4gICk7XG59XG5cbmV4cG9ydHMuaW5zdGFudGlhdGUgPSBpbnN0YW50aWF0ZTtcblxuLyoqIFN5bmNocm9ub3VzbHkgaW5zdGFudGlhdGVzIGFuIEFzc2VtYmx5U2NyaXB0IG1vZHVsZSBmcm9tIGEgV2ViQXNzZW1ibHkuTW9kdWxlIG9yIGJpbmFyeSBidWZmZXIuICovXG5mdW5jdGlvbiBpbnN0YW50aWF0ZVN5bmMoc291cmNlLCBpbXBvcnRzKSB7XG4gIHJldHVybiBwb3N0SW5zdGFudGlhdGUoXG4gICAgcHJlSW5zdGFudGlhdGUoaW1wb3J0cyB8fCAoaW1wb3J0cyA9IHt9KSksXG4gICAgbmV3IFdlYkFzc2VtYmx5Lkluc3RhbmNlKFxuICAgICAgc291cmNlIGluc3RhbmNlb2YgV2ViQXNzZW1ibHkuTW9kdWxlXG4gICAgICAgID8gc291cmNlXG4gICAgICAgIDogbmV3IFdlYkFzc2VtYmx5Lk1vZHVsZShzb3VyY2UpLFxuICAgICAgaW1wb3J0c1xuICAgIClcbiAgKVxufVxuXG5leHBvcnRzLmluc3RhbnRpYXRlU3luYyA9IGluc3RhbnRpYXRlU3luYztcblxuLyoqIEFzeW5jaHJvbm91c2x5IGluc3RhbnRpYXRlcyBhbiBBc3NlbWJseVNjcmlwdCBtb2R1bGUgZnJvbSBhIHJlc3BvbnNlLCBpLmUuIGFzIG9idGFpbmVkIGJ5IGBmZXRjaGAuICovXG5hc3luYyBmdW5jdGlvbiBpbnN0YW50aWF0ZVN0cmVhbWluZyhzb3VyY2UsIGltcG9ydHMpIHtcbiAgaWYgKCFXZWJBc3NlbWJseS5pbnN0YW50aWF0ZVN0cmVhbWluZykge1xuICAgIHJldHVybiBpbnN0YW50aWF0ZShcbiAgICAgIGlzUmVzcG9uc2Uoc291cmNlID0gYXdhaXQgc291cmNlKVxuICAgICAgICA/IHNvdXJjZS5hcnJheUJ1ZmZlcigpXG4gICAgICAgIDogc291cmNlLFxuICAgICAgaW1wb3J0c1xuICAgICk7XG4gIH1cbiAgcmV0dXJuIHBvc3RJbnN0YW50aWF0ZShcbiAgICBwcmVJbnN0YW50aWF0ZShpbXBvcnRzIHx8IChpbXBvcnRzID0ge30pKSxcbiAgICAoYXdhaXQgV2ViQXNzZW1ibHkuaW5zdGFudGlhdGVTdHJlYW1pbmcoc291cmNlLCBpbXBvcnRzKSkuaW5zdGFuY2VcbiAgKTtcbn1cblxuZXhwb3J0cy5pbnN0YW50aWF0ZVN0cmVhbWluZyA9IGluc3RhbnRpYXRlU3RyZWFtaW5nO1xuXG4vKiogRGVtYW5nbGVzIGFuIEFzc2VtYmx5U2NyaXB0IG1vZHVsZSdzIGV4cG9ydHMgdG8gYSBmcmllbmRseSBvYmplY3Qgc3RydWN0dXJlLiAqL1xuZnVuY3Rpb24gZGVtYW5nbGUoZXhwb3J0cywgYmFzZU1vZHVsZSkge1xuICB2YXIgbW9kdWxlID0gYmFzZU1vZHVsZSA/IE9iamVjdC5jcmVhdGUoYmFzZU1vZHVsZSkgOiB7fTtcbiAgdmFyIHNldEFyZ3VtZW50c0xlbmd0aCA9IGV4cG9ydHNbXCJfX2FyZ3VtZW50c0xlbmd0aFwiXVxuICAgID8gZnVuY3Rpb24obGVuZ3RoKSB7IGV4cG9ydHNbXCJfX2FyZ3VtZW50c0xlbmd0aFwiXS52YWx1ZSA9IGxlbmd0aDsgfVxuICAgIDogZXhwb3J0c1tcIl9fc2V0QXJndW1lbnRzTGVuZ3RoXCJdIHx8IGV4cG9ydHNbXCJfX3NldGFyZ2NcIl0gfHwgZnVuY3Rpb24oKSB7fTtcbiAgZm9yIChsZXQgaW50ZXJuYWxOYW1lIGluIGV4cG9ydHMpIHtcbiAgICBpZiAoIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChleHBvcnRzLCBpbnRlcm5hbE5hbWUpKSBjb250aW51ZTtcbiAgICBjb25zdCBlbGVtID0gZXhwb3J0c1tpbnRlcm5hbE5hbWVdO1xuICAgIGxldCBwYXJ0cyA9IGludGVybmFsTmFtZS5zcGxpdChcIi5cIik7XG4gICAgbGV0IGN1cnIgPSBtb2R1bGU7XG4gICAgd2hpbGUgKHBhcnRzLmxlbmd0aCA+IDEpIHtcbiAgICAgIGxldCBwYXJ0ID0gcGFydHMuc2hpZnQoKTtcbiAgICAgIGlmICghT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGN1cnIsIHBhcnQpKSBjdXJyW3BhcnRdID0ge307XG4gICAgICBjdXJyID0gY3VycltwYXJ0XTtcbiAgICB9XG4gICAgbGV0IG5hbWUgPSBwYXJ0c1swXTtcbiAgICBsZXQgaGFzaCA9IG5hbWUuaW5kZXhPZihcIiNcIik7XG4gICAgaWYgKGhhc2ggPj0gMCkge1xuICAgICAgbGV0IGNsYXNzTmFtZSA9IG5hbWUuc3Vic3RyaW5nKDAsIGhhc2gpO1xuICAgICAgbGV0IGNsYXNzRWxlbSA9IGN1cnJbY2xhc3NOYW1lXTtcbiAgICAgIGlmICh0eXBlb2YgY2xhc3NFbGVtID09PSBcInVuZGVmaW5lZFwiIHx8ICFjbGFzc0VsZW0ucHJvdG90eXBlKSB7XG4gICAgICAgIGxldCBjdG9yID0gZnVuY3Rpb24oLi4uYXJncykge1xuICAgICAgICAgIHJldHVybiBjdG9yLndyYXAoY3Rvci5wcm90b3R5cGUuY29uc3RydWN0b3IoMCwgLi4uYXJncykpO1xuICAgICAgICB9O1xuICAgICAgICBjdG9yLnByb3RvdHlwZSA9IHtcbiAgICAgICAgICB2YWx1ZU9mOiBmdW5jdGlvbiB2YWx1ZU9mKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXNbVEhJU107XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBjdG9yLndyYXAgPSBmdW5jdGlvbih0aGlzVmFsdWUpIHtcbiAgICAgICAgICByZXR1cm4gT2JqZWN0LmNyZWF0ZShjdG9yLnByb3RvdHlwZSwgeyBbVEhJU106IHsgdmFsdWU6IHRoaXNWYWx1ZSwgd3JpdGFibGU6IGZhbHNlIH0gfSk7XG4gICAgICAgIH07XG4gICAgICAgIGlmIChjbGFzc0VsZW0pIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKGNsYXNzRWxlbSkuZm9yRWFjaChuYW1lID0+XG4gICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGN0b3IsIG5hbWUsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoY2xhc3NFbGVtLCBuYW1lKSlcbiAgICAgICAgKTtcbiAgICAgICAgY3VycltjbGFzc05hbWVdID0gY3RvcjtcbiAgICAgIH1cbiAgICAgIG5hbWUgPSBuYW1lLnN1YnN0cmluZyhoYXNoICsgMSk7XG4gICAgICBjdXJyID0gY3VycltjbGFzc05hbWVdLnByb3RvdHlwZTtcbiAgICAgIGlmICgvXihnZXR8c2V0KTovLnRlc3QobmFtZSkpIHtcbiAgICAgICAgaWYgKCFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoY3VyciwgbmFtZSA9IG5hbWUuc3Vic3RyaW5nKDQpKSkge1xuICAgICAgICAgIGxldCBnZXR0ZXIgPSBleHBvcnRzW2ludGVybmFsTmFtZS5yZXBsYWNlKFwic2V0OlwiLCBcImdldDpcIildO1xuICAgICAgICAgIGxldCBzZXR0ZXIgPSBleHBvcnRzW2ludGVybmFsTmFtZS5yZXBsYWNlKFwiZ2V0OlwiLCBcInNldDpcIildO1xuICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShjdXJyLCBuYW1lLCB7XG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gZ2V0dGVyKHRoaXNbVEhJU10pOyB9LFxuICAgICAgICAgICAgc2V0OiBmdW5jdGlvbih2YWx1ZSkgeyBzZXR0ZXIodGhpc1tUSElTXSwgdmFsdWUpOyB9LFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAobmFtZSA9PT0gJ2NvbnN0cnVjdG9yJykge1xuICAgICAgICAgIChjdXJyW25hbWVdID0gKC4uLmFyZ3MpID0+IHtcbiAgICAgICAgICAgIHNldEFyZ3VtZW50c0xlbmd0aChhcmdzLmxlbmd0aCk7XG4gICAgICAgICAgICByZXR1cm4gZWxlbSguLi5hcmdzKTtcbiAgICAgICAgICB9KS5vcmlnaW5hbCA9IGVsZW07XG4gICAgICAgIH0gZWxzZSB7IC8vIGluc3RhbmNlIG1ldGhvZFxuICAgICAgICAgIChjdXJyW25hbWVdID0gZnVuY3Rpb24oLi4uYXJncykgeyAvLyAhXG4gICAgICAgICAgICBzZXRBcmd1bWVudHNMZW5ndGgoYXJncy5sZW5ndGgpO1xuICAgICAgICAgICAgcmV0dXJuIGVsZW0odGhpc1tUSElTXSwgLi4uYXJncyk7XG4gICAgICAgICAgfSkub3JpZ2luYWwgPSBlbGVtO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICgvXihnZXR8c2V0KTovLnRlc3QobmFtZSkpIHtcbiAgICAgICAgaWYgKCFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoY3VyciwgbmFtZSA9IG5hbWUuc3Vic3RyaW5nKDQpKSkge1xuICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShjdXJyLCBuYW1lLCB7XG4gICAgICAgICAgICBnZXQ6IGV4cG9ydHNbaW50ZXJuYWxOYW1lLnJlcGxhY2UoXCJzZXQ6XCIsIFwiZ2V0OlwiKV0sXG4gICAgICAgICAgICBzZXQ6IGV4cG9ydHNbaW50ZXJuYWxOYW1lLnJlcGxhY2UoXCJnZXQ6XCIsIFwic2V0OlwiKV0sXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGVsZW0gPT09IFwiZnVuY3Rpb25cIiAmJiBlbGVtICE9PSBzZXRBcmd1bWVudHNMZW5ndGgpIHtcbiAgICAgICAgKGN1cnJbbmFtZV0gPSAoLi4uYXJncykgPT4ge1xuICAgICAgICAgIHNldEFyZ3VtZW50c0xlbmd0aChhcmdzLmxlbmd0aCk7XG4gICAgICAgICAgcmV0dXJuIGVsZW0oLi4uYXJncyk7XG4gICAgICAgIH0pLm9yaWdpbmFsID0gZWxlbTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGN1cnJbbmFtZV0gPSBlbGVtO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gbW9kdWxlO1xufVxuXG5leHBvcnRzLmRlbWFuZ2xlID0gZGVtYW5nbGU7XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@assemblyscript/loader/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@assemblyscript/loader/index.js":
/*!******************************************************!*\
  !*** ./node_modules/@assemblyscript/loader/index.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\n\n// Runtime header offsets\nconst ID_OFFSET = -8;\nconst SIZE_OFFSET = -4;\n\n// Runtime ids\nconst ARRAYBUFFER_ID = 0;\nconst STRING_ID = 1;\nconst ARRAYBUFFERVIEW_ID = 2;\n\n// Runtime type information\nconst ARRAYBUFFERVIEW = 1 << 0;\nconst ARRAY = 1 << 1;\nconst SET = 1 << 2;\nconst MAP = 1 << 3;\nconst VAL_ALIGN_OFFSET = 5;\nconst VAL_ALIGN = 1 << VAL_ALIGN_OFFSET;\nconst VAL_SIGNED = 1 << 10;\nconst VAL_FLOAT = 1 << 11;\nconst VAL_NULLABLE = 1 << 12;\nconst VAL_MANAGED = 1 << 13;\nconst KEY_ALIGN_OFFSET = 14;\nconst KEY_ALIGN = 1 << KEY_ALIGN_OFFSET;\nconst KEY_SIGNED = 1 << 19;\nconst KEY_FLOAT = 1 << 20;\nconst KEY_NULLABLE = 1 << 21;\nconst KEY_MANAGED = 1 << 22;\n\n// Array(BufferView) layout\nconst ARRAYBUFFERVIEW_BUFFER_OFFSET = 0;\nconst ARRAYBUFFERVIEW_DATASTART_OFFSET = 4;\nconst ARRAYBUFFERVIEW_DATALENGTH_OFFSET = 8;\nconst ARRAYBUFFERVIEW_SIZE = 12;\nconst ARRAY_LENGTH_OFFSET = 12;\nconst ARRAY_SIZE = 16;\n\nconst BIGINT = typeof BigUint64Array !== \"undefined\";\nconst THIS = Symbol();\nconst CHUNKSIZE = 1024;\n\n/** Gets a string from an U32 and an U16 view on a memory. */\nfunction getStringImpl(buffer, ptr) {\n  const U32 = new Uint32Array(buffer);\n  const U16 = new Uint16Array(buffer);\n  var length = U32[(ptr + SIZE_OFFSET) >>> 2] >>> 1;\n  var offset = ptr >>> 1;\n  if (length <= CHUNKSIZE) return String.fromCharCode.apply(String, U16.subarray(offset, offset + length));\n  const parts = [];\n  do {\n    const last = U16[offset + CHUNKSIZE - 1];\n    const size = last >= 0xD800 && last < 0xDC00 ? CHUNKSIZE - 1 : CHUNKSIZE;\n    parts.push(String.fromCharCode.apply(String, U16.subarray(offset, offset += size)));\n    length -= size;\n  } while (length > CHUNKSIZE);\n  return parts.join(\"\") + String.fromCharCode.apply(String, U16.subarray(offset, offset + length));\n}\n\n/** Prepares the base module prior to instantiation. */\nfunction preInstantiate(imports) {\n  const baseModule = {};\n\n  function getString(memory, ptr) {\n    if (!memory) return \"<yet unknown>\";\n    return getStringImpl(memory.buffer, ptr);\n  }\n\n  // add common imports used by stdlib for convenience\n  const env = (imports.env = imports.env || {});\n  env.abort = env.abort || function abort(mesg, file, line, colm) {\n    const memory = baseModule.memory || env.memory; // prefer exported, otherwise try imported\n    throw Error(\"abort: \" + getString(memory, mesg) + \" at \" + getString(memory, file) + \":\" + line + \":\" + colm);\n  }\n  env.trace = env.trace || function trace(mesg, n) {\n    const memory = baseModule.memory || env.memory;\n    console.log(\"trace: \" + getString(memory, mesg) + (n ? \" \" : \"\") + Array.prototype.slice.call(arguments, 2, 2 + n).join(\", \"));\n  }\n  imports.Math = imports.Math || Math;\n  imports.Date = imports.Date || Date;\n\n  return baseModule;\n}\n\n/** Prepares the final module once instantiation is complete. */\nfunction postInstantiate(baseModule, instance) {\n  const rawExports = instance.exports;\n  const memory = rawExports.memory;\n  const table = rawExports.table;\n  const alloc = rawExports[\"__alloc\"];\n  const retain = rawExports[\"__retain\"];\n  const rttiBase = rawExports[\"__rtti_base\"] || ~0; // oob if not present\n\n  /** Gets the runtime type info for the given id. */\n  function getInfo(id) {\n    const U32 = new Uint32Array(memory.buffer);\n    const count = U32[rttiBase >>> 2];\n    if ((id >>>= 0) >= count) throw Error(\"invalid id: \" + id);\n    return U32[(rttiBase + 4 >>> 2) + id * 2];\n  }\n\n  /** Gets the runtime base id for the given id. */\n  function getBase(id) {\n    const U32 = new Uint32Array(memory.buffer);\n    const count = U32[rttiBase >>> 2];\n    if ((id >>>= 0) >= count) throw Error(\"invalid id: \" + id);\n    return U32[(rttiBase + 4 >>> 2) + id * 2 + 1];\n  }\n\n  /** Gets the runtime alignment of a collection's values. */\n  function getValueAlign(info) {\n    return 31 - Math.clz32((info >>> VAL_ALIGN_OFFSET) & 31); // -1 if none\n  }\n\n  /** Gets the runtime alignment of a collection's keys. */\n  function getKeyAlign(info) {\n    return 31 - Math.clz32((info >>> KEY_ALIGN_OFFSET) & 31); // -1 if none\n  }\n\n  /** Allocates a new string in the module's memory and returns its retained pointer. */\n  function __allocString(str) {\n    const length = str.length;\n    const ptr = alloc(length << 1, STRING_ID);\n    const U16 = new Uint16Array(memory.buffer);\n    for (var i = 0, p = ptr >>> 1; i < length; ++i) U16[p + i] = str.charCodeAt(i);\n    return ptr;\n  }\n\n  baseModule.__allocString = __allocString;\n\n  /** Reads a string from the module's memory by its pointer. */\n  function __getString(ptr) {\n    const buffer = memory.buffer;\n    const id = new Uint32Array(buffer)[ptr + ID_OFFSET >>> 2];\n    if (id !== STRING_ID) throw Error(\"not a string: \" + ptr);\n    return getStringImpl(buffer, ptr);\n  }\n\n  baseModule.__getString = __getString;\n\n  /** Gets the view matching the specified alignment, signedness and floatness. */\n  function getView(alignLog2, signed, float) {\n    const buffer = memory.buffer;\n    if (float) {\n      switch (alignLog2) {\n        case 2: return new Float32Array(buffer);\n        case 3: return new Float64Array(buffer);\n      }\n    } else {\n      switch (alignLog2) {\n        case 0: return new (signed ? Int8Array : Uint8Array)(buffer);\n        case 1: return new (signed ? Int16Array : Uint16Array)(buffer);\n        case 2: return new (signed ? Int32Array : Uint32Array)(buffer);\n        case 3: return new (signed ? BigInt64Array : BigUint64Array)(buffer);\n      }\n    }\n    throw Error(\"unsupported align: \" + alignLog2);\n  }\n\n  /** Allocates a new array in the module's memory and returns its retained pointer. */\n  function __allocArray(id, values) {\n    const info = getInfo(id);\n    if (!(info & (ARRAYBUFFERVIEW | ARRAY))) throw Error(\"not an array: \" + id + \" @ \" + info);\n    const align = getValueAlign(info);\n    const length = values.length;\n    const buf = alloc(length << align, ARRAYBUFFER_ID);\n    const arr = alloc(info & ARRAY ? ARRAY_SIZE : ARRAYBUFFERVIEW_SIZE, id);\n    const U32 = new Uint32Array(memory.buffer);\n    U32[arr + ARRAYBUFFERVIEW_BUFFER_OFFSET >>> 2] = retain(buf);\n    U32[arr + ARRAYBUFFERVIEW_DATASTART_OFFSET >>> 2] = buf;\n    U32[arr + ARRAYBUFFERVIEW_DATALENGTH_OFFSET >>> 2] = length << align;\n    if (info & ARRAY) U32[arr + ARRAY_LENGTH_OFFSET >>> 2] = length;\n    const view = getView(align, info & VAL_SIGNED, info & VAL_FLOAT);\n    if (info & VAL_MANAGED) {\n      for (let i = 0; i < length; ++i) view[(buf >>> align) + i] = retain(values[i]);\n    } else {\n      view.set(values, buf >>> align);\n    }\n    return arr;\n  }\n\n  baseModule.__allocArray = __allocArray;\n\n  /** Gets a live view on an array's values in the module's memory. Infers the array type from RTTI. */\n  function __getArrayView(arr) {\n    const U32 = new Uint32Array(memory.buffer);\n    const id = U32[arr + ID_OFFSET >>> 2];\n    const info = getInfo(id);\n    if (!(info & ARRAYBUFFERVIEW)) throw Error(\"not an array: \" + id);\n    const align = getValueAlign(info);\n    var buf = U32[arr + ARRAYBUFFERVIEW_DATASTART_OFFSET >>> 2];\n    const length = info & ARRAY\n      ? U32[arr + ARRAY_LENGTH_OFFSET >>> 2]\n      : U32[buf + SIZE_OFFSET >>> 2] >>> align;\n    return getView(align, info & VAL_SIGNED, info & VAL_FLOAT)\n          .subarray(buf >>>= align, buf + length);\n  }\n\n  baseModule.__getArrayView = __getArrayView;\n\n  /** Copies an array's values from the module's memory. Infers the array type from RTTI. */\n  function __getArray(arr) {\n    const input = __getArrayView(arr);\n    const len = input.length;\n    const out = new Array(len);\n    for (let i = 0; i < len; i++) out[i] = input[i];\n    return out;\n  }\n\n  baseModule.__getArray = __getArray;\n\n  /** Copies an ArrayBuffer's value from the module's memory. */\n  function __getArrayBuffer(ptr) {\n    const buffer = memory.buffer;\n    const length = new Uint32Array(buffer)[ptr + SIZE_OFFSET >>> 2];\n    return buffer.slice(ptr, ptr + length);\n  }\n\n  baseModule.__getArrayBuffer = __getArrayBuffer;\n\n  /** Copies a typed array's values from the module's memory. */\n  function getTypedArray(Type, alignLog2, ptr) {\n    return new Type(getTypedArrayView(Type, alignLog2, ptr));\n  }\n\n  /** Gets a live view on a typed array's values in the module's memory. */\n  function getTypedArrayView(Type, alignLog2, ptr) {\n    const buffer = memory.buffer;\n    const U32 = new Uint32Array(buffer);\n    const bufPtr = U32[ptr + ARRAYBUFFERVIEW_DATASTART_OFFSET >>> 2];\n    return new Type(buffer, bufPtr, U32[bufPtr + SIZE_OFFSET >>> 2] >>> alignLog2);\n  }\n\n  baseModule.__getInt8Array = getTypedArray.bind(null, Int8Array, 0);\n  baseModule.__getInt8ArrayView = getTypedArrayView.bind(null, Int8Array, 0);\n  baseModule.__getUint8Array = getTypedArray.bind(null, Uint8Array, 0);\n  baseModule.__getUint8ArrayView = getTypedArrayView.bind(null, Uint8Array, 0);\n  baseModule.__getUint8ClampedArray = getTypedArray.bind(null, Uint8ClampedArray, 0);\n  baseModule.__getUint8ClampedArrayView = getTypedArrayView.bind(null, Uint8ClampedArray, 0);\n  baseModule.__getInt16Array = getTypedArray.bind(null, Int16Array, 1);\n  baseModule.__getInt16ArrayView = getTypedArrayView.bind(null, Int16Array, 1);\n  baseModule.__getUint16Array = getTypedArray.bind(null, Uint16Array, 1);\n  baseModule.__getUint16ArrayView = getTypedArrayView.bind(null, Uint16Array, 1);\n  baseModule.__getInt32Array = getTypedArray.bind(null, Int32Array, 2);\n  baseModule.__getInt32ArrayView = getTypedArrayView.bind(null, Int32Array, 2);\n  baseModule.__getUint32Array = getTypedArray.bind(null, Uint32Array, 2);\n  baseModule.__getUint32ArrayView = getTypedArrayView.bind(null, Uint32Array, 2);\n  if (BIGINT) {\n    baseModule.__getInt64Array = getTypedArray.bind(null, BigInt64Array, 3);\n    baseModule.__getInt64ArrayView = getTypedArrayView.bind(null, BigInt64Array, 3);\n    baseModule.__getUint64Array = getTypedArray.bind(null, BigUint64Array, 3);\n    baseModule.__getUint64ArrayView = getTypedArrayView.bind(null, BigUint64Array, 3);\n  }\n  baseModule.__getFloat32Array = getTypedArray.bind(null, Float32Array, 2);\n  baseModule.__getFloat32ArrayView = getTypedArrayView.bind(null, Float32Array, 2);\n  baseModule.__getFloat64Array = getTypedArray.bind(null, Float64Array, 3);\n  baseModule.__getFloat64ArrayView = getTypedArrayView.bind(null, Float64Array, 3);\n\n  /** Tests whether an object is an instance of the class represented by the specified base id. */\n  function __instanceof(ptr, baseId) {\n    const U32 = new Uint32Array(memory.buffer);\n    var id = U32[(ptr + ID_OFFSET) >>> 2];\n    if (id <= U32[rttiBase >>> 2]) {\n      do if (id == baseId) return true;\n      while (id = getBase(id));\n    }\n    return false;\n  }\n\n  baseModule.__instanceof = __instanceof;\n\n  // Pull basic exports to baseModule so code in preInstantiate can use them\n  baseModule.memory = baseModule.memory || memory;\n  baseModule.table  = baseModule.table  || table;\n\n  // Demangle exports and provide the usual utility on the prototype\n  return demangle(rawExports, baseModule);\n}\n\nfunction isResponse(o) {\n  return typeof Response !== \"undefined\" && o instanceof Response;\n}\n\n/** Asynchronously instantiates an AssemblyScript module from anything that can be instantiated. */\nasync function instantiate(source, imports) {\n  if (isResponse(source = await source)) return instantiateStreaming(source, imports);\n  return postInstantiate(\n    preInstantiate(imports || (imports = {})),\n    await WebAssembly.instantiate(\n      source instanceof WebAssembly.Module\n        ? source\n        : await WebAssembly.compile(source),\n      imports\n    )\n  );\n}\n\nexports.instantiate = instantiate;\n\n/** Synchronously instantiates an AssemblyScript module from a WebAssembly.Module or binary buffer. */\nfunction instantiateSync(source, imports) {\n  return postInstantiate(\n    preInstantiate(imports || (imports = {})),\n    new WebAssembly.Instance(\n      source instanceof WebAssembly.Module\n        ? source\n        : new WebAssembly.Module(source),\n      imports\n    )\n  )\n}\n\nexports.instantiateSync = instantiateSync;\n\n/** Asynchronously instantiates an AssemblyScript module from a response, i.e. as obtained by `fetch`. */\nasync function instantiateStreaming(source, imports) {\n  if (!WebAssembly.instantiateStreaming) {\n    return instantiate(\n      isResponse(source = await source)\n        ? source.arrayBuffer()\n        : source,\n      imports\n    );\n  }\n  return postInstantiate(\n    preInstantiate(imports || (imports = {})),\n    (await WebAssembly.instantiateStreaming(source, imports)).instance\n  );\n}\n\nexports.instantiateStreaming = instantiateStreaming;\n\n/** Demangles an AssemblyScript module's exports to a friendly object structure. */\nfunction demangle(exports, baseModule) {\n  var module = baseModule ? Object.create(baseModule) : {};\n  var setArgumentsLength = exports[\"__argumentsLength\"]\n    ? function(length) { exports[\"__argumentsLength\"].value = length; }\n    : exports[\"__setArgumentsLength\"] || exports[\"__setargc\"] || function() {};\n  for (let internalName in exports) {\n    if (!Object.prototype.hasOwnProperty.call(exports, internalName)) continue;\n    const elem = exports[internalName];\n    let parts = internalName.split(\".\");\n    let curr = module;\n    while (parts.length > 1) {\n      let part = parts.shift();\n      if (!Object.prototype.hasOwnProperty.call(curr, part)) curr[part] = {};\n      curr = curr[part];\n    }\n    let name = parts[0];\n    let hash = name.indexOf(\"#\");\n    if (hash >= 0) {\n      let className = name.substring(0, hash);\n      let classElem = curr[className];\n      if (typeof classElem === \"undefined\" || !classElem.prototype) {\n        let ctor = function(...args) {\n          return ctor.wrap(ctor.prototype.constructor(0, ...args));\n        };\n        ctor.prototype = {\n          valueOf: function valueOf() {\n            return this[THIS];\n          }\n        };\n        ctor.wrap = function(thisValue) {\n          return Object.create(ctor.prototype, { [THIS]: { value: thisValue, writable: false } });\n        };\n        if (classElem) Object.getOwnPropertyNames(classElem).forEach(name =>\n          Object.defineProperty(ctor, name, Object.getOwnPropertyDescriptor(classElem, name))\n        );\n        curr[className] = ctor;\n      }\n      name = name.substring(hash + 1);\n      curr = curr[className].prototype;\n      if (/^(get|set):/.test(name)) {\n        if (!Object.prototype.hasOwnProperty.call(curr, name = name.substring(4))) {\n          let getter = exports[internalName.replace(\"set:\", \"get:\")];\n          let setter = exports[internalName.replace(\"get:\", \"set:\")];\n          Object.defineProperty(curr, name, {\n            get: function() { return getter(this[THIS]); },\n            set: function(value) { setter(this[THIS], value); },\n            enumerable: true\n          });\n        }\n      } else {\n        if (name === 'constructor') {\n          (curr[name] = (...args) => {\n            setArgumentsLength(args.length);\n            return elem(...args);\n          }).original = elem;\n        } else { // instance method\n          (curr[name] = function(...args) { // !\n            setArgumentsLength(args.length);\n            return elem(this[THIS], ...args);\n          }).original = elem;\n        }\n      }\n    } else {\n      if (/^(get|set):/.test(name)) {\n        if (!Object.prototype.hasOwnProperty.call(curr, name = name.substring(4))) {\n          Object.defineProperty(curr, name, {\n            get: exports[internalName.replace(\"set:\", \"get:\")],\n            set: exports[internalName.replace(\"get:\", \"set:\")],\n            enumerable: true\n          });\n        }\n      } else if (typeof elem === \"function\" && elem !== setArgumentsLength) {\n        (curr[name] = (...args) => {\n          setArgumentsLength(args.length);\n          return elem(...args);\n        }).original = elem;\n      } else {\n        curr[name] = elem;\n      }\n    }\n  }\n  return module;\n}\n\nexports.demangle = demangle;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGFzc2VtYmx5c2NyaXB0L2xvYWRlci9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw4Q0FBOEM7QUFDOUM7QUFDQSxvREFBb0Q7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0RBQW9EOztBQUVwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsOERBQThEO0FBQzlEOztBQUVBO0FBQ0E7QUFDQSw4REFBOEQ7QUFDOUQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyxZQUFZO0FBQy9DO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLFlBQVk7QUFDbEMsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixTQUFTO0FBQzdCO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG1CQUFtQjs7QUFFbkI7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsdUJBQXVCOztBQUV2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDO0FBQzNDO0FBQ0E7QUFDQTs7QUFFQSw0QkFBNEI7O0FBRTVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQsVUFBVSxxQ0FBcUM7QUFDaEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsNEJBQTRCO0FBQzFELG1DQUFtQyw0QkFBNEI7QUFDL0Q7QUFDQSxXQUFXO0FBQ1g7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsVUFBVSxPQUFPO0FBQ2pCLDRDQUE0QztBQUM1QztBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGdCQUFnQiIsInNvdXJjZXMiOlsiL2hvbWUvYWx0Y29pbi1kYWRkeS9Eb3dubG9hZHMvb3dubHkvbm9kZV9tb2R1bGVzL0Bhc3NlbWJseXNjcmlwdC9sb2FkZXIvaW5kZXguanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5cbi8vIFJ1bnRpbWUgaGVhZGVyIG9mZnNldHNcbmNvbnN0IElEX09GRlNFVCA9IC04O1xuY29uc3QgU0laRV9PRkZTRVQgPSAtNDtcblxuLy8gUnVudGltZSBpZHNcbmNvbnN0IEFSUkFZQlVGRkVSX0lEID0gMDtcbmNvbnN0IFNUUklOR19JRCA9IDE7XG5jb25zdCBBUlJBWUJVRkZFUlZJRVdfSUQgPSAyO1xuXG4vLyBSdW50aW1lIHR5cGUgaW5mb3JtYXRpb25cbmNvbnN0IEFSUkFZQlVGRkVSVklFVyA9IDEgPDwgMDtcbmNvbnN0IEFSUkFZID0gMSA8PCAxO1xuY29uc3QgU0VUID0gMSA8PCAyO1xuY29uc3QgTUFQID0gMSA8PCAzO1xuY29uc3QgVkFMX0FMSUdOX09GRlNFVCA9IDU7XG5jb25zdCBWQUxfQUxJR04gPSAxIDw8IFZBTF9BTElHTl9PRkZTRVQ7XG5jb25zdCBWQUxfU0lHTkVEID0gMSA8PCAxMDtcbmNvbnN0IFZBTF9GTE9BVCA9IDEgPDwgMTE7XG5jb25zdCBWQUxfTlVMTEFCTEUgPSAxIDw8IDEyO1xuY29uc3QgVkFMX01BTkFHRUQgPSAxIDw8IDEzO1xuY29uc3QgS0VZX0FMSUdOX09GRlNFVCA9IDE0O1xuY29uc3QgS0VZX0FMSUdOID0gMSA8PCBLRVlfQUxJR05fT0ZGU0VUO1xuY29uc3QgS0VZX1NJR05FRCA9IDEgPDwgMTk7XG5jb25zdCBLRVlfRkxPQVQgPSAxIDw8IDIwO1xuY29uc3QgS0VZX05VTExBQkxFID0gMSA8PCAyMTtcbmNvbnN0IEtFWV9NQU5BR0VEID0gMSA8PCAyMjtcblxuLy8gQXJyYXkoQnVmZmVyVmlldykgbGF5b3V0XG5jb25zdCBBUlJBWUJVRkZFUlZJRVdfQlVGRkVSX09GRlNFVCA9IDA7XG5jb25zdCBBUlJBWUJVRkZFUlZJRVdfREFUQVNUQVJUX09GRlNFVCA9IDQ7XG5jb25zdCBBUlJBWUJVRkZFUlZJRVdfREFUQUxFTkdUSF9PRkZTRVQgPSA4O1xuY29uc3QgQVJSQVlCVUZGRVJWSUVXX1NJWkUgPSAxMjtcbmNvbnN0IEFSUkFZX0xFTkdUSF9PRkZTRVQgPSAxMjtcbmNvbnN0IEFSUkFZX1NJWkUgPSAxNjtcblxuY29uc3QgQklHSU5UID0gdHlwZW9mIEJpZ1VpbnQ2NEFycmF5ICE9PSBcInVuZGVmaW5lZFwiO1xuY29uc3QgVEhJUyA9IFN5bWJvbCgpO1xuY29uc3QgQ0hVTktTSVpFID0gMTAyNDtcblxuLyoqIEdldHMgYSBzdHJpbmcgZnJvbSBhbiBVMzIgYW5kIGFuIFUxNiB2aWV3IG9uIGEgbWVtb3J5LiAqL1xuZnVuY3Rpb24gZ2V0U3RyaW5nSW1wbChidWZmZXIsIHB0cikge1xuICBjb25zdCBVMzIgPSBuZXcgVWludDMyQXJyYXkoYnVmZmVyKTtcbiAgY29uc3QgVTE2ID0gbmV3IFVpbnQxNkFycmF5KGJ1ZmZlcik7XG4gIHZhciBsZW5ndGggPSBVMzJbKHB0ciArIFNJWkVfT0ZGU0VUKSA+Pj4gMl0gPj4+IDE7XG4gIHZhciBvZmZzZXQgPSBwdHIgPj4+IDE7XG4gIGlmIChsZW5ndGggPD0gQ0hVTktTSVpFKSByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShTdHJpbmcsIFUxNi5zdWJhcnJheShvZmZzZXQsIG9mZnNldCArIGxlbmd0aCkpO1xuICBjb25zdCBwYXJ0cyA9IFtdO1xuICBkbyB7XG4gICAgY29uc3QgbGFzdCA9IFUxNltvZmZzZXQgKyBDSFVOS1NJWkUgLSAxXTtcbiAgICBjb25zdCBzaXplID0gbGFzdCA+PSAweEQ4MDAgJiYgbGFzdCA8IDB4REMwMCA/IENIVU5LU0laRSAtIDEgOiBDSFVOS1NJWkU7XG4gICAgcGFydHMucHVzaChTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KFN0cmluZywgVTE2LnN1YmFycmF5KG9mZnNldCwgb2Zmc2V0ICs9IHNpemUpKSk7XG4gICAgbGVuZ3RoIC09IHNpemU7XG4gIH0gd2hpbGUgKGxlbmd0aCA+IENIVU5LU0laRSk7XG4gIHJldHVybiBwYXJ0cy5qb2luKFwiXCIpICsgU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShTdHJpbmcsIFUxNi5zdWJhcnJheShvZmZzZXQsIG9mZnNldCArIGxlbmd0aCkpO1xufVxuXG4vKiogUHJlcGFyZXMgdGhlIGJhc2UgbW9kdWxlIHByaW9yIHRvIGluc3RhbnRpYXRpb24uICovXG5mdW5jdGlvbiBwcmVJbnN0YW50aWF0ZShpbXBvcnRzKSB7XG4gIGNvbnN0IGJhc2VNb2R1bGUgPSB7fTtcblxuICBmdW5jdGlvbiBnZXRTdHJpbmcobWVtb3J5LCBwdHIpIHtcbiAgICBpZiAoIW1lbW9yeSkgcmV0dXJuIFwiPHlldCB1bmtub3duPlwiO1xuICAgIHJldHVybiBnZXRTdHJpbmdJbXBsKG1lbW9yeS5idWZmZXIsIHB0cik7XG4gIH1cblxuICAvLyBhZGQgY29tbW9uIGltcG9ydHMgdXNlZCBieSBzdGRsaWIgZm9yIGNvbnZlbmllbmNlXG4gIGNvbnN0IGVudiA9IChpbXBvcnRzLmVudiA9IGltcG9ydHMuZW52IHx8IHt9KTtcbiAgZW52LmFib3J0ID0gZW52LmFib3J0IHx8IGZ1bmN0aW9uIGFib3J0KG1lc2csIGZpbGUsIGxpbmUsIGNvbG0pIHtcbiAgICBjb25zdCBtZW1vcnkgPSBiYXNlTW9kdWxlLm1lbW9yeSB8fCBlbnYubWVtb3J5OyAvLyBwcmVmZXIgZXhwb3J0ZWQsIG90aGVyd2lzZSB0cnkgaW1wb3J0ZWRcbiAgICB0aHJvdyBFcnJvcihcImFib3J0OiBcIiArIGdldFN0cmluZyhtZW1vcnksIG1lc2cpICsgXCIgYXQgXCIgKyBnZXRTdHJpbmcobWVtb3J5LCBmaWxlKSArIFwiOlwiICsgbGluZSArIFwiOlwiICsgY29sbSk7XG4gIH1cbiAgZW52LnRyYWNlID0gZW52LnRyYWNlIHx8IGZ1bmN0aW9uIHRyYWNlKG1lc2csIG4pIHtcbiAgICBjb25zdCBtZW1vcnkgPSBiYXNlTW9kdWxlLm1lbW9yeSB8fCBlbnYubWVtb3J5O1xuICAgIGNvbnNvbGUubG9nKFwidHJhY2U6IFwiICsgZ2V0U3RyaW5nKG1lbW9yeSwgbWVzZykgKyAobiA/IFwiIFwiIDogXCJcIikgKyBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDIsIDIgKyBuKS5qb2luKFwiLCBcIikpO1xuICB9XG4gIGltcG9ydHMuTWF0aCA9IGltcG9ydHMuTWF0aCB8fCBNYXRoO1xuICBpbXBvcnRzLkRhdGUgPSBpbXBvcnRzLkRhdGUgfHwgRGF0ZTtcblxuICByZXR1cm4gYmFzZU1vZHVsZTtcbn1cblxuLyoqIFByZXBhcmVzIHRoZSBmaW5hbCBtb2R1bGUgb25jZSBpbnN0YW50aWF0aW9uIGlzIGNvbXBsZXRlLiAqL1xuZnVuY3Rpb24gcG9zdEluc3RhbnRpYXRlKGJhc2VNb2R1bGUsIGluc3RhbmNlKSB7XG4gIGNvbnN0IHJhd0V4cG9ydHMgPSBpbnN0YW5jZS5leHBvcnRzO1xuICBjb25zdCBtZW1vcnkgPSByYXdFeHBvcnRzLm1lbW9yeTtcbiAgY29uc3QgdGFibGUgPSByYXdFeHBvcnRzLnRhYmxlO1xuICBjb25zdCBhbGxvYyA9IHJhd0V4cG9ydHNbXCJfX2FsbG9jXCJdO1xuICBjb25zdCByZXRhaW4gPSByYXdFeHBvcnRzW1wiX19yZXRhaW5cIl07XG4gIGNvbnN0IHJ0dGlCYXNlID0gcmF3RXhwb3J0c1tcIl9fcnR0aV9iYXNlXCJdIHx8IH4wOyAvLyBvb2IgaWYgbm90IHByZXNlbnRcblxuICAvKiogR2V0cyB0aGUgcnVudGltZSB0eXBlIGluZm8gZm9yIHRoZSBnaXZlbiBpZC4gKi9cbiAgZnVuY3Rpb24gZ2V0SW5mbyhpZCkge1xuICAgIGNvbnN0IFUzMiA9IG5ldyBVaW50MzJBcnJheShtZW1vcnkuYnVmZmVyKTtcbiAgICBjb25zdCBjb3VudCA9IFUzMltydHRpQmFzZSA+Pj4gMl07XG4gICAgaWYgKChpZCA+Pj49IDApID49IGNvdW50KSB0aHJvdyBFcnJvcihcImludmFsaWQgaWQ6IFwiICsgaWQpO1xuICAgIHJldHVybiBVMzJbKHJ0dGlCYXNlICsgNCA+Pj4gMikgKyBpZCAqIDJdO1xuICB9XG5cbiAgLyoqIEdldHMgdGhlIHJ1bnRpbWUgYmFzZSBpZCBmb3IgdGhlIGdpdmVuIGlkLiAqL1xuICBmdW5jdGlvbiBnZXRCYXNlKGlkKSB7XG4gICAgY29uc3QgVTMyID0gbmV3IFVpbnQzMkFycmF5KG1lbW9yeS5idWZmZXIpO1xuICAgIGNvbnN0IGNvdW50ID0gVTMyW3J0dGlCYXNlID4+PiAyXTtcbiAgICBpZiAoKGlkID4+Pj0gMCkgPj0gY291bnQpIHRocm93IEVycm9yKFwiaW52YWxpZCBpZDogXCIgKyBpZCk7XG4gICAgcmV0dXJuIFUzMlsocnR0aUJhc2UgKyA0ID4+PiAyKSArIGlkICogMiArIDFdO1xuICB9XG5cbiAgLyoqIEdldHMgdGhlIHJ1bnRpbWUgYWxpZ25tZW50IG9mIGEgY29sbGVjdGlvbidzIHZhbHVlcy4gKi9cbiAgZnVuY3Rpb24gZ2V0VmFsdWVBbGlnbihpbmZvKSB7XG4gICAgcmV0dXJuIDMxIC0gTWF0aC5jbHozMigoaW5mbyA+Pj4gVkFMX0FMSUdOX09GRlNFVCkgJiAzMSk7IC8vIC0xIGlmIG5vbmVcbiAgfVxuXG4gIC8qKiBHZXRzIHRoZSBydW50aW1lIGFsaWdubWVudCBvZiBhIGNvbGxlY3Rpb24ncyBrZXlzLiAqL1xuICBmdW5jdGlvbiBnZXRLZXlBbGlnbihpbmZvKSB7XG4gICAgcmV0dXJuIDMxIC0gTWF0aC5jbHozMigoaW5mbyA+Pj4gS0VZX0FMSUdOX09GRlNFVCkgJiAzMSk7IC8vIC0xIGlmIG5vbmVcbiAgfVxuXG4gIC8qKiBBbGxvY2F0ZXMgYSBuZXcgc3RyaW5nIGluIHRoZSBtb2R1bGUncyBtZW1vcnkgYW5kIHJldHVybnMgaXRzIHJldGFpbmVkIHBvaW50ZXIuICovXG4gIGZ1bmN0aW9uIF9fYWxsb2NTdHJpbmcoc3RyKSB7XG4gICAgY29uc3QgbGVuZ3RoID0gc3RyLmxlbmd0aDtcbiAgICBjb25zdCBwdHIgPSBhbGxvYyhsZW5ndGggPDwgMSwgU1RSSU5HX0lEKTtcbiAgICBjb25zdCBVMTYgPSBuZXcgVWludDE2QXJyYXkobWVtb3J5LmJ1ZmZlcik7XG4gICAgZm9yICh2YXIgaSA9IDAsIHAgPSBwdHIgPj4+IDE7IGkgPCBsZW5ndGg7ICsraSkgVTE2W3AgKyBpXSA9IHN0ci5jaGFyQ29kZUF0KGkpO1xuICAgIHJldHVybiBwdHI7XG4gIH1cblxuICBiYXNlTW9kdWxlLl9fYWxsb2NTdHJpbmcgPSBfX2FsbG9jU3RyaW5nO1xuXG4gIC8qKiBSZWFkcyBhIHN0cmluZyBmcm9tIHRoZSBtb2R1bGUncyBtZW1vcnkgYnkgaXRzIHBvaW50ZXIuICovXG4gIGZ1bmN0aW9uIF9fZ2V0U3RyaW5nKHB0cikge1xuICAgIGNvbnN0IGJ1ZmZlciA9IG1lbW9yeS5idWZmZXI7XG4gICAgY29uc3QgaWQgPSBuZXcgVWludDMyQXJyYXkoYnVmZmVyKVtwdHIgKyBJRF9PRkZTRVQgPj4+IDJdO1xuICAgIGlmIChpZCAhPT0gU1RSSU5HX0lEKSB0aHJvdyBFcnJvcihcIm5vdCBhIHN0cmluZzogXCIgKyBwdHIpO1xuICAgIHJldHVybiBnZXRTdHJpbmdJbXBsKGJ1ZmZlciwgcHRyKTtcbiAgfVxuXG4gIGJhc2VNb2R1bGUuX19nZXRTdHJpbmcgPSBfX2dldFN0cmluZztcblxuICAvKiogR2V0cyB0aGUgdmlldyBtYXRjaGluZyB0aGUgc3BlY2lmaWVkIGFsaWdubWVudCwgc2lnbmVkbmVzcyBhbmQgZmxvYXRuZXNzLiAqL1xuICBmdW5jdGlvbiBnZXRWaWV3KGFsaWduTG9nMiwgc2lnbmVkLCBmbG9hdCkge1xuICAgIGNvbnN0IGJ1ZmZlciA9IG1lbW9yeS5idWZmZXI7XG4gICAgaWYgKGZsb2F0KSB7XG4gICAgICBzd2l0Y2ggKGFsaWduTG9nMikge1xuICAgICAgICBjYXNlIDI6IHJldHVybiBuZXcgRmxvYXQzMkFycmF5KGJ1ZmZlcik7XG4gICAgICAgIGNhc2UgMzogcmV0dXJuIG5ldyBGbG9hdDY0QXJyYXkoYnVmZmVyKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgc3dpdGNoIChhbGlnbkxvZzIpIHtcbiAgICAgICAgY2FzZSAwOiByZXR1cm4gbmV3IChzaWduZWQgPyBJbnQ4QXJyYXkgOiBVaW50OEFycmF5KShidWZmZXIpO1xuICAgICAgICBjYXNlIDE6IHJldHVybiBuZXcgKHNpZ25lZCA/IEludDE2QXJyYXkgOiBVaW50MTZBcnJheSkoYnVmZmVyKTtcbiAgICAgICAgY2FzZSAyOiByZXR1cm4gbmV3IChzaWduZWQgPyBJbnQzMkFycmF5IDogVWludDMyQXJyYXkpKGJ1ZmZlcik7XG4gICAgICAgIGNhc2UgMzogcmV0dXJuIG5ldyAoc2lnbmVkID8gQmlnSW50NjRBcnJheSA6IEJpZ1VpbnQ2NEFycmF5KShidWZmZXIpO1xuICAgICAgfVxuICAgIH1cbiAgICB0aHJvdyBFcnJvcihcInVuc3VwcG9ydGVkIGFsaWduOiBcIiArIGFsaWduTG9nMik7XG4gIH1cblxuICAvKiogQWxsb2NhdGVzIGEgbmV3IGFycmF5IGluIHRoZSBtb2R1bGUncyBtZW1vcnkgYW5kIHJldHVybnMgaXRzIHJldGFpbmVkIHBvaW50ZXIuICovXG4gIGZ1bmN0aW9uIF9fYWxsb2NBcnJheShpZCwgdmFsdWVzKSB7XG4gICAgY29uc3QgaW5mbyA9IGdldEluZm8oaWQpO1xuICAgIGlmICghKGluZm8gJiAoQVJSQVlCVUZGRVJWSUVXIHwgQVJSQVkpKSkgdGhyb3cgRXJyb3IoXCJub3QgYW4gYXJyYXk6IFwiICsgaWQgKyBcIiBAIFwiICsgaW5mbyk7XG4gICAgY29uc3QgYWxpZ24gPSBnZXRWYWx1ZUFsaWduKGluZm8pO1xuICAgIGNvbnN0IGxlbmd0aCA9IHZhbHVlcy5sZW5ndGg7XG4gICAgY29uc3QgYnVmID0gYWxsb2MobGVuZ3RoIDw8IGFsaWduLCBBUlJBWUJVRkZFUl9JRCk7XG4gICAgY29uc3QgYXJyID0gYWxsb2MoaW5mbyAmIEFSUkFZID8gQVJSQVlfU0laRSA6IEFSUkFZQlVGRkVSVklFV19TSVpFLCBpZCk7XG4gICAgY29uc3QgVTMyID0gbmV3IFVpbnQzMkFycmF5KG1lbW9yeS5idWZmZXIpO1xuICAgIFUzMlthcnIgKyBBUlJBWUJVRkZFUlZJRVdfQlVGRkVSX09GRlNFVCA+Pj4gMl0gPSByZXRhaW4oYnVmKTtcbiAgICBVMzJbYXJyICsgQVJSQVlCVUZGRVJWSUVXX0RBVEFTVEFSVF9PRkZTRVQgPj4+IDJdID0gYnVmO1xuICAgIFUzMlthcnIgKyBBUlJBWUJVRkZFUlZJRVdfREFUQUxFTkdUSF9PRkZTRVQgPj4+IDJdID0gbGVuZ3RoIDw8IGFsaWduO1xuICAgIGlmIChpbmZvICYgQVJSQVkpIFUzMlthcnIgKyBBUlJBWV9MRU5HVEhfT0ZGU0VUID4+PiAyXSA9IGxlbmd0aDtcbiAgICBjb25zdCB2aWV3ID0gZ2V0VmlldyhhbGlnbiwgaW5mbyAmIFZBTF9TSUdORUQsIGluZm8gJiBWQUxfRkxPQVQpO1xuICAgIGlmIChpbmZvICYgVkFMX01BTkFHRUQpIHtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuZ3RoOyArK2kpIHZpZXdbKGJ1ZiA+Pj4gYWxpZ24pICsgaV0gPSByZXRhaW4odmFsdWVzW2ldKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmlldy5zZXQodmFsdWVzLCBidWYgPj4+IGFsaWduKTtcbiAgICB9XG4gICAgcmV0dXJuIGFycjtcbiAgfVxuXG4gIGJhc2VNb2R1bGUuX19hbGxvY0FycmF5ID0gX19hbGxvY0FycmF5O1xuXG4gIC8qKiBHZXRzIGEgbGl2ZSB2aWV3IG9uIGFuIGFycmF5J3MgdmFsdWVzIGluIHRoZSBtb2R1bGUncyBtZW1vcnkuIEluZmVycyB0aGUgYXJyYXkgdHlwZSBmcm9tIFJUVEkuICovXG4gIGZ1bmN0aW9uIF9fZ2V0QXJyYXlWaWV3KGFycikge1xuICAgIGNvbnN0IFUzMiA9IG5ldyBVaW50MzJBcnJheShtZW1vcnkuYnVmZmVyKTtcbiAgICBjb25zdCBpZCA9IFUzMlthcnIgKyBJRF9PRkZTRVQgPj4+IDJdO1xuICAgIGNvbnN0IGluZm8gPSBnZXRJbmZvKGlkKTtcbiAgICBpZiAoIShpbmZvICYgQVJSQVlCVUZGRVJWSUVXKSkgdGhyb3cgRXJyb3IoXCJub3QgYW4gYXJyYXk6IFwiICsgaWQpO1xuICAgIGNvbnN0IGFsaWduID0gZ2V0VmFsdWVBbGlnbihpbmZvKTtcbiAgICB2YXIgYnVmID0gVTMyW2FyciArIEFSUkFZQlVGRkVSVklFV19EQVRBU1RBUlRfT0ZGU0VUID4+PiAyXTtcbiAgICBjb25zdCBsZW5ndGggPSBpbmZvICYgQVJSQVlcbiAgICAgID8gVTMyW2FyciArIEFSUkFZX0xFTkdUSF9PRkZTRVQgPj4+IDJdXG4gICAgICA6IFUzMltidWYgKyBTSVpFX09GRlNFVCA+Pj4gMl0gPj4+IGFsaWduO1xuICAgIHJldHVybiBnZXRWaWV3KGFsaWduLCBpbmZvICYgVkFMX1NJR05FRCwgaW5mbyAmIFZBTF9GTE9BVClcbiAgICAgICAgICAuc3ViYXJyYXkoYnVmID4+Pj0gYWxpZ24sIGJ1ZiArIGxlbmd0aCk7XG4gIH1cblxuICBiYXNlTW9kdWxlLl9fZ2V0QXJyYXlWaWV3ID0gX19nZXRBcnJheVZpZXc7XG5cbiAgLyoqIENvcGllcyBhbiBhcnJheSdzIHZhbHVlcyBmcm9tIHRoZSBtb2R1bGUncyBtZW1vcnkuIEluZmVycyB0aGUgYXJyYXkgdHlwZSBmcm9tIFJUVEkuICovXG4gIGZ1bmN0aW9uIF9fZ2V0QXJyYXkoYXJyKSB7XG4gICAgY29uc3QgaW5wdXQgPSBfX2dldEFycmF5VmlldyhhcnIpO1xuICAgIGNvbnN0IGxlbiA9IGlucHV0Lmxlbmd0aDtcbiAgICBjb25zdCBvdXQgPSBuZXcgQXJyYXkobGVuKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbjsgaSsrKSBvdXRbaV0gPSBpbnB1dFtpXTtcbiAgICByZXR1cm4gb3V0O1xuICB9XG5cbiAgYmFzZU1vZHVsZS5fX2dldEFycmF5ID0gX19nZXRBcnJheTtcblxuICAvKiogQ29waWVzIGFuIEFycmF5QnVmZmVyJ3MgdmFsdWUgZnJvbSB0aGUgbW9kdWxlJ3MgbWVtb3J5LiAqL1xuICBmdW5jdGlvbiBfX2dldEFycmF5QnVmZmVyKHB0cikge1xuICAgIGNvbnN0IGJ1ZmZlciA9IG1lbW9yeS5idWZmZXI7XG4gICAgY29uc3QgbGVuZ3RoID0gbmV3IFVpbnQzMkFycmF5KGJ1ZmZlcilbcHRyICsgU0laRV9PRkZTRVQgPj4+IDJdO1xuICAgIHJldHVybiBidWZmZXIuc2xpY2UocHRyLCBwdHIgKyBsZW5ndGgpO1xuICB9XG5cbiAgYmFzZU1vZHVsZS5fX2dldEFycmF5QnVmZmVyID0gX19nZXRBcnJheUJ1ZmZlcjtcblxuICAvKiogQ29waWVzIGEgdHlwZWQgYXJyYXkncyB2YWx1ZXMgZnJvbSB0aGUgbW9kdWxlJ3MgbWVtb3J5LiAqL1xuICBmdW5jdGlvbiBnZXRUeXBlZEFycmF5KFR5cGUsIGFsaWduTG9nMiwgcHRyKSB7XG4gICAgcmV0dXJuIG5ldyBUeXBlKGdldFR5cGVkQXJyYXlWaWV3KFR5cGUsIGFsaWduTG9nMiwgcHRyKSk7XG4gIH1cblxuICAvKiogR2V0cyBhIGxpdmUgdmlldyBvbiBhIHR5cGVkIGFycmF5J3MgdmFsdWVzIGluIHRoZSBtb2R1bGUncyBtZW1vcnkuICovXG4gIGZ1bmN0aW9uIGdldFR5cGVkQXJyYXlWaWV3KFR5cGUsIGFsaWduTG9nMiwgcHRyKSB7XG4gICAgY29uc3QgYnVmZmVyID0gbWVtb3J5LmJ1ZmZlcjtcbiAgICBjb25zdCBVMzIgPSBuZXcgVWludDMyQXJyYXkoYnVmZmVyKTtcbiAgICBjb25zdCBidWZQdHIgPSBVMzJbcHRyICsgQVJSQVlCVUZGRVJWSUVXX0RBVEFTVEFSVF9PRkZTRVQgPj4+IDJdO1xuICAgIHJldHVybiBuZXcgVHlwZShidWZmZXIsIGJ1ZlB0ciwgVTMyW2J1ZlB0ciArIFNJWkVfT0ZGU0VUID4+PiAyXSA+Pj4gYWxpZ25Mb2cyKTtcbiAgfVxuXG4gIGJhc2VNb2R1bGUuX19nZXRJbnQ4QXJyYXkgPSBnZXRUeXBlZEFycmF5LmJpbmQobnVsbCwgSW50OEFycmF5LCAwKTtcbiAgYmFzZU1vZHVsZS5fX2dldEludDhBcnJheVZpZXcgPSBnZXRUeXBlZEFycmF5Vmlldy5iaW5kKG51bGwsIEludDhBcnJheSwgMCk7XG4gIGJhc2VNb2R1bGUuX19nZXRVaW50OEFycmF5ID0gZ2V0VHlwZWRBcnJheS5iaW5kKG51bGwsIFVpbnQ4QXJyYXksIDApO1xuICBiYXNlTW9kdWxlLl9fZ2V0VWludDhBcnJheVZpZXcgPSBnZXRUeXBlZEFycmF5Vmlldy5iaW5kKG51bGwsIFVpbnQ4QXJyYXksIDApO1xuICBiYXNlTW9kdWxlLl9fZ2V0VWludDhDbGFtcGVkQXJyYXkgPSBnZXRUeXBlZEFycmF5LmJpbmQobnVsbCwgVWludDhDbGFtcGVkQXJyYXksIDApO1xuICBiYXNlTW9kdWxlLl9fZ2V0VWludDhDbGFtcGVkQXJyYXlWaWV3ID0gZ2V0VHlwZWRBcnJheVZpZXcuYmluZChudWxsLCBVaW50OENsYW1wZWRBcnJheSwgMCk7XG4gIGJhc2VNb2R1bGUuX19nZXRJbnQxNkFycmF5ID0gZ2V0VHlwZWRBcnJheS5iaW5kKG51bGwsIEludDE2QXJyYXksIDEpO1xuICBiYXNlTW9kdWxlLl9fZ2V0SW50MTZBcnJheVZpZXcgPSBnZXRUeXBlZEFycmF5Vmlldy5iaW5kKG51bGwsIEludDE2QXJyYXksIDEpO1xuICBiYXNlTW9kdWxlLl9fZ2V0VWludDE2QXJyYXkgPSBnZXRUeXBlZEFycmF5LmJpbmQobnVsbCwgVWludDE2QXJyYXksIDEpO1xuICBiYXNlTW9kdWxlLl9fZ2V0VWludDE2QXJyYXlWaWV3ID0gZ2V0VHlwZWRBcnJheVZpZXcuYmluZChudWxsLCBVaW50MTZBcnJheSwgMSk7XG4gIGJhc2VNb2R1bGUuX19nZXRJbnQzMkFycmF5ID0gZ2V0VHlwZWRBcnJheS5iaW5kKG51bGwsIEludDMyQXJyYXksIDIpO1xuICBiYXNlTW9kdWxlLl9fZ2V0SW50MzJBcnJheVZpZXcgPSBnZXRUeXBlZEFycmF5Vmlldy5iaW5kKG51bGwsIEludDMyQXJyYXksIDIpO1xuICBiYXNlTW9kdWxlLl9fZ2V0VWludDMyQXJyYXkgPSBnZXRUeXBlZEFycmF5LmJpbmQobnVsbCwgVWludDMyQXJyYXksIDIpO1xuICBiYXNlTW9kdWxlLl9fZ2V0VWludDMyQXJyYXlWaWV3ID0gZ2V0VHlwZWRBcnJheVZpZXcuYmluZChudWxsLCBVaW50MzJBcnJheSwgMik7XG4gIGlmIChCSUdJTlQpIHtcbiAgICBiYXNlTW9kdWxlLl9fZ2V0SW50NjRBcnJheSA9IGdldFR5cGVkQXJyYXkuYmluZChudWxsLCBCaWdJbnQ2NEFycmF5LCAzKTtcbiAgICBiYXNlTW9kdWxlLl9fZ2V0SW50NjRBcnJheVZpZXcgPSBnZXRUeXBlZEFycmF5Vmlldy5iaW5kKG51bGwsIEJpZ0ludDY0QXJyYXksIDMpO1xuICAgIGJhc2VNb2R1bGUuX19nZXRVaW50NjRBcnJheSA9IGdldFR5cGVkQXJyYXkuYmluZChudWxsLCBCaWdVaW50NjRBcnJheSwgMyk7XG4gICAgYmFzZU1vZHVsZS5fX2dldFVpbnQ2NEFycmF5VmlldyA9IGdldFR5cGVkQXJyYXlWaWV3LmJpbmQobnVsbCwgQmlnVWludDY0QXJyYXksIDMpO1xuICB9XG4gIGJhc2VNb2R1bGUuX19nZXRGbG9hdDMyQXJyYXkgPSBnZXRUeXBlZEFycmF5LmJpbmQobnVsbCwgRmxvYXQzMkFycmF5LCAyKTtcbiAgYmFzZU1vZHVsZS5fX2dldEZsb2F0MzJBcnJheVZpZXcgPSBnZXRUeXBlZEFycmF5Vmlldy5iaW5kKG51bGwsIEZsb2F0MzJBcnJheSwgMik7XG4gIGJhc2VNb2R1bGUuX19nZXRGbG9hdDY0QXJyYXkgPSBnZXRUeXBlZEFycmF5LmJpbmQobnVsbCwgRmxvYXQ2NEFycmF5LCAzKTtcbiAgYmFzZU1vZHVsZS5fX2dldEZsb2F0NjRBcnJheVZpZXcgPSBnZXRUeXBlZEFycmF5Vmlldy5iaW5kKG51bGwsIEZsb2F0NjRBcnJheSwgMyk7XG5cbiAgLyoqIFRlc3RzIHdoZXRoZXIgYW4gb2JqZWN0IGlzIGFuIGluc3RhbmNlIG9mIHRoZSBjbGFzcyByZXByZXNlbnRlZCBieSB0aGUgc3BlY2lmaWVkIGJhc2UgaWQuICovXG4gIGZ1bmN0aW9uIF9faW5zdGFuY2VvZihwdHIsIGJhc2VJZCkge1xuICAgIGNvbnN0IFUzMiA9IG5ldyBVaW50MzJBcnJheShtZW1vcnkuYnVmZmVyKTtcbiAgICB2YXIgaWQgPSBVMzJbKHB0ciArIElEX09GRlNFVCkgPj4+IDJdO1xuICAgIGlmIChpZCA8PSBVMzJbcnR0aUJhc2UgPj4+IDJdKSB7XG4gICAgICBkbyBpZiAoaWQgPT0gYmFzZUlkKSByZXR1cm4gdHJ1ZTtcbiAgICAgIHdoaWxlIChpZCA9IGdldEJhc2UoaWQpKTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgYmFzZU1vZHVsZS5fX2luc3RhbmNlb2YgPSBfX2luc3RhbmNlb2Y7XG5cbiAgLy8gUHVsbCBiYXNpYyBleHBvcnRzIHRvIGJhc2VNb2R1bGUgc28gY29kZSBpbiBwcmVJbnN0YW50aWF0ZSBjYW4gdXNlIHRoZW1cbiAgYmFzZU1vZHVsZS5tZW1vcnkgPSBiYXNlTW9kdWxlLm1lbW9yeSB8fCBtZW1vcnk7XG4gIGJhc2VNb2R1bGUudGFibGUgID0gYmFzZU1vZHVsZS50YWJsZSAgfHwgdGFibGU7XG5cbiAgLy8gRGVtYW5nbGUgZXhwb3J0cyBhbmQgcHJvdmlkZSB0aGUgdXN1YWwgdXRpbGl0eSBvbiB0aGUgcHJvdG90eXBlXG4gIHJldHVybiBkZW1hbmdsZShyYXdFeHBvcnRzLCBiYXNlTW9kdWxlKTtcbn1cblxuZnVuY3Rpb24gaXNSZXNwb25zZShvKSB7XG4gIHJldHVybiB0eXBlb2YgUmVzcG9uc2UgIT09IFwidW5kZWZpbmVkXCIgJiYgbyBpbnN0YW5jZW9mIFJlc3BvbnNlO1xufVxuXG4vKiogQXN5bmNocm9ub3VzbHkgaW5zdGFudGlhdGVzIGFuIEFzc2VtYmx5U2NyaXB0IG1vZHVsZSBmcm9tIGFueXRoaW5nIHRoYXQgY2FuIGJlIGluc3RhbnRpYXRlZC4gKi9cbmFzeW5jIGZ1bmN0aW9uIGluc3RhbnRpYXRlKHNvdXJjZSwgaW1wb3J0cykge1xuICBpZiAoaXNSZXNwb25zZShzb3VyY2UgPSBhd2FpdCBzb3VyY2UpKSByZXR1cm4gaW5zdGFudGlhdGVTdHJlYW1pbmcoc291cmNlLCBpbXBvcnRzKTtcbiAgcmV0dXJuIHBvc3RJbnN0YW50aWF0ZShcbiAgICBwcmVJbnN0YW50aWF0ZShpbXBvcnRzIHx8IChpbXBvcnRzID0ge30pKSxcbiAgICBhd2FpdCBXZWJBc3NlbWJseS5pbnN0YW50aWF0ZShcbiAgICAgIHNvdXJjZSBpbnN0YW5jZW9mIFdlYkFzc2VtYmx5Lk1vZHVsZVxuICAgICAgICA/IHNvdXJjZVxuICAgICAgICA6IGF3YWl0IFdlYkFzc2VtYmx5LmNvbXBpbGUoc291cmNlKSxcbiAgICAgIGltcG9ydHNcbiAgICApXG4gICk7XG59XG5cbmV4cG9ydHMuaW5zdGFudGlhdGUgPSBpbnN0YW50aWF0ZTtcblxuLyoqIFN5bmNocm9ub3VzbHkgaW5zdGFudGlhdGVzIGFuIEFzc2VtYmx5U2NyaXB0IG1vZHVsZSBmcm9tIGEgV2ViQXNzZW1ibHkuTW9kdWxlIG9yIGJpbmFyeSBidWZmZXIuICovXG5mdW5jdGlvbiBpbnN0YW50aWF0ZVN5bmMoc291cmNlLCBpbXBvcnRzKSB7XG4gIHJldHVybiBwb3N0SW5zdGFudGlhdGUoXG4gICAgcHJlSW5zdGFudGlhdGUoaW1wb3J0cyB8fCAoaW1wb3J0cyA9IHt9KSksXG4gICAgbmV3IFdlYkFzc2VtYmx5Lkluc3RhbmNlKFxuICAgICAgc291cmNlIGluc3RhbmNlb2YgV2ViQXNzZW1ibHkuTW9kdWxlXG4gICAgICAgID8gc291cmNlXG4gICAgICAgIDogbmV3IFdlYkFzc2VtYmx5Lk1vZHVsZShzb3VyY2UpLFxuICAgICAgaW1wb3J0c1xuICAgIClcbiAgKVxufVxuXG5leHBvcnRzLmluc3RhbnRpYXRlU3luYyA9IGluc3RhbnRpYXRlU3luYztcblxuLyoqIEFzeW5jaHJvbm91c2x5IGluc3RhbnRpYXRlcyBhbiBBc3NlbWJseVNjcmlwdCBtb2R1bGUgZnJvbSBhIHJlc3BvbnNlLCBpLmUuIGFzIG9idGFpbmVkIGJ5IGBmZXRjaGAuICovXG5hc3luYyBmdW5jdGlvbiBpbnN0YW50aWF0ZVN0cmVhbWluZyhzb3VyY2UsIGltcG9ydHMpIHtcbiAgaWYgKCFXZWJBc3NlbWJseS5pbnN0YW50aWF0ZVN0cmVhbWluZykge1xuICAgIHJldHVybiBpbnN0YW50aWF0ZShcbiAgICAgIGlzUmVzcG9uc2Uoc291cmNlID0gYXdhaXQgc291cmNlKVxuICAgICAgICA/IHNvdXJjZS5hcnJheUJ1ZmZlcigpXG4gICAgICAgIDogc291cmNlLFxuICAgICAgaW1wb3J0c1xuICAgICk7XG4gIH1cbiAgcmV0dXJuIHBvc3RJbnN0YW50aWF0ZShcbiAgICBwcmVJbnN0YW50aWF0ZShpbXBvcnRzIHx8IChpbXBvcnRzID0ge30pKSxcbiAgICAoYXdhaXQgV2ViQXNzZW1ibHkuaW5zdGFudGlhdGVTdHJlYW1pbmcoc291cmNlLCBpbXBvcnRzKSkuaW5zdGFuY2VcbiAgKTtcbn1cblxuZXhwb3J0cy5pbnN0YW50aWF0ZVN0cmVhbWluZyA9IGluc3RhbnRpYXRlU3RyZWFtaW5nO1xuXG4vKiogRGVtYW5nbGVzIGFuIEFzc2VtYmx5U2NyaXB0IG1vZHVsZSdzIGV4cG9ydHMgdG8gYSBmcmllbmRseSBvYmplY3Qgc3RydWN0dXJlLiAqL1xuZnVuY3Rpb24gZGVtYW5nbGUoZXhwb3J0cywgYmFzZU1vZHVsZSkge1xuICB2YXIgbW9kdWxlID0gYmFzZU1vZHVsZSA/IE9iamVjdC5jcmVhdGUoYmFzZU1vZHVsZSkgOiB7fTtcbiAgdmFyIHNldEFyZ3VtZW50c0xlbmd0aCA9IGV4cG9ydHNbXCJfX2FyZ3VtZW50c0xlbmd0aFwiXVxuICAgID8gZnVuY3Rpb24obGVuZ3RoKSB7IGV4cG9ydHNbXCJfX2FyZ3VtZW50c0xlbmd0aFwiXS52YWx1ZSA9IGxlbmd0aDsgfVxuICAgIDogZXhwb3J0c1tcIl9fc2V0QXJndW1lbnRzTGVuZ3RoXCJdIHx8IGV4cG9ydHNbXCJfX3NldGFyZ2NcIl0gfHwgZnVuY3Rpb24oKSB7fTtcbiAgZm9yIChsZXQgaW50ZXJuYWxOYW1lIGluIGV4cG9ydHMpIHtcbiAgICBpZiAoIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChleHBvcnRzLCBpbnRlcm5hbE5hbWUpKSBjb250aW51ZTtcbiAgICBjb25zdCBlbGVtID0gZXhwb3J0c1tpbnRlcm5hbE5hbWVdO1xuICAgIGxldCBwYXJ0cyA9IGludGVybmFsTmFtZS5zcGxpdChcIi5cIik7XG4gICAgbGV0IGN1cnIgPSBtb2R1bGU7XG4gICAgd2hpbGUgKHBhcnRzLmxlbmd0aCA+IDEpIHtcbiAgICAgIGxldCBwYXJ0ID0gcGFydHMuc2hpZnQoKTtcbiAgICAgIGlmICghT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGN1cnIsIHBhcnQpKSBjdXJyW3BhcnRdID0ge307XG4gICAgICBjdXJyID0gY3VycltwYXJ0XTtcbiAgICB9XG4gICAgbGV0IG5hbWUgPSBwYXJ0c1swXTtcbiAgICBsZXQgaGFzaCA9IG5hbWUuaW5kZXhPZihcIiNcIik7XG4gICAgaWYgKGhhc2ggPj0gMCkge1xuICAgICAgbGV0IGNsYXNzTmFtZSA9IG5hbWUuc3Vic3RyaW5nKDAsIGhhc2gpO1xuICAgICAgbGV0IGNsYXNzRWxlbSA9IGN1cnJbY2xhc3NOYW1lXTtcbiAgICAgIGlmICh0eXBlb2YgY2xhc3NFbGVtID09PSBcInVuZGVmaW5lZFwiIHx8ICFjbGFzc0VsZW0ucHJvdG90eXBlKSB7XG4gICAgICAgIGxldCBjdG9yID0gZnVuY3Rpb24oLi4uYXJncykge1xuICAgICAgICAgIHJldHVybiBjdG9yLndyYXAoY3Rvci5wcm90b3R5cGUuY29uc3RydWN0b3IoMCwgLi4uYXJncykpO1xuICAgICAgICB9O1xuICAgICAgICBjdG9yLnByb3RvdHlwZSA9IHtcbiAgICAgICAgICB2YWx1ZU9mOiBmdW5jdGlvbiB2YWx1ZU9mKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXNbVEhJU107XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBjdG9yLndyYXAgPSBmdW5jdGlvbih0aGlzVmFsdWUpIHtcbiAgICAgICAgICByZXR1cm4gT2JqZWN0LmNyZWF0ZShjdG9yLnByb3RvdHlwZSwgeyBbVEhJU106IHsgdmFsdWU6IHRoaXNWYWx1ZSwgd3JpdGFibGU6IGZhbHNlIH0gfSk7XG4gICAgICAgIH07XG4gICAgICAgIGlmIChjbGFzc0VsZW0pIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKGNsYXNzRWxlbSkuZm9yRWFjaChuYW1lID0+XG4gICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGN0b3IsIG5hbWUsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoY2xhc3NFbGVtLCBuYW1lKSlcbiAgICAgICAgKTtcbiAgICAgICAgY3VycltjbGFzc05hbWVdID0gY3RvcjtcbiAgICAgIH1cbiAgICAgIG5hbWUgPSBuYW1lLnN1YnN0cmluZyhoYXNoICsgMSk7XG4gICAgICBjdXJyID0gY3VycltjbGFzc05hbWVdLnByb3RvdHlwZTtcbiAgICAgIGlmICgvXihnZXR8c2V0KTovLnRlc3QobmFtZSkpIHtcbiAgICAgICAgaWYgKCFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoY3VyciwgbmFtZSA9IG5hbWUuc3Vic3RyaW5nKDQpKSkge1xuICAgICAgICAgIGxldCBnZXR0ZXIgPSBleHBvcnRzW2ludGVybmFsTmFtZS5yZXBsYWNlKFwic2V0OlwiLCBcImdldDpcIildO1xuICAgICAgICAgIGxldCBzZXR0ZXIgPSBleHBvcnRzW2ludGVybmFsTmFtZS5yZXBsYWNlKFwiZ2V0OlwiLCBcInNldDpcIildO1xuICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShjdXJyLCBuYW1lLCB7XG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gZ2V0dGVyKHRoaXNbVEhJU10pOyB9LFxuICAgICAgICAgICAgc2V0OiBmdW5jdGlvbih2YWx1ZSkgeyBzZXR0ZXIodGhpc1tUSElTXSwgdmFsdWUpOyB9LFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAobmFtZSA9PT0gJ2NvbnN0cnVjdG9yJykge1xuICAgICAgICAgIChjdXJyW25hbWVdID0gKC4uLmFyZ3MpID0+IHtcbiAgICAgICAgICAgIHNldEFyZ3VtZW50c0xlbmd0aChhcmdzLmxlbmd0aCk7XG4gICAgICAgICAgICByZXR1cm4gZWxlbSguLi5hcmdzKTtcbiAgICAgICAgICB9KS5vcmlnaW5hbCA9IGVsZW07XG4gICAgICAgIH0gZWxzZSB7IC8vIGluc3RhbmNlIG1ldGhvZFxuICAgICAgICAgIChjdXJyW25hbWVdID0gZnVuY3Rpb24oLi4uYXJncykgeyAvLyAhXG4gICAgICAgICAgICBzZXRBcmd1bWVudHNMZW5ndGgoYXJncy5sZW5ndGgpO1xuICAgICAgICAgICAgcmV0dXJuIGVsZW0odGhpc1tUSElTXSwgLi4uYXJncyk7XG4gICAgICAgICAgfSkub3JpZ2luYWwgPSBlbGVtO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICgvXihnZXR8c2V0KTovLnRlc3QobmFtZSkpIHtcbiAgICAgICAgaWYgKCFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoY3VyciwgbmFtZSA9IG5hbWUuc3Vic3RyaW5nKDQpKSkge1xuICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShjdXJyLCBuYW1lLCB7XG4gICAgICAgICAgICBnZXQ6IGV4cG9ydHNbaW50ZXJuYWxOYW1lLnJlcGxhY2UoXCJzZXQ6XCIsIFwiZ2V0OlwiKV0sXG4gICAgICAgICAgICBzZXQ6IGV4cG9ydHNbaW50ZXJuYWxOYW1lLnJlcGxhY2UoXCJnZXQ6XCIsIFwic2V0OlwiKV0sXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGVsZW0gPT09IFwiZnVuY3Rpb25cIiAmJiBlbGVtICE9PSBzZXRBcmd1bWVudHNMZW5ndGgpIHtcbiAgICAgICAgKGN1cnJbbmFtZV0gPSAoLi4uYXJncykgPT4ge1xuICAgICAgICAgIHNldEFyZ3VtZW50c0xlbmd0aChhcmdzLmxlbmd0aCk7XG4gICAgICAgICAgcmV0dXJuIGVsZW0oLi4uYXJncyk7XG4gICAgICAgIH0pLm9yaWdpbmFsID0gZWxlbTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGN1cnJbbmFtZV0gPSBlbGVtO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gbW9kdWxlO1xufVxuXG5leHBvcnRzLmRlbWFuZ2xlID0gZGVtYW5nbGU7XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@assemblyscript/loader/index.js\n");

/***/ })

};
;