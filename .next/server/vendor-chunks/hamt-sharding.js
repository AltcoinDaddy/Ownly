"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/hamt-sharding";
exports.ids = ["vendor-chunks/hamt-sharding"];
exports.modules = {

/***/ "(rsc)/./node_modules/hamt-sharding/src/bucket.js":
/*!**************************************************!*\
  !*** ./node_modules/hamt-sharding/src/bucket.js ***!
  \**************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\n// @ts-ignore\nconst SparseArray = __webpack_require__(/*! sparse-array */ \"(rsc)/./node_modules/sparse-array/index.js\")\nconst { fromString: uint8ArrayFromString } = __webpack_require__(/*! uint8arrays/from-string */ \"(rsc)/./node_modules/uint8arrays/cjs/src/from-string.js\")\n\n/**\n * @typedef {import('./consumable-hash').InfiniteHash} InfiniteHash\n * @typedef {import('../').UserBucketOptions} UserBucketOptions\n */\n\n/**\n * @template V\n * @typedef {object} BucketChild<V>\n * @property {string} key\n * @property {V} value\n * @property {InfiniteHash} hash\n */\n\n/**\n * @template B\n *\n * @typedef {object} SA<B>\n * @property {number} length\n * @property {() => B[]} compactArray\n * @property {(i: number) => B} get\n * @property {(i: number, value: B) => void} set\n * @property {<A> (fn: (acc: A, curr: B, index: number) => A, initial: A) => B} reduce\n * @property {(fn: (item: B) => boolean) => B | undefined} find\n * @property {() => number[]} bitField\n * @property {(i: number) => void} unset\n */\n\n/**\n * @template T\n *\n * @typedef {object} BucketPosition<T>\n * @property {Bucket<T>} bucket\n * @property {number} pos\n * @property {InfiniteHash} hash\n * @property {BucketChild<T>} [existingChild]\n */\n\n/**\n * @typedef {object} BucketOptions\n * @property {number} bits\n * @property {(value: Uint8Array | InfiniteHash) => InfiniteHash} hash\n */\n\n/**\n * @template T\n */\nclass Bucket {\n  /**\n   * @param {BucketOptions} options\n   * @param {Bucket<T>} [parent]\n   * @param {number} [posAtParent=0]\n   */\n  constructor (options, parent, posAtParent = 0) {\n    this._options = options\n    this._popCount = 0\n    this._parent = parent\n    this._posAtParent = posAtParent\n\n    /** @type {SA<Bucket<T> | BucketChild<T>>} */\n    this._children = new SparseArray()\n\n    /** @type {string | null} */\n    this.key = null\n  }\n\n  /**\n   * @param {string} key\n   * @param {T} value\n   */\n  async put (key, value) {\n    const place = await this._findNewBucketAndPos(key)\n\n    await place.bucket._putAt(place, key, value)\n  }\n\n  /**\n   * @param {string} key\n   */\n  async get (key) {\n    const child = await this._findChild(key)\n\n    if (child) {\n      return child.value\n    }\n  }\n\n  /**\n   * @param {string} key\n   */\n  async del (key) {\n    const place = await this._findPlace(key)\n    const child = place.bucket._at(place.pos)\n\n    if (child && child.key === key) {\n      place.bucket._delAt(place.pos)\n    }\n  }\n\n  /**\n   * @returns {number}\n   */\n  leafCount () {\n    const children = this._children.compactArray()\n\n    return children.reduce((acc, child) => {\n      if (child instanceof Bucket) {\n        return acc + child.leafCount()\n      }\n\n      return acc + 1\n    }, 0)\n  }\n\n  childrenCount () {\n    return this._children.length\n  }\n\n  onlyChild () {\n    return this._children.get(0)\n  }\n\n  /**\n   * @returns {Iterable<BucketChild<T>>}\n   */\n  * eachLeafSeries () {\n    const children = this._children.compactArray()\n\n    for (const child of children) {\n      if (child instanceof Bucket) {\n        yield * child.eachLeafSeries()\n      } else {\n        yield child\n      }\n    }\n\n    // this is necessary because tsc requires a @return annotation as it\n    // can't derive a return type due to the recursion, and eslint requires\n    // a return statement when there is a @return annotation\n    return []\n  }\n\n  /**\n   * @param {(value: BucketChild<T>, index: number) => T} map\n   * @param {(reduced: any) => any} reduce\n   */\n  serialize (map, reduce) {\n    /** @type {T[]} */\n    const acc = []\n    // serialize to a custom non-sparse representation\n    return reduce(this._children.reduce((acc, child, index) => {\n      if (child) {\n        if (child instanceof Bucket) {\n          acc.push(child.serialize(map, reduce))\n        } else {\n          acc.push(map(child, index))\n        }\n      }\n      return acc\n    }, acc))\n  }\n\n  /**\n   * @param {(value: BucketChild<T>) => Promise<T[]>} asyncMap\n   * @param {(reduced: any) => Promise<any>} asyncReduce\n   */\n  asyncTransform (asyncMap, asyncReduce) {\n    return asyncTransformBucket(this, asyncMap, asyncReduce)\n  }\n\n  toJSON () {\n    return this.serialize(mapNode, reduceNodes)\n  }\n\n  prettyPrint () {\n    return JSON.stringify(this.toJSON(), null, '  ')\n  }\n\n  tableSize () {\n    return Math.pow(2, this._options.bits)\n  }\n\n  /**\n   * @param {string} key\n   * @returns {Promise<BucketChild<T> | undefined>}\n   */\n  async _findChild (key) {\n    const result = await this._findPlace(key)\n    const child = result.bucket._at(result.pos)\n\n    if (child instanceof Bucket) {\n      // should not be possible, this._findPlace should always\n      // return a location for a child, not a bucket\n      return undefined\n    }\n\n    if (child && child.key === key) {\n      return child\n    }\n  }\n\n  /**\n   * @param {string | InfiniteHash} key\n   * @returns {Promise<BucketPosition<T>>}\n   */\n  async _findPlace (key) {\n    const hashValue = this._options.hash(typeof key === 'string' ? uint8ArrayFromString(key) : key)\n    const index = await hashValue.take(this._options.bits)\n\n    const child = this._children.get(index)\n\n    if (child instanceof Bucket) {\n      return child._findPlace(hashValue)\n    }\n\n    return {\n      bucket: this,\n      pos: index,\n      hash: hashValue,\n      existingChild: child\n    }\n  }\n\n  /**\n   * @param {string | InfiniteHash} key\n   * @returns {Promise<BucketPosition<T>>}\n   */\n  async _findNewBucketAndPos (key) {\n    const place = await this._findPlace(key)\n\n    if (place.existingChild && place.existingChild.key !== key) {\n      // conflict\n      const bucket = new Bucket(this._options, place.bucket, place.pos)\n      place.bucket._putObjectAt(place.pos, bucket)\n\n      // put the previous value\n      const newPlace = await bucket._findPlace(place.existingChild.hash)\n      newPlace.bucket._putAt(newPlace, place.existingChild.key, place.existingChild.value)\n\n      return bucket._findNewBucketAndPos(place.hash)\n    }\n\n    // no conflict, we found the place\n    return place\n  }\n\n  /**\n   * @param {BucketPosition<T>} place\n   * @param {string} key\n   * @param {T} value\n   */\n  _putAt (place, key, value) {\n    this._putObjectAt(place.pos, {\n      key: key,\n      value: value,\n      hash: place.hash\n    })\n  }\n\n  /**\n   * @param {number} pos\n   * @param {Bucket<T> | BucketChild<T>} object\n   */\n  _putObjectAt (pos, object) {\n    if (!this._children.get(pos)) {\n      this._popCount++\n    }\n    this._children.set(pos, object)\n  }\n\n  /**\n   * @param {number} pos\n   */\n  _delAt (pos) {\n    if (pos === -1) {\n      throw new Error('Invalid position')\n    }\n\n    if (this._children.get(pos)) {\n      this._popCount--\n    }\n    this._children.unset(pos)\n    this._level()\n  }\n\n  _level () {\n    if (this._parent && this._popCount <= 1) {\n      if (this._popCount === 1) {\n        // remove myself from parent, replacing me with my only child\n        const onlyChild = this._children.find(exists)\n\n        if (onlyChild && !(onlyChild instanceof Bucket)) {\n          const hash = onlyChild.hash\n          hash.untake(this._options.bits)\n          const place = {\n            pos: this._posAtParent,\n            hash: hash,\n            bucket: this._parent\n          }\n          this._parent._putAt(place, onlyChild.key, onlyChild.value)\n        }\n      } else {\n        this._parent._delAt(this._posAtParent)\n      }\n    }\n  }\n\n  /**\n   * @param {number} index\n   * @returns {BucketChild<T> | Bucket<T> | undefined}\n   */\n  _at (index) {\n    return this._children.get(index)\n  }\n}\n\n/**\n * @param {any} o\n */\nfunction exists (o) {\n  return Boolean(o)\n}\n\n/**\n *\n * @param {*} node\n * @param {number} index\n */\nfunction mapNode (node, index) {\n  return node.key\n}\n\n/**\n * @param {*} nodes\n */\nfunction reduceNodes (nodes) {\n  return nodes\n}\n\n/**\n * @template T\n *\n * @param {Bucket<T>} bucket\n * @param {(value: BucketChild<T>) => Promise<T[]>} asyncMap\n * @param {(reduced: any) => Promise<any>} asyncReduce\n */\nasync function asyncTransformBucket (bucket, asyncMap, asyncReduce) {\n  const output = []\n\n  for (const child of bucket._children.compactArray()) {\n    if (child instanceof Bucket) {\n      await asyncTransformBucket(child, asyncMap, asyncReduce)\n    } else {\n      const mappedChildren = await asyncMap(child)\n\n      output.push({\n        bitField: bucket._children.bitField(),\n        children: mappedChildren\n      })\n    }\n  }\n\n  return asyncReduce(output)\n}\n\nmodule.exports = Bucket\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvaGFtdC1zaGFyZGluZy9zcmMvYnVja2V0LmpzIiwibWFwcGluZ3MiOiJBQUFZOztBQUVaO0FBQ0Esb0JBQW9CLG1CQUFPLENBQUMsZ0VBQWM7QUFDMUMsUUFBUSxtQ0FBbUMsRUFBRSxtQkFBTyxDQUFDLHdGQUF5Qjs7QUFFOUU7QUFDQSxhQUFhLDBDQUEwQztBQUN2RCxhQUFhLGlDQUFpQztBQUM5Qzs7QUFFQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGNBQWMsUUFBUTtBQUN0QixjQUFjLEdBQUc7QUFDakIsY0FBYyxjQUFjO0FBQzVCOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixjQUFjLFFBQVE7QUFDdEIsY0FBYyxXQUFXO0FBQ3pCLGNBQWMsa0JBQWtCO0FBQ2hDLGNBQWMsK0JBQStCO0FBQzdDLGNBQWMsa0VBQWtFO0FBQ2hGLGNBQWMsNkNBQTZDO0FBQzNELGNBQWMsZ0JBQWdCO0FBQzlCLGNBQWMscUJBQXFCO0FBQ25DOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixjQUFjLFdBQVc7QUFDekIsY0FBYyxRQUFRO0FBQ3RCLGNBQWMsY0FBYztBQUM1QixjQUFjLGdCQUFnQjtBQUM5Qjs7QUFFQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixjQUFjLFFBQVE7QUFDdEIsY0FBYyxvREFBb0Q7QUFDbEU7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsZUFBZTtBQUM1QixhQUFhLFdBQVc7QUFDeEIsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxlQUFlLGdDQUFnQztBQUMvQzs7QUFFQSxlQUFlLGVBQWU7QUFDOUI7QUFDQTs7QUFFQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixhQUFhLEdBQUc7QUFDaEI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxhQUFhLDZDQUE2QztBQUMxRCxhQUFhLHVCQUF1QjtBQUNwQztBQUNBO0FBQ0EsZUFBZSxLQUFLO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBLGFBQWEseUNBQXlDO0FBQ3RELGFBQWEsZ0NBQWdDO0FBQzdDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsYUFBYSx1QkFBdUI7QUFDcEMsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGFBQWEsdUJBQXVCO0FBQ3BDLGVBQWU7QUFDZjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsYUFBYSxtQkFBbUI7QUFDaEMsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsR0FBRztBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQSxhQUFhLFFBQVE7QUFDckIsYUFBYSw0QkFBNEI7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFdBQVcsS0FBSztBQUNoQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxHQUFHO0FBQ2QsV0FBVyxRQUFRO0FBQ25CO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsV0FBVyxHQUFHO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxXQUFXO0FBQ3RCLFdBQVcseUNBQXlDO0FBQ3BELFdBQVcsZ0NBQWdDO0FBQzNDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSIsInNvdXJjZXMiOlsiL2hvbWUvYWx0Y29pbi1kYWRkeS9Eb3dubG9hZHMvb3dubHkvbm9kZV9tb2R1bGVzL2hhbXQtc2hhcmRpbmcvc3JjL2J1Y2tldC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCdcblxuLy8gQHRzLWlnbm9yZVxuY29uc3QgU3BhcnNlQXJyYXkgPSByZXF1aXJlKCdzcGFyc2UtYXJyYXknKVxuY29uc3QgeyBmcm9tU3RyaW5nOiB1aW50OEFycmF5RnJvbVN0cmluZyB9ID0gcmVxdWlyZSgndWludDhhcnJheXMvZnJvbS1zdHJpbmcnKVxuXG4vKipcbiAqIEB0eXBlZGVmIHtpbXBvcnQoJy4vY29uc3VtYWJsZS1oYXNoJykuSW5maW5pdGVIYXNofSBJbmZpbml0ZUhhc2hcbiAqIEB0eXBlZGVmIHtpbXBvcnQoJy4uLycpLlVzZXJCdWNrZXRPcHRpb25zfSBVc2VyQnVja2V0T3B0aW9uc1xuICovXG5cbi8qKlxuICogQHRlbXBsYXRlIFZcbiAqIEB0eXBlZGVmIHtvYmplY3R9IEJ1Y2tldENoaWxkPFY+XG4gKiBAcHJvcGVydHkge3N0cmluZ30ga2V5XG4gKiBAcHJvcGVydHkge1Z9IHZhbHVlXG4gKiBAcHJvcGVydHkge0luZmluaXRlSGFzaH0gaGFzaFxuICovXG5cbi8qKlxuICogQHRlbXBsYXRlIEJcbiAqXG4gKiBAdHlwZWRlZiB7b2JqZWN0fSBTQTxCPlxuICogQHByb3BlcnR5IHtudW1iZXJ9IGxlbmd0aFxuICogQHByb3BlcnR5IHsoKSA9PiBCW119IGNvbXBhY3RBcnJheVxuICogQHByb3BlcnR5IHsoaTogbnVtYmVyKSA9PiBCfSBnZXRcbiAqIEBwcm9wZXJ0eSB7KGk6IG51bWJlciwgdmFsdWU6IEIpID0+IHZvaWR9IHNldFxuICogQHByb3BlcnR5IHs8QT4gKGZuOiAoYWNjOiBBLCBjdXJyOiBCLCBpbmRleDogbnVtYmVyKSA9PiBBLCBpbml0aWFsOiBBKSA9PiBCfSByZWR1Y2VcbiAqIEBwcm9wZXJ0eSB7KGZuOiAoaXRlbTogQikgPT4gYm9vbGVhbikgPT4gQiB8IHVuZGVmaW5lZH0gZmluZFxuICogQHByb3BlcnR5IHsoKSA9PiBudW1iZXJbXX0gYml0RmllbGRcbiAqIEBwcm9wZXJ0eSB7KGk6IG51bWJlcikgPT4gdm9pZH0gdW5zZXRcbiAqL1xuXG4vKipcbiAqIEB0ZW1wbGF0ZSBUXG4gKlxuICogQHR5cGVkZWYge29iamVjdH0gQnVja2V0UG9zaXRpb248VD5cbiAqIEBwcm9wZXJ0eSB7QnVja2V0PFQ+fSBidWNrZXRcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBwb3NcbiAqIEBwcm9wZXJ0eSB7SW5maW5pdGVIYXNofSBoYXNoXG4gKiBAcHJvcGVydHkge0J1Y2tldENoaWxkPFQ+fSBbZXhpc3RpbmdDaGlsZF1cbiAqL1xuXG4vKipcbiAqIEB0eXBlZGVmIHtvYmplY3R9IEJ1Y2tldE9wdGlvbnNcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBiaXRzXG4gKiBAcHJvcGVydHkgeyh2YWx1ZTogVWludDhBcnJheSB8IEluZmluaXRlSGFzaCkgPT4gSW5maW5pdGVIYXNofSBoYXNoXG4gKi9cblxuLyoqXG4gKiBAdGVtcGxhdGUgVFxuICovXG5jbGFzcyBCdWNrZXQge1xuICAvKipcbiAgICogQHBhcmFtIHtCdWNrZXRPcHRpb25zfSBvcHRpb25zXG4gICAqIEBwYXJhbSB7QnVja2V0PFQ+fSBbcGFyZW50XVxuICAgKiBAcGFyYW0ge251bWJlcn0gW3Bvc0F0UGFyZW50PTBdXG4gICAqL1xuICBjb25zdHJ1Y3RvciAob3B0aW9ucywgcGFyZW50LCBwb3NBdFBhcmVudCA9IDApIHtcbiAgICB0aGlzLl9vcHRpb25zID0gb3B0aW9uc1xuICAgIHRoaXMuX3BvcENvdW50ID0gMFxuICAgIHRoaXMuX3BhcmVudCA9IHBhcmVudFxuICAgIHRoaXMuX3Bvc0F0UGFyZW50ID0gcG9zQXRQYXJlbnRcblxuICAgIC8qKiBAdHlwZSB7U0E8QnVja2V0PFQ+IHwgQnVja2V0Q2hpbGQ8VD4+fSAqL1xuICAgIHRoaXMuX2NoaWxkcmVuID0gbmV3IFNwYXJzZUFycmF5KClcblxuICAgIC8qKiBAdHlwZSB7c3RyaW5nIHwgbnVsbH0gKi9cbiAgICB0aGlzLmtleSA9IG51bGxcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5XG4gICAqIEBwYXJhbSB7VH0gdmFsdWVcbiAgICovXG4gIGFzeW5jIHB1dCAoa2V5LCB2YWx1ZSkge1xuICAgIGNvbnN0IHBsYWNlID0gYXdhaXQgdGhpcy5fZmluZE5ld0J1Y2tldEFuZFBvcyhrZXkpXG5cbiAgICBhd2FpdCBwbGFjZS5idWNrZXQuX3B1dEF0KHBsYWNlLCBrZXksIHZhbHVlKVxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBrZXlcbiAgICovXG4gIGFzeW5jIGdldCAoa2V5KSB7XG4gICAgY29uc3QgY2hpbGQgPSBhd2FpdCB0aGlzLl9maW5kQ2hpbGQoa2V5KVxuXG4gICAgaWYgKGNoaWxkKSB7XG4gICAgICByZXR1cm4gY2hpbGQudmFsdWVcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtzdHJpbmd9IGtleVxuICAgKi9cbiAgYXN5bmMgZGVsIChrZXkpIHtcbiAgICBjb25zdCBwbGFjZSA9IGF3YWl0IHRoaXMuX2ZpbmRQbGFjZShrZXkpXG4gICAgY29uc3QgY2hpbGQgPSBwbGFjZS5idWNrZXQuX2F0KHBsYWNlLnBvcylcblxuICAgIGlmIChjaGlsZCAmJiBjaGlsZC5rZXkgPT09IGtleSkge1xuICAgICAgcGxhY2UuYnVja2V0Ll9kZWxBdChwbGFjZS5wb3MpXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm5zIHtudW1iZXJ9XG4gICAqL1xuICBsZWFmQ291bnQgKCkge1xuICAgIGNvbnN0IGNoaWxkcmVuID0gdGhpcy5fY2hpbGRyZW4uY29tcGFjdEFycmF5KClcblxuICAgIHJldHVybiBjaGlsZHJlbi5yZWR1Y2UoKGFjYywgY2hpbGQpID0+IHtcbiAgICAgIGlmIChjaGlsZCBpbnN0YW5jZW9mIEJ1Y2tldCkge1xuICAgICAgICByZXR1cm4gYWNjICsgY2hpbGQubGVhZkNvdW50KClcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGFjYyArIDFcbiAgICB9LCAwKVxuICB9XG5cbiAgY2hpbGRyZW5Db3VudCAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2NoaWxkcmVuLmxlbmd0aFxuICB9XG5cbiAgb25seUNoaWxkICgpIHtcbiAgICByZXR1cm4gdGhpcy5fY2hpbGRyZW4uZ2V0KDApXG4gIH1cblxuICAvKipcbiAgICogQHJldHVybnMge0l0ZXJhYmxlPEJ1Y2tldENoaWxkPFQ+Pn1cbiAgICovXG4gICogZWFjaExlYWZTZXJpZXMgKCkge1xuICAgIGNvbnN0IGNoaWxkcmVuID0gdGhpcy5fY2hpbGRyZW4uY29tcGFjdEFycmF5KClcblxuICAgIGZvciAoY29uc3QgY2hpbGQgb2YgY2hpbGRyZW4pIHtcbiAgICAgIGlmIChjaGlsZCBpbnN0YW5jZW9mIEJ1Y2tldCkge1xuICAgICAgICB5aWVsZCAqIGNoaWxkLmVhY2hMZWFmU2VyaWVzKClcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHlpZWxkIGNoaWxkXG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gdGhpcyBpcyBuZWNlc3NhcnkgYmVjYXVzZSB0c2MgcmVxdWlyZXMgYSBAcmV0dXJuIGFubm90YXRpb24gYXMgaXRcbiAgICAvLyBjYW4ndCBkZXJpdmUgYSByZXR1cm4gdHlwZSBkdWUgdG8gdGhlIHJlY3Vyc2lvbiwgYW5kIGVzbGludCByZXF1aXJlc1xuICAgIC8vIGEgcmV0dXJuIHN0YXRlbWVudCB3aGVuIHRoZXJlIGlzIGEgQHJldHVybiBhbm5vdGF0aW9uXG4gICAgcmV0dXJuIFtdXG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHsodmFsdWU6IEJ1Y2tldENoaWxkPFQ+LCBpbmRleDogbnVtYmVyKSA9PiBUfSBtYXBcbiAgICogQHBhcmFtIHsocmVkdWNlZDogYW55KSA9PiBhbnl9IHJlZHVjZVxuICAgKi9cbiAgc2VyaWFsaXplIChtYXAsIHJlZHVjZSkge1xuICAgIC8qKiBAdHlwZSB7VFtdfSAqL1xuICAgIGNvbnN0IGFjYyA9IFtdXG4gICAgLy8gc2VyaWFsaXplIHRvIGEgY3VzdG9tIG5vbi1zcGFyc2UgcmVwcmVzZW50YXRpb25cbiAgICByZXR1cm4gcmVkdWNlKHRoaXMuX2NoaWxkcmVuLnJlZHVjZSgoYWNjLCBjaGlsZCwgaW5kZXgpID0+IHtcbiAgICAgIGlmIChjaGlsZCkge1xuICAgICAgICBpZiAoY2hpbGQgaW5zdGFuY2VvZiBCdWNrZXQpIHtcbiAgICAgICAgICBhY2MucHVzaChjaGlsZC5zZXJpYWxpemUobWFwLCByZWR1Y2UpKVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGFjYy5wdXNoKG1hcChjaGlsZCwgaW5kZXgpKVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gYWNjXG4gICAgfSwgYWNjKSlcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0geyh2YWx1ZTogQnVja2V0Q2hpbGQ8VD4pID0+IFByb21pc2U8VFtdPn0gYXN5bmNNYXBcbiAgICogQHBhcmFtIHsocmVkdWNlZDogYW55KSA9PiBQcm9taXNlPGFueT59IGFzeW5jUmVkdWNlXG4gICAqL1xuICBhc3luY1RyYW5zZm9ybSAoYXN5bmNNYXAsIGFzeW5jUmVkdWNlKSB7XG4gICAgcmV0dXJuIGFzeW5jVHJhbnNmb3JtQnVja2V0KHRoaXMsIGFzeW5jTWFwLCBhc3luY1JlZHVjZSlcbiAgfVxuXG4gIHRvSlNPTiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuc2VyaWFsaXplKG1hcE5vZGUsIHJlZHVjZU5vZGVzKVxuICB9XG5cbiAgcHJldHR5UHJpbnQgKCkge1xuICAgIHJldHVybiBKU09OLnN0cmluZ2lmeSh0aGlzLnRvSlNPTigpLCBudWxsLCAnICAnKVxuICB9XG5cbiAgdGFibGVTaXplICgpIHtcbiAgICByZXR1cm4gTWF0aC5wb3coMiwgdGhpcy5fb3B0aW9ucy5iaXRzKVxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBrZXlcbiAgICogQHJldHVybnMge1Byb21pc2U8QnVja2V0Q2hpbGQ8VD4gfCB1bmRlZmluZWQ+fVxuICAgKi9cbiAgYXN5bmMgX2ZpbmRDaGlsZCAoa2V5KSB7XG4gICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgdGhpcy5fZmluZFBsYWNlKGtleSlcbiAgICBjb25zdCBjaGlsZCA9IHJlc3VsdC5idWNrZXQuX2F0KHJlc3VsdC5wb3MpXG5cbiAgICBpZiAoY2hpbGQgaW5zdGFuY2VvZiBCdWNrZXQpIHtcbiAgICAgIC8vIHNob3VsZCBub3QgYmUgcG9zc2libGUsIHRoaXMuX2ZpbmRQbGFjZSBzaG91bGQgYWx3YXlzXG4gICAgICAvLyByZXR1cm4gYSBsb2NhdGlvbiBmb3IgYSBjaGlsZCwgbm90IGEgYnVja2V0XG4gICAgICByZXR1cm4gdW5kZWZpbmVkXG4gICAgfVxuXG4gICAgaWYgKGNoaWxkICYmIGNoaWxkLmtleSA9PT0ga2V5KSB7XG4gICAgICByZXR1cm4gY2hpbGRcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtzdHJpbmcgfCBJbmZpbml0ZUhhc2h9IGtleVxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxCdWNrZXRQb3NpdGlvbjxUPj59XG4gICAqL1xuICBhc3luYyBfZmluZFBsYWNlIChrZXkpIHtcbiAgICBjb25zdCBoYXNoVmFsdWUgPSB0aGlzLl9vcHRpb25zLmhhc2godHlwZW9mIGtleSA9PT0gJ3N0cmluZycgPyB1aW50OEFycmF5RnJvbVN0cmluZyhrZXkpIDoga2V5KVxuICAgIGNvbnN0IGluZGV4ID0gYXdhaXQgaGFzaFZhbHVlLnRha2UodGhpcy5fb3B0aW9ucy5iaXRzKVxuXG4gICAgY29uc3QgY2hpbGQgPSB0aGlzLl9jaGlsZHJlbi5nZXQoaW5kZXgpXG5cbiAgICBpZiAoY2hpbGQgaW5zdGFuY2VvZiBCdWNrZXQpIHtcbiAgICAgIHJldHVybiBjaGlsZC5fZmluZFBsYWNlKGhhc2hWYWx1ZSlcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgYnVja2V0OiB0aGlzLFxuICAgICAgcG9zOiBpbmRleCxcbiAgICAgIGhhc2g6IGhhc2hWYWx1ZSxcbiAgICAgIGV4aXN0aW5nQ2hpbGQ6IGNoaWxkXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7c3RyaW5nIHwgSW5maW5pdGVIYXNofSBrZXlcbiAgICogQHJldHVybnMge1Byb21pc2U8QnVja2V0UG9zaXRpb248VD4+fVxuICAgKi9cbiAgYXN5bmMgX2ZpbmROZXdCdWNrZXRBbmRQb3MgKGtleSkge1xuICAgIGNvbnN0IHBsYWNlID0gYXdhaXQgdGhpcy5fZmluZFBsYWNlKGtleSlcblxuICAgIGlmIChwbGFjZS5leGlzdGluZ0NoaWxkICYmIHBsYWNlLmV4aXN0aW5nQ2hpbGQua2V5ICE9PSBrZXkpIHtcbiAgICAgIC8vIGNvbmZsaWN0XG4gICAgICBjb25zdCBidWNrZXQgPSBuZXcgQnVja2V0KHRoaXMuX29wdGlvbnMsIHBsYWNlLmJ1Y2tldCwgcGxhY2UucG9zKVxuICAgICAgcGxhY2UuYnVja2V0Ll9wdXRPYmplY3RBdChwbGFjZS5wb3MsIGJ1Y2tldClcblxuICAgICAgLy8gcHV0IHRoZSBwcmV2aW91cyB2YWx1ZVxuICAgICAgY29uc3QgbmV3UGxhY2UgPSBhd2FpdCBidWNrZXQuX2ZpbmRQbGFjZShwbGFjZS5leGlzdGluZ0NoaWxkLmhhc2gpXG4gICAgICBuZXdQbGFjZS5idWNrZXQuX3B1dEF0KG5ld1BsYWNlLCBwbGFjZS5leGlzdGluZ0NoaWxkLmtleSwgcGxhY2UuZXhpc3RpbmdDaGlsZC52YWx1ZSlcblxuICAgICAgcmV0dXJuIGJ1Y2tldC5fZmluZE5ld0J1Y2tldEFuZFBvcyhwbGFjZS5oYXNoKVxuICAgIH1cblxuICAgIC8vIG5vIGNvbmZsaWN0LCB3ZSBmb3VuZCB0aGUgcGxhY2VcbiAgICByZXR1cm4gcGxhY2VcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge0J1Y2tldFBvc2l0aW9uPFQ+fSBwbGFjZVxuICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5XG4gICAqIEBwYXJhbSB7VH0gdmFsdWVcbiAgICovXG4gIF9wdXRBdCAocGxhY2UsIGtleSwgdmFsdWUpIHtcbiAgICB0aGlzLl9wdXRPYmplY3RBdChwbGFjZS5wb3MsIHtcbiAgICAgIGtleToga2V5LFxuICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgaGFzaDogcGxhY2UuaGFzaFxuICAgIH0pXG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtudW1iZXJ9IHBvc1xuICAgKiBAcGFyYW0ge0J1Y2tldDxUPiB8IEJ1Y2tldENoaWxkPFQ+fSBvYmplY3RcbiAgICovXG4gIF9wdXRPYmplY3RBdCAocG9zLCBvYmplY3QpIHtcbiAgICBpZiAoIXRoaXMuX2NoaWxkcmVuLmdldChwb3MpKSB7XG4gICAgICB0aGlzLl9wb3BDb3VudCsrXG4gICAgfVxuICAgIHRoaXMuX2NoaWxkcmVuLnNldChwb3MsIG9iamVjdClcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge251bWJlcn0gcG9zXG4gICAqL1xuICBfZGVsQXQgKHBvcykge1xuICAgIGlmIChwb3MgPT09IC0xKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgcG9zaXRpb24nKVxuICAgIH1cblxuICAgIGlmICh0aGlzLl9jaGlsZHJlbi5nZXQocG9zKSkge1xuICAgICAgdGhpcy5fcG9wQ291bnQtLVxuICAgIH1cbiAgICB0aGlzLl9jaGlsZHJlbi51bnNldChwb3MpXG4gICAgdGhpcy5fbGV2ZWwoKVxuICB9XG5cbiAgX2xldmVsICgpIHtcbiAgICBpZiAodGhpcy5fcGFyZW50ICYmIHRoaXMuX3BvcENvdW50IDw9IDEpIHtcbiAgICAgIGlmICh0aGlzLl9wb3BDb3VudCA9PT0gMSkge1xuICAgICAgICAvLyByZW1vdmUgbXlzZWxmIGZyb20gcGFyZW50LCByZXBsYWNpbmcgbWUgd2l0aCBteSBvbmx5IGNoaWxkXG4gICAgICAgIGNvbnN0IG9ubHlDaGlsZCA9IHRoaXMuX2NoaWxkcmVuLmZpbmQoZXhpc3RzKVxuXG4gICAgICAgIGlmIChvbmx5Q2hpbGQgJiYgIShvbmx5Q2hpbGQgaW5zdGFuY2VvZiBCdWNrZXQpKSB7XG4gICAgICAgICAgY29uc3QgaGFzaCA9IG9ubHlDaGlsZC5oYXNoXG4gICAgICAgICAgaGFzaC51bnRha2UodGhpcy5fb3B0aW9ucy5iaXRzKVxuICAgICAgICAgIGNvbnN0IHBsYWNlID0ge1xuICAgICAgICAgICAgcG9zOiB0aGlzLl9wb3NBdFBhcmVudCxcbiAgICAgICAgICAgIGhhc2g6IGhhc2gsXG4gICAgICAgICAgICBidWNrZXQ6IHRoaXMuX3BhcmVudFxuICAgICAgICAgIH1cbiAgICAgICAgICB0aGlzLl9wYXJlbnQuX3B1dEF0KHBsYWNlLCBvbmx5Q2hpbGQua2V5LCBvbmx5Q2hpbGQudmFsdWUpXG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuX3BhcmVudC5fZGVsQXQodGhpcy5fcG9zQXRQYXJlbnQpXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleFxuICAgKiBAcmV0dXJucyB7QnVja2V0Q2hpbGQ8VD4gfCBCdWNrZXQ8VD4gfCB1bmRlZmluZWR9XG4gICAqL1xuICBfYXQgKGluZGV4KSB7XG4gICAgcmV0dXJuIHRoaXMuX2NoaWxkcmVuLmdldChpbmRleClcbiAgfVxufVxuXG4vKipcbiAqIEBwYXJhbSB7YW55fSBvXG4gKi9cbmZ1bmN0aW9uIGV4aXN0cyAobykge1xuICByZXR1cm4gQm9vbGVhbihvKVxufVxuXG4vKipcbiAqXG4gKiBAcGFyYW0geyp9IG5vZGVcbiAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleFxuICovXG5mdW5jdGlvbiBtYXBOb2RlIChub2RlLCBpbmRleCkge1xuICByZXR1cm4gbm9kZS5rZXlcbn1cblxuLyoqXG4gKiBAcGFyYW0geyp9IG5vZGVzXG4gKi9cbmZ1bmN0aW9uIHJlZHVjZU5vZGVzIChub2Rlcykge1xuICByZXR1cm4gbm9kZXNcbn1cblxuLyoqXG4gKiBAdGVtcGxhdGUgVFxuICpcbiAqIEBwYXJhbSB7QnVja2V0PFQ+fSBidWNrZXRcbiAqIEBwYXJhbSB7KHZhbHVlOiBCdWNrZXRDaGlsZDxUPikgPT4gUHJvbWlzZTxUW10+fSBhc3luY01hcFxuICogQHBhcmFtIHsocmVkdWNlZDogYW55KSA9PiBQcm9taXNlPGFueT59IGFzeW5jUmVkdWNlXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIGFzeW5jVHJhbnNmb3JtQnVja2V0IChidWNrZXQsIGFzeW5jTWFwLCBhc3luY1JlZHVjZSkge1xuICBjb25zdCBvdXRwdXQgPSBbXVxuXG4gIGZvciAoY29uc3QgY2hpbGQgb2YgYnVja2V0Ll9jaGlsZHJlbi5jb21wYWN0QXJyYXkoKSkge1xuICAgIGlmIChjaGlsZCBpbnN0YW5jZW9mIEJ1Y2tldCkge1xuICAgICAgYXdhaXQgYXN5bmNUcmFuc2Zvcm1CdWNrZXQoY2hpbGQsIGFzeW5jTWFwLCBhc3luY1JlZHVjZSlcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgbWFwcGVkQ2hpbGRyZW4gPSBhd2FpdCBhc3luY01hcChjaGlsZClcblxuICAgICAgb3V0cHV0LnB1c2goe1xuICAgICAgICBiaXRGaWVsZDogYnVja2V0Ll9jaGlsZHJlbi5iaXRGaWVsZCgpLFxuICAgICAgICBjaGlsZHJlbjogbWFwcGVkQ2hpbGRyZW5cbiAgICAgIH0pXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGFzeW5jUmVkdWNlKG91dHB1dClcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBCdWNrZXRcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/hamt-sharding/src/bucket.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/hamt-sharding/src/consumable-buffer.js":
/*!*************************************************************!*\
  !*** ./node_modules/hamt-sharding/src/consumable-buffer.js ***!
  \*************************************************************/
/***/ ((module) => {

eval("\n\nconst START_MASKS = [\n  0b11111111,\n  0b11111110,\n  0b11111100,\n  0b11111000,\n  0b11110000,\n  0b11100000,\n  0b11000000,\n  0b10000000\n]\n\nconst STOP_MASKS = [\n  0b00000001,\n  0b00000011,\n  0b00000111,\n  0b00001111,\n  0b00011111,\n  0b00111111,\n  0b01111111,\n  0b11111111\n]\n\nmodule.exports = class ConsumableBuffer {\n  /**\n   * @param {Uint8Array} value\n   */\n  constructor (value) {\n    this._value = value\n    this._currentBytePos = value.length - 1\n    this._currentBitPos = 7\n  }\n\n  availableBits () {\n    return this._currentBitPos + 1 + this._currentBytePos * 8\n  }\n\n  totalBits () {\n    return this._value.length * 8\n  }\n\n  /**\n   * @param {number} bits\n   */\n  take (bits) {\n    let pendingBits = bits\n    let result = 0\n    while (pendingBits && this._haveBits()) {\n      const byte = this._value[this._currentBytePos]\n      const availableBits = this._currentBitPos + 1\n      const taking = Math.min(availableBits, pendingBits)\n      const value = byteBitsToInt(byte, availableBits - taking, taking)\n      result = (result << taking) + value\n\n      pendingBits -= taking\n\n      this._currentBitPos -= taking\n      if (this._currentBitPos < 0) {\n        this._currentBitPos = 7\n        this._currentBytePos--\n      }\n    }\n\n    return result\n  }\n\n  /**\n   * @param {number} bits\n   */\n  untake (bits) {\n    this._currentBitPos += bits\n    while (this._currentBitPos > 7) {\n      this._currentBitPos -= 8\n      this._currentBytePos += 1\n    }\n  }\n\n  _haveBits () {\n    return this._currentBytePos >= 0\n  }\n}\n\n/**\n * @param {number} byte\n * @param {number} start\n * @param {number} length\n */\nfunction byteBitsToInt (byte, start, length) {\n  const mask = maskFor(start, length)\n  return (byte & mask) >>> start\n}\n\n/**\n * @param {number} start\n * @param {number} length\n */\nfunction maskFor (start, length) {\n  return START_MASKS[start] & STOP_MASKS[Math.min(length + start - 1, 7)]\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvaGFtdC1zaGFyZGluZy9zcmMvY29uc3VtYWJsZS1idWZmZXIuanMiLCJtYXBwaW5ncyI6IkFBQVk7O0FBRVo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGFBQWEsWUFBWTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkI7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIi9ob21lL2FsdGNvaW4tZGFkZHkvRG93bmxvYWRzL293bmx5L25vZGVfbW9kdWxlcy9oYW10LXNoYXJkaW5nL3NyYy9jb25zdW1hYmxlLWJ1ZmZlci5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCdcblxuY29uc3QgU1RBUlRfTUFTS1MgPSBbXG4gIDBiMTExMTExMTEsXG4gIDBiMTExMTExMTAsXG4gIDBiMTExMTExMDAsXG4gIDBiMTExMTEwMDAsXG4gIDBiMTExMTAwMDAsXG4gIDBiMTExMDAwMDAsXG4gIDBiMTEwMDAwMDAsXG4gIDBiMTAwMDAwMDBcbl1cblxuY29uc3QgU1RPUF9NQVNLUyA9IFtcbiAgMGIwMDAwMDAwMSxcbiAgMGIwMDAwMDAxMSxcbiAgMGIwMDAwMDExMSxcbiAgMGIwMDAwMTExMSxcbiAgMGIwMDAxMTExMSxcbiAgMGIwMDExMTExMSxcbiAgMGIwMTExMTExMSxcbiAgMGIxMTExMTExMVxuXVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNsYXNzIENvbnN1bWFibGVCdWZmZXIge1xuICAvKipcbiAgICogQHBhcmFtIHtVaW50OEFycmF5fSB2YWx1ZVxuICAgKi9cbiAgY29uc3RydWN0b3IgKHZhbHVlKSB7XG4gICAgdGhpcy5fdmFsdWUgPSB2YWx1ZVxuICAgIHRoaXMuX2N1cnJlbnRCeXRlUG9zID0gdmFsdWUubGVuZ3RoIC0gMVxuICAgIHRoaXMuX2N1cnJlbnRCaXRQb3MgPSA3XG4gIH1cblxuICBhdmFpbGFibGVCaXRzICgpIHtcbiAgICByZXR1cm4gdGhpcy5fY3VycmVudEJpdFBvcyArIDEgKyB0aGlzLl9jdXJyZW50Qnl0ZVBvcyAqIDhcbiAgfVxuXG4gIHRvdGFsQml0cyAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3ZhbHVlLmxlbmd0aCAqIDhcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge251bWJlcn0gYml0c1xuICAgKi9cbiAgdGFrZSAoYml0cykge1xuICAgIGxldCBwZW5kaW5nQml0cyA9IGJpdHNcbiAgICBsZXQgcmVzdWx0ID0gMFxuICAgIHdoaWxlIChwZW5kaW5nQml0cyAmJiB0aGlzLl9oYXZlQml0cygpKSB7XG4gICAgICBjb25zdCBieXRlID0gdGhpcy5fdmFsdWVbdGhpcy5fY3VycmVudEJ5dGVQb3NdXG4gICAgICBjb25zdCBhdmFpbGFibGVCaXRzID0gdGhpcy5fY3VycmVudEJpdFBvcyArIDFcbiAgICAgIGNvbnN0IHRha2luZyA9IE1hdGgubWluKGF2YWlsYWJsZUJpdHMsIHBlbmRpbmdCaXRzKVxuICAgICAgY29uc3QgdmFsdWUgPSBieXRlQml0c1RvSW50KGJ5dGUsIGF2YWlsYWJsZUJpdHMgLSB0YWtpbmcsIHRha2luZylcbiAgICAgIHJlc3VsdCA9IChyZXN1bHQgPDwgdGFraW5nKSArIHZhbHVlXG5cbiAgICAgIHBlbmRpbmdCaXRzIC09IHRha2luZ1xuXG4gICAgICB0aGlzLl9jdXJyZW50Qml0UG9zIC09IHRha2luZ1xuICAgICAgaWYgKHRoaXMuX2N1cnJlbnRCaXRQb3MgPCAwKSB7XG4gICAgICAgIHRoaXMuX2N1cnJlbnRCaXRQb3MgPSA3XG4gICAgICAgIHRoaXMuX2N1cnJlbnRCeXRlUG9zLS1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gcmVzdWx0XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtudW1iZXJ9IGJpdHNcbiAgICovXG4gIHVudGFrZSAoYml0cykge1xuICAgIHRoaXMuX2N1cnJlbnRCaXRQb3MgKz0gYml0c1xuICAgIHdoaWxlICh0aGlzLl9jdXJyZW50Qml0UG9zID4gNykge1xuICAgICAgdGhpcy5fY3VycmVudEJpdFBvcyAtPSA4XG4gICAgICB0aGlzLl9jdXJyZW50Qnl0ZVBvcyArPSAxXG4gICAgfVxuICB9XG5cbiAgX2hhdmVCaXRzICgpIHtcbiAgICByZXR1cm4gdGhpcy5fY3VycmVudEJ5dGVQb3MgPj0gMFxuICB9XG59XG5cbi8qKlxuICogQHBhcmFtIHtudW1iZXJ9IGJ5dGVcbiAqIEBwYXJhbSB7bnVtYmVyfSBzdGFydFxuICogQHBhcmFtIHtudW1iZXJ9IGxlbmd0aFxuICovXG5mdW5jdGlvbiBieXRlQml0c1RvSW50IChieXRlLCBzdGFydCwgbGVuZ3RoKSB7XG4gIGNvbnN0IG1hc2sgPSBtYXNrRm9yKHN0YXJ0LCBsZW5ndGgpXG4gIHJldHVybiAoYnl0ZSAmIG1hc2spID4+PiBzdGFydFxufVxuXG4vKipcbiAqIEBwYXJhbSB7bnVtYmVyfSBzdGFydFxuICogQHBhcmFtIHtudW1iZXJ9IGxlbmd0aFxuICovXG5mdW5jdGlvbiBtYXNrRm9yIChzdGFydCwgbGVuZ3RoKSB7XG4gIHJldHVybiBTVEFSVF9NQVNLU1tzdGFydF0gJiBTVE9QX01BU0tTW01hdGgubWluKGxlbmd0aCArIHN0YXJ0IC0gMSwgNyldXG59XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/hamt-sharding/src/consumable-buffer.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/hamt-sharding/src/consumable-hash.js":
/*!***********************************************************!*\
  !*** ./node_modules/hamt-sharding/src/consumable-hash.js ***!
  \***********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nconst ConsumableBuffer = __webpack_require__(/*! ./consumable-buffer */ \"(rsc)/./node_modules/hamt-sharding/src/consumable-buffer.js\")\nconst { concat: uint8ArrayConcat } = __webpack_require__(/*! uint8arrays/concat */ \"(rsc)/./node_modules/uint8arrays/cjs/src/concat.js\")\n\n/**\n * @param {(value: Uint8Array) => Promise<Uint8Array>} hashFn\n */\nfunction wrapHash (hashFn) {\n  /**\n   * @param {InfiniteHash | Uint8Array} value\n   */\n  function hashing (value) {\n    if (value instanceof InfiniteHash) {\n      // already a hash. return it\n      return value\n    } else {\n      return new InfiniteHash(value, hashFn)\n    }\n  }\n\n  return hashing\n}\n\nclass InfiniteHash {\n  /**\n   *\n   * @param {Uint8Array} value\n   * @param {(value: Uint8Array) => Promise<Uint8Array>} hashFn\n   */\n  constructor (value, hashFn) {\n    if (!(value instanceof Uint8Array)) {\n      throw new Error('can only hash Uint8Arrays')\n    }\n\n    this._value = value\n    this._hashFn = hashFn\n    this._depth = -1\n    this._availableBits = 0\n    this._currentBufferIndex = 0\n\n    /** @type {ConsumableBuffer[]} */\n    this._buffers = []\n  }\n\n  /**\n   * @param {number} bits\n   */\n  async take (bits) {\n    let pendingBits = bits\n\n    while (this._availableBits < pendingBits) {\n      await this._produceMoreBits()\n    }\n\n    let result = 0\n\n    while (pendingBits > 0) {\n      const hash = this._buffers[this._currentBufferIndex]\n      const available = Math.min(hash.availableBits(), pendingBits)\n      const took = hash.take(available)\n      result = (result << available) + took\n      pendingBits -= available\n      this._availableBits -= available\n\n      if (hash.availableBits() === 0) {\n        this._currentBufferIndex++\n      }\n    }\n\n    return result\n  }\n\n  /**\n   * @param {number} bits\n   */\n  untake (bits) {\n    let pendingBits = bits\n\n    while (pendingBits > 0) {\n      const hash = this._buffers[this._currentBufferIndex]\n      const availableForUntake = Math.min(hash.totalBits() - hash.availableBits(), pendingBits)\n      hash.untake(availableForUntake)\n      pendingBits -= availableForUntake\n      this._availableBits += availableForUntake\n\n      if (this._currentBufferIndex > 0 && hash.totalBits() === hash.availableBits()) {\n        this._depth--\n        this._currentBufferIndex--\n      }\n    }\n  }\n\n  async _produceMoreBits () {\n    this._depth++\n\n    const value = this._depth ? uint8ArrayConcat([this._value, Uint8Array.from([this._depth])]) : this._value\n    const hashValue = await this._hashFn(value)\n    const buffer = new ConsumableBuffer(hashValue)\n\n    this._buffers.push(buffer)\n    this._availableBits += buffer.availableBits()\n  }\n}\n\nmodule.exports = wrapHash\nmodule.exports.InfiniteHash = InfiniteHash\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvaGFtdC1zaGFyZGluZy9zcmMvY29uc3VtYWJsZS1oYXNoLmpzIiwibWFwcGluZ3MiOiJBQUFZOztBQUVaLHlCQUF5QixtQkFBTyxDQUFDLHdGQUFxQjtBQUN0RCxRQUFRLDJCQUEyQixFQUFFLG1CQUFPLENBQUMsOEVBQW9COztBQUVqRTtBQUNBLFdBQVcsNENBQTRDO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBLGFBQWEsMkJBQTJCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYSxZQUFZO0FBQ3pCLGFBQWEsNENBQTRDO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxlQUFlLG9CQUFvQjtBQUNuQztBQUNBOztBQUVBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDJCQUEyQiIsInNvdXJjZXMiOlsiL2hvbWUvYWx0Y29pbi1kYWRkeS9Eb3dubG9hZHMvb3dubHkvbm9kZV9tb2R1bGVzL2hhbXQtc2hhcmRpbmcvc3JjL2NvbnN1bWFibGUtaGFzaC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCdcblxuY29uc3QgQ29uc3VtYWJsZUJ1ZmZlciA9IHJlcXVpcmUoJy4vY29uc3VtYWJsZS1idWZmZXInKVxuY29uc3QgeyBjb25jYXQ6IHVpbnQ4QXJyYXlDb25jYXQgfSA9IHJlcXVpcmUoJ3VpbnQ4YXJyYXlzL2NvbmNhdCcpXG5cbi8qKlxuICogQHBhcmFtIHsodmFsdWU6IFVpbnQ4QXJyYXkpID0+IFByb21pc2U8VWludDhBcnJheT59IGhhc2hGblxuICovXG5mdW5jdGlvbiB3cmFwSGFzaCAoaGFzaEZuKSB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge0luZmluaXRlSGFzaCB8IFVpbnQ4QXJyYXl9IHZhbHVlXG4gICAqL1xuICBmdW5jdGlvbiBoYXNoaW5nICh2YWx1ZSkge1xuICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIEluZmluaXRlSGFzaCkge1xuICAgICAgLy8gYWxyZWFkeSBhIGhhc2guIHJldHVybiBpdFxuICAgICAgcmV0dXJuIHZhbHVlXG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBuZXcgSW5maW5pdGVIYXNoKHZhbHVlLCBoYXNoRm4pXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGhhc2hpbmdcbn1cblxuY2xhc3MgSW5maW5pdGVIYXNoIHtcbiAgLyoqXG4gICAqXG4gICAqIEBwYXJhbSB7VWludDhBcnJheX0gdmFsdWVcbiAgICogQHBhcmFtIHsodmFsdWU6IFVpbnQ4QXJyYXkpID0+IFByb21pc2U8VWludDhBcnJheT59IGhhc2hGblxuICAgKi9cbiAgY29uc3RydWN0b3IgKHZhbHVlLCBoYXNoRm4pIHtcbiAgICBpZiAoISh2YWx1ZSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2NhbiBvbmx5IGhhc2ggVWludDhBcnJheXMnKVxuICAgIH1cblxuICAgIHRoaXMuX3ZhbHVlID0gdmFsdWVcbiAgICB0aGlzLl9oYXNoRm4gPSBoYXNoRm5cbiAgICB0aGlzLl9kZXB0aCA9IC0xXG4gICAgdGhpcy5fYXZhaWxhYmxlQml0cyA9IDBcbiAgICB0aGlzLl9jdXJyZW50QnVmZmVySW5kZXggPSAwXG5cbiAgICAvKiogQHR5cGUge0NvbnN1bWFibGVCdWZmZXJbXX0gKi9cbiAgICB0aGlzLl9idWZmZXJzID0gW11cbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge251bWJlcn0gYml0c1xuICAgKi9cbiAgYXN5bmMgdGFrZSAoYml0cykge1xuICAgIGxldCBwZW5kaW5nQml0cyA9IGJpdHNcblxuICAgIHdoaWxlICh0aGlzLl9hdmFpbGFibGVCaXRzIDwgcGVuZGluZ0JpdHMpIHtcbiAgICAgIGF3YWl0IHRoaXMuX3Byb2R1Y2VNb3JlQml0cygpXG4gICAgfVxuXG4gICAgbGV0IHJlc3VsdCA9IDBcblxuICAgIHdoaWxlIChwZW5kaW5nQml0cyA+IDApIHtcbiAgICAgIGNvbnN0IGhhc2ggPSB0aGlzLl9idWZmZXJzW3RoaXMuX2N1cnJlbnRCdWZmZXJJbmRleF1cbiAgICAgIGNvbnN0IGF2YWlsYWJsZSA9IE1hdGgubWluKGhhc2guYXZhaWxhYmxlQml0cygpLCBwZW5kaW5nQml0cylcbiAgICAgIGNvbnN0IHRvb2sgPSBoYXNoLnRha2UoYXZhaWxhYmxlKVxuICAgICAgcmVzdWx0ID0gKHJlc3VsdCA8PCBhdmFpbGFibGUpICsgdG9va1xuICAgICAgcGVuZGluZ0JpdHMgLT0gYXZhaWxhYmxlXG4gICAgICB0aGlzLl9hdmFpbGFibGVCaXRzIC09IGF2YWlsYWJsZVxuXG4gICAgICBpZiAoaGFzaC5hdmFpbGFibGVCaXRzKCkgPT09IDApIHtcbiAgICAgICAgdGhpcy5fY3VycmVudEJ1ZmZlckluZGV4KytcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gcmVzdWx0XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtudW1iZXJ9IGJpdHNcbiAgICovXG4gIHVudGFrZSAoYml0cykge1xuICAgIGxldCBwZW5kaW5nQml0cyA9IGJpdHNcblxuICAgIHdoaWxlIChwZW5kaW5nQml0cyA+IDApIHtcbiAgICAgIGNvbnN0IGhhc2ggPSB0aGlzLl9idWZmZXJzW3RoaXMuX2N1cnJlbnRCdWZmZXJJbmRleF1cbiAgICAgIGNvbnN0IGF2YWlsYWJsZUZvclVudGFrZSA9IE1hdGgubWluKGhhc2gudG90YWxCaXRzKCkgLSBoYXNoLmF2YWlsYWJsZUJpdHMoKSwgcGVuZGluZ0JpdHMpXG4gICAgICBoYXNoLnVudGFrZShhdmFpbGFibGVGb3JVbnRha2UpXG4gICAgICBwZW5kaW5nQml0cyAtPSBhdmFpbGFibGVGb3JVbnRha2VcbiAgICAgIHRoaXMuX2F2YWlsYWJsZUJpdHMgKz0gYXZhaWxhYmxlRm9yVW50YWtlXG5cbiAgICAgIGlmICh0aGlzLl9jdXJyZW50QnVmZmVySW5kZXggPiAwICYmIGhhc2gudG90YWxCaXRzKCkgPT09IGhhc2guYXZhaWxhYmxlQml0cygpKSB7XG4gICAgICAgIHRoaXMuX2RlcHRoLS1cbiAgICAgICAgdGhpcy5fY3VycmVudEJ1ZmZlckluZGV4LS1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBhc3luYyBfcHJvZHVjZU1vcmVCaXRzICgpIHtcbiAgICB0aGlzLl9kZXB0aCsrXG5cbiAgICBjb25zdCB2YWx1ZSA9IHRoaXMuX2RlcHRoID8gdWludDhBcnJheUNvbmNhdChbdGhpcy5fdmFsdWUsIFVpbnQ4QXJyYXkuZnJvbShbdGhpcy5fZGVwdGhdKV0pIDogdGhpcy5fdmFsdWVcbiAgICBjb25zdCBoYXNoVmFsdWUgPSBhd2FpdCB0aGlzLl9oYXNoRm4odmFsdWUpXG4gICAgY29uc3QgYnVmZmVyID0gbmV3IENvbnN1bWFibGVCdWZmZXIoaGFzaFZhbHVlKVxuXG4gICAgdGhpcy5fYnVmZmVycy5wdXNoKGJ1ZmZlcilcbiAgICB0aGlzLl9hdmFpbGFibGVCaXRzICs9IGJ1ZmZlci5hdmFpbGFibGVCaXRzKClcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHdyYXBIYXNoXG5tb2R1bGUuZXhwb3J0cy5JbmZpbml0ZUhhc2ggPSBJbmZpbml0ZUhhc2hcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/hamt-sharding/src/consumable-hash.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/hamt-sharding/src/index.js":
/*!*************************************************!*\
  !*** ./node_modules/hamt-sharding/src/index.js ***!
  \*************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nconst Bucket = __webpack_require__(/*! ./bucket */ \"(rsc)/./node_modules/hamt-sharding/src/bucket.js\")\nconst wrapHash = __webpack_require__(/*! ./consumable-hash */ \"(rsc)/./node_modules/hamt-sharding/src/consumable-hash.js\")\n\n/**\n * @typedef {object} UserBucketOptions\n * @property {(value: Uint8Array) => Promise<Uint8Array>} hashFn\n * @property {number} [bits=8]\n */\n\n/**\n * @param {UserBucketOptions} options\n */\nfunction createHAMT (options) {\n  if (!options || !options.hashFn) {\n    throw new Error('please define an options.hashFn')\n  }\n\n  const bucketOptions = {\n    bits: options.bits || 8,\n    hash: wrapHash(options.hashFn)\n  }\n\n  return new Bucket(bucketOptions)\n}\n\nmodule.exports = {\n  createHAMT,\n  Bucket\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvaGFtdC1zaGFyZGluZy9zcmMvaW5kZXguanMiLCJtYXBwaW5ncyI6IkFBQVk7O0FBRVosZUFBZSxtQkFBTyxDQUFDLGtFQUFVO0FBQ2pDLGlCQUFpQixtQkFBTyxDQUFDLG9GQUFtQjs7QUFFNUM7QUFDQSxhQUFhLFFBQVE7QUFDckIsY0FBYyw0Q0FBNEM7QUFDMUQsY0FBYyxRQUFRO0FBQ3RCOztBQUVBO0FBQ0EsV0FBVyxtQkFBbUI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyIvaG9tZS9hbHRjb2luLWRhZGR5L0Rvd25sb2Fkcy9vd25seS9ub2RlX21vZHVsZXMvaGFtdC1zaGFyZGluZy9zcmMvaW5kZXguanMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IEJ1Y2tldCA9IHJlcXVpcmUoJy4vYnVja2V0JylcbmNvbnN0IHdyYXBIYXNoID0gcmVxdWlyZSgnLi9jb25zdW1hYmxlLWhhc2gnKVxuXG4vKipcbiAqIEB0eXBlZGVmIHtvYmplY3R9IFVzZXJCdWNrZXRPcHRpb25zXG4gKiBAcHJvcGVydHkgeyh2YWx1ZTogVWludDhBcnJheSkgPT4gUHJvbWlzZTxVaW50OEFycmF5Pn0gaGFzaEZuXG4gKiBAcHJvcGVydHkge251bWJlcn0gW2JpdHM9OF1cbiAqL1xuXG4vKipcbiAqIEBwYXJhbSB7VXNlckJ1Y2tldE9wdGlvbnN9IG9wdGlvbnNcbiAqL1xuZnVuY3Rpb24gY3JlYXRlSEFNVCAob3B0aW9ucykge1xuICBpZiAoIW9wdGlvbnMgfHwgIW9wdGlvbnMuaGFzaEZuKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdwbGVhc2UgZGVmaW5lIGFuIG9wdGlvbnMuaGFzaEZuJylcbiAgfVxuXG4gIGNvbnN0IGJ1Y2tldE9wdGlvbnMgPSB7XG4gICAgYml0czogb3B0aW9ucy5iaXRzIHx8IDgsXG4gICAgaGFzaDogd3JhcEhhc2gob3B0aW9ucy5oYXNoRm4pXG4gIH1cblxuICByZXR1cm4gbmV3IEJ1Y2tldChidWNrZXRPcHRpb25zKVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgY3JlYXRlSEFNVCxcbiAgQnVja2V0XG59XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/hamt-sharding/src/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/hamt-sharding/src/bucket.js":
/*!**************************************************!*\
  !*** ./node_modules/hamt-sharding/src/bucket.js ***!
  \**************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\n// @ts-ignore\nconst SparseArray = __webpack_require__(/*! sparse-array */ \"(ssr)/./node_modules/sparse-array/index.js\")\nconst { fromString: uint8ArrayFromString } = __webpack_require__(/*! uint8arrays/from-string */ \"(ssr)/./node_modules/uint8arrays/cjs/src/from-string.js\")\n\n/**\n * @typedef {import('./consumable-hash').InfiniteHash} InfiniteHash\n * @typedef {import('../').UserBucketOptions} UserBucketOptions\n */\n\n/**\n * @template V\n * @typedef {object} BucketChild<V>\n * @property {string} key\n * @property {V} value\n * @property {InfiniteHash} hash\n */\n\n/**\n * @template B\n *\n * @typedef {object} SA<B>\n * @property {number} length\n * @property {() => B[]} compactArray\n * @property {(i: number) => B} get\n * @property {(i: number, value: B) => void} set\n * @property {<A> (fn: (acc: A, curr: B, index: number) => A, initial: A) => B} reduce\n * @property {(fn: (item: B) => boolean) => B | undefined} find\n * @property {() => number[]} bitField\n * @property {(i: number) => void} unset\n */\n\n/**\n * @template T\n *\n * @typedef {object} BucketPosition<T>\n * @property {Bucket<T>} bucket\n * @property {number} pos\n * @property {InfiniteHash} hash\n * @property {BucketChild<T>} [existingChild]\n */\n\n/**\n * @typedef {object} BucketOptions\n * @property {number} bits\n * @property {(value: Uint8Array | InfiniteHash) => InfiniteHash} hash\n */\n\n/**\n * @template T\n */\nclass Bucket {\n  /**\n   * @param {BucketOptions} options\n   * @param {Bucket<T>} [parent]\n   * @param {number} [posAtParent=0]\n   */\n  constructor (options, parent, posAtParent = 0) {\n    this._options = options\n    this._popCount = 0\n    this._parent = parent\n    this._posAtParent = posAtParent\n\n    /** @type {SA<Bucket<T> | BucketChild<T>>} */\n    this._children = new SparseArray()\n\n    /** @type {string | null} */\n    this.key = null\n  }\n\n  /**\n   * @param {string} key\n   * @param {T} value\n   */\n  async put (key, value) {\n    const place = await this._findNewBucketAndPos(key)\n\n    await place.bucket._putAt(place, key, value)\n  }\n\n  /**\n   * @param {string} key\n   */\n  async get (key) {\n    const child = await this._findChild(key)\n\n    if (child) {\n      return child.value\n    }\n  }\n\n  /**\n   * @param {string} key\n   */\n  async del (key) {\n    const place = await this._findPlace(key)\n    const child = place.bucket._at(place.pos)\n\n    if (child && child.key === key) {\n      place.bucket._delAt(place.pos)\n    }\n  }\n\n  /**\n   * @returns {number}\n   */\n  leafCount () {\n    const children = this._children.compactArray()\n\n    return children.reduce((acc, child) => {\n      if (child instanceof Bucket) {\n        return acc + child.leafCount()\n      }\n\n      return acc + 1\n    }, 0)\n  }\n\n  childrenCount () {\n    return this._children.length\n  }\n\n  onlyChild () {\n    return this._children.get(0)\n  }\n\n  /**\n   * @returns {Iterable<BucketChild<T>>}\n   */\n  * eachLeafSeries () {\n    const children = this._children.compactArray()\n\n    for (const child of children) {\n      if (child instanceof Bucket) {\n        yield * child.eachLeafSeries()\n      } else {\n        yield child\n      }\n    }\n\n    // this is necessary because tsc requires a @return annotation as it\n    // can't derive a return type due to the recursion, and eslint requires\n    // a return statement when there is a @return annotation\n    return []\n  }\n\n  /**\n   * @param {(value: BucketChild<T>, index: number) => T} map\n   * @param {(reduced: any) => any} reduce\n   */\n  serialize (map, reduce) {\n    /** @type {T[]} */\n    const acc = []\n    // serialize to a custom non-sparse representation\n    return reduce(this._children.reduce((acc, child, index) => {\n      if (child) {\n        if (child instanceof Bucket) {\n          acc.push(child.serialize(map, reduce))\n        } else {\n          acc.push(map(child, index))\n        }\n      }\n      return acc\n    }, acc))\n  }\n\n  /**\n   * @param {(value: BucketChild<T>) => Promise<T[]>} asyncMap\n   * @param {(reduced: any) => Promise<any>} asyncReduce\n   */\n  asyncTransform (asyncMap, asyncReduce) {\n    return asyncTransformBucket(this, asyncMap, asyncReduce)\n  }\n\n  toJSON () {\n    return this.serialize(mapNode, reduceNodes)\n  }\n\n  prettyPrint () {\n    return JSON.stringify(this.toJSON(), null, '  ')\n  }\n\n  tableSize () {\n    return Math.pow(2, this._options.bits)\n  }\n\n  /**\n   * @param {string} key\n   * @returns {Promise<BucketChild<T> | undefined>}\n   */\n  async _findChild (key) {\n    const result = await this._findPlace(key)\n    const child = result.bucket._at(result.pos)\n\n    if (child instanceof Bucket) {\n      // should not be possible, this._findPlace should always\n      // return a location for a child, not a bucket\n      return undefined\n    }\n\n    if (child && child.key === key) {\n      return child\n    }\n  }\n\n  /**\n   * @param {string | InfiniteHash} key\n   * @returns {Promise<BucketPosition<T>>}\n   */\n  async _findPlace (key) {\n    const hashValue = this._options.hash(typeof key === 'string' ? uint8ArrayFromString(key) : key)\n    const index = await hashValue.take(this._options.bits)\n\n    const child = this._children.get(index)\n\n    if (child instanceof Bucket) {\n      return child._findPlace(hashValue)\n    }\n\n    return {\n      bucket: this,\n      pos: index,\n      hash: hashValue,\n      existingChild: child\n    }\n  }\n\n  /**\n   * @param {string | InfiniteHash} key\n   * @returns {Promise<BucketPosition<T>>}\n   */\n  async _findNewBucketAndPos (key) {\n    const place = await this._findPlace(key)\n\n    if (place.existingChild && place.existingChild.key !== key) {\n      // conflict\n      const bucket = new Bucket(this._options, place.bucket, place.pos)\n      place.bucket._putObjectAt(place.pos, bucket)\n\n      // put the previous value\n      const newPlace = await bucket._findPlace(place.existingChild.hash)\n      newPlace.bucket._putAt(newPlace, place.existingChild.key, place.existingChild.value)\n\n      return bucket._findNewBucketAndPos(place.hash)\n    }\n\n    // no conflict, we found the place\n    return place\n  }\n\n  /**\n   * @param {BucketPosition<T>} place\n   * @param {string} key\n   * @param {T} value\n   */\n  _putAt (place, key, value) {\n    this._putObjectAt(place.pos, {\n      key: key,\n      value: value,\n      hash: place.hash\n    })\n  }\n\n  /**\n   * @param {number} pos\n   * @param {Bucket<T> | BucketChild<T>} object\n   */\n  _putObjectAt (pos, object) {\n    if (!this._children.get(pos)) {\n      this._popCount++\n    }\n    this._children.set(pos, object)\n  }\n\n  /**\n   * @param {number} pos\n   */\n  _delAt (pos) {\n    if (pos === -1) {\n      throw new Error('Invalid position')\n    }\n\n    if (this._children.get(pos)) {\n      this._popCount--\n    }\n    this._children.unset(pos)\n    this._level()\n  }\n\n  _level () {\n    if (this._parent && this._popCount <= 1) {\n      if (this._popCount === 1) {\n        // remove myself from parent, replacing me with my only child\n        const onlyChild = this._children.find(exists)\n\n        if (onlyChild && !(onlyChild instanceof Bucket)) {\n          const hash = onlyChild.hash\n          hash.untake(this._options.bits)\n          const place = {\n            pos: this._posAtParent,\n            hash: hash,\n            bucket: this._parent\n          }\n          this._parent._putAt(place, onlyChild.key, onlyChild.value)\n        }\n      } else {\n        this._parent._delAt(this._posAtParent)\n      }\n    }\n  }\n\n  /**\n   * @param {number} index\n   * @returns {BucketChild<T> | Bucket<T> | undefined}\n   */\n  _at (index) {\n    return this._children.get(index)\n  }\n}\n\n/**\n * @param {any} o\n */\nfunction exists (o) {\n  return Boolean(o)\n}\n\n/**\n *\n * @param {*} node\n * @param {number} index\n */\nfunction mapNode (node, index) {\n  return node.key\n}\n\n/**\n * @param {*} nodes\n */\nfunction reduceNodes (nodes) {\n  return nodes\n}\n\n/**\n * @template T\n *\n * @param {Bucket<T>} bucket\n * @param {(value: BucketChild<T>) => Promise<T[]>} asyncMap\n * @param {(reduced: any) => Promise<any>} asyncReduce\n */\nasync function asyncTransformBucket (bucket, asyncMap, asyncReduce) {\n  const output = []\n\n  for (const child of bucket._children.compactArray()) {\n    if (child instanceof Bucket) {\n      await asyncTransformBucket(child, asyncMap, asyncReduce)\n    } else {\n      const mappedChildren = await asyncMap(child)\n\n      output.push({\n        bitField: bucket._children.bitField(),\n        children: mappedChildren\n      })\n    }\n  }\n\n  return asyncReduce(output)\n}\n\nmodule.exports = Bucket\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvaGFtdC1zaGFyZGluZy9zcmMvYnVja2V0LmpzIiwibWFwcGluZ3MiOiJBQUFZOztBQUVaO0FBQ0Esb0JBQW9CLG1CQUFPLENBQUMsZ0VBQWM7QUFDMUMsUUFBUSxtQ0FBbUMsRUFBRSxtQkFBTyxDQUFDLHdGQUF5Qjs7QUFFOUU7QUFDQSxhQUFhLDBDQUEwQztBQUN2RCxhQUFhLGlDQUFpQztBQUM5Qzs7QUFFQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGNBQWMsUUFBUTtBQUN0QixjQUFjLEdBQUc7QUFDakIsY0FBYyxjQUFjO0FBQzVCOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixjQUFjLFFBQVE7QUFDdEIsY0FBYyxXQUFXO0FBQ3pCLGNBQWMsa0JBQWtCO0FBQ2hDLGNBQWMsK0JBQStCO0FBQzdDLGNBQWMsa0VBQWtFO0FBQ2hGLGNBQWMsNkNBQTZDO0FBQzNELGNBQWMsZ0JBQWdCO0FBQzlCLGNBQWMscUJBQXFCO0FBQ25DOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixjQUFjLFdBQVc7QUFDekIsY0FBYyxRQUFRO0FBQ3RCLGNBQWMsY0FBYztBQUM1QixjQUFjLGdCQUFnQjtBQUM5Qjs7QUFFQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixjQUFjLFFBQVE7QUFDdEIsY0FBYyxvREFBb0Q7QUFDbEU7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsZUFBZTtBQUM1QixhQUFhLFdBQVc7QUFDeEIsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxlQUFlLGdDQUFnQztBQUMvQzs7QUFFQSxlQUFlLGVBQWU7QUFDOUI7QUFDQTs7QUFFQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixhQUFhLEdBQUc7QUFDaEI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxhQUFhLDZDQUE2QztBQUMxRCxhQUFhLHVCQUF1QjtBQUNwQztBQUNBO0FBQ0EsZUFBZSxLQUFLO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBLGFBQWEseUNBQXlDO0FBQ3RELGFBQWEsZ0NBQWdDO0FBQzdDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsYUFBYSx1QkFBdUI7QUFDcEMsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGFBQWEsdUJBQXVCO0FBQ3BDLGVBQWU7QUFDZjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsYUFBYSxtQkFBbUI7QUFDaEMsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsR0FBRztBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQSxhQUFhLFFBQVE7QUFDckIsYUFBYSw0QkFBNEI7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFdBQVcsS0FBSztBQUNoQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxHQUFHO0FBQ2QsV0FBVyxRQUFRO0FBQ25CO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsV0FBVyxHQUFHO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxXQUFXO0FBQ3RCLFdBQVcseUNBQXlDO0FBQ3BELFdBQVcsZ0NBQWdDO0FBQzNDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSIsInNvdXJjZXMiOlsiL2hvbWUvYWx0Y29pbi1kYWRkeS9Eb3dubG9hZHMvb3dubHkvbm9kZV9tb2R1bGVzL2hhbXQtc2hhcmRpbmcvc3JjL2J1Y2tldC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCdcblxuLy8gQHRzLWlnbm9yZVxuY29uc3QgU3BhcnNlQXJyYXkgPSByZXF1aXJlKCdzcGFyc2UtYXJyYXknKVxuY29uc3QgeyBmcm9tU3RyaW5nOiB1aW50OEFycmF5RnJvbVN0cmluZyB9ID0gcmVxdWlyZSgndWludDhhcnJheXMvZnJvbS1zdHJpbmcnKVxuXG4vKipcbiAqIEB0eXBlZGVmIHtpbXBvcnQoJy4vY29uc3VtYWJsZS1oYXNoJykuSW5maW5pdGVIYXNofSBJbmZpbml0ZUhhc2hcbiAqIEB0eXBlZGVmIHtpbXBvcnQoJy4uLycpLlVzZXJCdWNrZXRPcHRpb25zfSBVc2VyQnVja2V0T3B0aW9uc1xuICovXG5cbi8qKlxuICogQHRlbXBsYXRlIFZcbiAqIEB0eXBlZGVmIHtvYmplY3R9IEJ1Y2tldENoaWxkPFY+XG4gKiBAcHJvcGVydHkge3N0cmluZ30ga2V5XG4gKiBAcHJvcGVydHkge1Z9IHZhbHVlXG4gKiBAcHJvcGVydHkge0luZmluaXRlSGFzaH0gaGFzaFxuICovXG5cbi8qKlxuICogQHRlbXBsYXRlIEJcbiAqXG4gKiBAdHlwZWRlZiB7b2JqZWN0fSBTQTxCPlxuICogQHByb3BlcnR5IHtudW1iZXJ9IGxlbmd0aFxuICogQHByb3BlcnR5IHsoKSA9PiBCW119IGNvbXBhY3RBcnJheVxuICogQHByb3BlcnR5IHsoaTogbnVtYmVyKSA9PiBCfSBnZXRcbiAqIEBwcm9wZXJ0eSB7KGk6IG51bWJlciwgdmFsdWU6IEIpID0+IHZvaWR9IHNldFxuICogQHByb3BlcnR5IHs8QT4gKGZuOiAoYWNjOiBBLCBjdXJyOiBCLCBpbmRleDogbnVtYmVyKSA9PiBBLCBpbml0aWFsOiBBKSA9PiBCfSByZWR1Y2VcbiAqIEBwcm9wZXJ0eSB7KGZuOiAoaXRlbTogQikgPT4gYm9vbGVhbikgPT4gQiB8IHVuZGVmaW5lZH0gZmluZFxuICogQHByb3BlcnR5IHsoKSA9PiBudW1iZXJbXX0gYml0RmllbGRcbiAqIEBwcm9wZXJ0eSB7KGk6IG51bWJlcikgPT4gdm9pZH0gdW5zZXRcbiAqL1xuXG4vKipcbiAqIEB0ZW1wbGF0ZSBUXG4gKlxuICogQHR5cGVkZWYge29iamVjdH0gQnVja2V0UG9zaXRpb248VD5cbiAqIEBwcm9wZXJ0eSB7QnVja2V0PFQ+fSBidWNrZXRcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBwb3NcbiAqIEBwcm9wZXJ0eSB7SW5maW5pdGVIYXNofSBoYXNoXG4gKiBAcHJvcGVydHkge0J1Y2tldENoaWxkPFQ+fSBbZXhpc3RpbmdDaGlsZF1cbiAqL1xuXG4vKipcbiAqIEB0eXBlZGVmIHtvYmplY3R9IEJ1Y2tldE9wdGlvbnNcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBiaXRzXG4gKiBAcHJvcGVydHkgeyh2YWx1ZTogVWludDhBcnJheSB8IEluZmluaXRlSGFzaCkgPT4gSW5maW5pdGVIYXNofSBoYXNoXG4gKi9cblxuLyoqXG4gKiBAdGVtcGxhdGUgVFxuICovXG5jbGFzcyBCdWNrZXQge1xuICAvKipcbiAgICogQHBhcmFtIHtCdWNrZXRPcHRpb25zfSBvcHRpb25zXG4gICAqIEBwYXJhbSB7QnVja2V0PFQ+fSBbcGFyZW50XVxuICAgKiBAcGFyYW0ge251bWJlcn0gW3Bvc0F0UGFyZW50PTBdXG4gICAqL1xuICBjb25zdHJ1Y3RvciAob3B0aW9ucywgcGFyZW50LCBwb3NBdFBhcmVudCA9IDApIHtcbiAgICB0aGlzLl9vcHRpb25zID0gb3B0aW9uc1xuICAgIHRoaXMuX3BvcENvdW50ID0gMFxuICAgIHRoaXMuX3BhcmVudCA9IHBhcmVudFxuICAgIHRoaXMuX3Bvc0F0UGFyZW50ID0gcG9zQXRQYXJlbnRcblxuICAgIC8qKiBAdHlwZSB7U0E8QnVja2V0PFQ+IHwgQnVja2V0Q2hpbGQ8VD4+fSAqL1xuICAgIHRoaXMuX2NoaWxkcmVuID0gbmV3IFNwYXJzZUFycmF5KClcblxuICAgIC8qKiBAdHlwZSB7c3RyaW5nIHwgbnVsbH0gKi9cbiAgICB0aGlzLmtleSA9IG51bGxcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5XG4gICAqIEBwYXJhbSB7VH0gdmFsdWVcbiAgICovXG4gIGFzeW5jIHB1dCAoa2V5LCB2YWx1ZSkge1xuICAgIGNvbnN0IHBsYWNlID0gYXdhaXQgdGhpcy5fZmluZE5ld0J1Y2tldEFuZFBvcyhrZXkpXG5cbiAgICBhd2FpdCBwbGFjZS5idWNrZXQuX3B1dEF0KHBsYWNlLCBrZXksIHZhbHVlKVxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBrZXlcbiAgICovXG4gIGFzeW5jIGdldCAoa2V5KSB7XG4gICAgY29uc3QgY2hpbGQgPSBhd2FpdCB0aGlzLl9maW5kQ2hpbGQoa2V5KVxuXG4gICAgaWYgKGNoaWxkKSB7XG4gICAgICByZXR1cm4gY2hpbGQudmFsdWVcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtzdHJpbmd9IGtleVxuICAgKi9cbiAgYXN5bmMgZGVsIChrZXkpIHtcbiAgICBjb25zdCBwbGFjZSA9IGF3YWl0IHRoaXMuX2ZpbmRQbGFjZShrZXkpXG4gICAgY29uc3QgY2hpbGQgPSBwbGFjZS5idWNrZXQuX2F0KHBsYWNlLnBvcylcblxuICAgIGlmIChjaGlsZCAmJiBjaGlsZC5rZXkgPT09IGtleSkge1xuICAgICAgcGxhY2UuYnVja2V0Ll9kZWxBdChwbGFjZS5wb3MpXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm5zIHtudW1iZXJ9XG4gICAqL1xuICBsZWFmQ291bnQgKCkge1xuICAgIGNvbnN0IGNoaWxkcmVuID0gdGhpcy5fY2hpbGRyZW4uY29tcGFjdEFycmF5KClcblxuICAgIHJldHVybiBjaGlsZHJlbi5yZWR1Y2UoKGFjYywgY2hpbGQpID0+IHtcbiAgICAgIGlmIChjaGlsZCBpbnN0YW5jZW9mIEJ1Y2tldCkge1xuICAgICAgICByZXR1cm4gYWNjICsgY2hpbGQubGVhZkNvdW50KClcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGFjYyArIDFcbiAgICB9LCAwKVxuICB9XG5cbiAgY2hpbGRyZW5Db3VudCAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2NoaWxkcmVuLmxlbmd0aFxuICB9XG5cbiAgb25seUNoaWxkICgpIHtcbiAgICByZXR1cm4gdGhpcy5fY2hpbGRyZW4uZ2V0KDApXG4gIH1cblxuICAvKipcbiAgICogQHJldHVybnMge0l0ZXJhYmxlPEJ1Y2tldENoaWxkPFQ+Pn1cbiAgICovXG4gICogZWFjaExlYWZTZXJpZXMgKCkge1xuICAgIGNvbnN0IGNoaWxkcmVuID0gdGhpcy5fY2hpbGRyZW4uY29tcGFjdEFycmF5KClcblxuICAgIGZvciAoY29uc3QgY2hpbGQgb2YgY2hpbGRyZW4pIHtcbiAgICAgIGlmIChjaGlsZCBpbnN0YW5jZW9mIEJ1Y2tldCkge1xuICAgICAgICB5aWVsZCAqIGNoaWxkLmVhY2hMZWFmU2VyaWVzKClcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHlpZWxkIGNoaWxkXG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gdGhpcyBpcyBuZWNlc3NhcnkgYmVjYXVzZSB0c2MgcmVxdWlyZXMgYSBAcmV0dXJuIGFubm90YXRpb24gYXMgaXRcbiAgICAvLyBjYW4ndCBkZXJpdmUgYSByZXR1cm4gdHlwZSBkdWUgdG8gdGhlIHJlY3Vyc2lvbiwgYW5kIGVzbGludCByZXF1aXJlc1xuICAgIC8vIGEgcmV0dXJuIHN0YXRlbWVudCB3aGVuIHRoZXJlIGlzIGEgQHJldHVybiBhbm5vdGF0aW9uXG4gICAgcmV0dXJuIFtdXG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHsodmFsdWU6IEJ1Y2tldENoaWxkPFQ+LCBpbmRleDogbnVtYmVyKSA9PiBUfSBtYXBcbiAgICogQHBhcmFtIHsocmVkdWNlZDogYW55KSA9PiBhbnl9IHJlZHVjZVxuICAgKi9cbiAgc2VyaWFsaXplIChtYXAsIHJlZHVjZSkge1xuICAgIC8qKiBAdHlwZSB7VFtdfSAqL1xuICAgIGNvbnN0IGFjYyA9IFtdXG4gICAgLy8gc2VyaWFsaXplIHRvIGEgY3VzdG9tIG5vbi1zcGFyc2UgcmVwcmVzZW50YXRpb25cbiAgICByZXR1cm4gcmVkdWNlKHRoaXMuX2NoaWxkcmVuLnJlZHVjZSgoYWNjLCBjaGlsZCwgaW5kZXgpID0+IHtcbiAgICAgIGlmIChjaGlsZCkge1xuICAgICAgICBpZiAoY2hpbGQgaW5zdGFuY2VvZiBCdWNrZXQpIHtcbiAgICAgICAgICBhY2MucHVzaChjaGlsZC5zZXJpYWxpemUobWFwLCByZWR1Y2UpKVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGFjYy5wdXNoKG1hcChjaGlsZCwgaW5kZXgpKVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gYWNjXG4gICAgfSwgYWNjKSlcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0geyh2YWx1ZTogQnVja2V0Q2hpbGQ8VD4pID0+IFByb21pc2U8VFtdPn0gYXN5bmNNYXBcbiAgICogQHBhcmFtIHsocmVkdWNlZDogYW55KSA9PiBQcm9taXNlPGFueT59IGFzeW5jUmVkdWNlXG4gICAqL1xuICBhc3luY1RyYW5zZm9ybSAoYXN5bmNNYXAsIGFzeW5jUmVkdWNlKSB7XG4gICAgcmV0dXJuIGFzeW5jVHJhbnNmb3JtQnVja2V0KHRoaXMsIGFzeW5jTWFwLCBhc3luY1JlZHVjZSlcbiAgfVxuXG4gIHRvSlNPTiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuc2VyaWFsaXplKG1hcE5vZGUsIHJlZHVjZU5vZGVzKVxuICB9XG5cbiAgcHJldHR5UHJpbnQgKCkge1xuICAgIHJldHVybiBKU09OLnN0cmluZ2lmeSh0aGlzLnRvSlNPTigpLCBudWxsLCAnICAnKVxuICB9XG5cbiAgdGFibGVTaXplICgpIHtcbiAgICByZXR1cm4gTWF0aC5wb3coMiwgdGhpcy5fb3B0aW9ucy5iaXRzKVxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBrZXlcbiAgICogQHJldHVybnMge1Byb21pc2U8QnVja2V0Q2hpbGQ8VD4gfCB1bmRlZmluZWQ+fVxuICAgKi9cbiAgYXN5bmMgX2ZpbmRDaGlsZCAoa2V5KSB7XG4gICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgdGhpcy5fZmluZFBsYWNlKGtleSlcbiAgICBjb25zdCBjaGlsZCA9IHJlc3VsdC5idWNrZXQuX2F0KHJlc3VsdC5wb3MpXG5cbiAgICBpZiAoY2hpbGQgaW5zdGFuY2VvZiBCdWNrZXQpIHtcbiAgICAgIC8vIHNob3VsZCBub3QgYmUgcG9zc2libGUsIHRoaXMuX2ZpbmRQbGFjZSBzaG91bGQgYWx3YXlzXG4gICAgICAvLyByZXR1cm4gYSBsb2NhdGlvbiBmb3IgYSBjaGlsZCwgbm90IGEgYnVja2V0XG4gICAgICByZXR1cm4gdW5kZWZpbmVkXG4gICAgfVxuXG4gICAgaWYgKGNoaWxkICYmIGNoaWxkLmtleSA9PT0ga2V5KSB7XG4gICAgICByZXR1cm4gY2hpbGRcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtzdHJpbmcgfCBJbmZpbml0ZUhhc2h9IGtleVxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxCdWNrZXRQb3NpdGlvbjxUPj59XG4gICAqL1xuICBhc3luYyBfZmluZFBsYWNlIChrZXkpIHtcbiAgICBjb25zdCBoYXNoVmFsdWUgPSB0aGlzLl9vcHRpb25zLmhhc2godHlwZW9mIGtleSA9PT0gJ3N0cmluZycgPyB1aW50OEFycmF5RnJvbVN0cmluZyhrZXkpIDoga2V5KVxuICAgIGNvbnN0IGluZGV4ID0gYXdhaXQgaGFzaFZhbHVlLnRha2UodGhpcy5fb3B0aW9ucy5iaXRzKVxuXG4gICAgY29uc3QgY2hpbGQgPSB0aGlzLl9jaGlsZHJlbi5nZXQoaW5kZXgpXG5cbiAgICBpZiAoY2hpbGQgaW5zdGFuY2VvZiBCdWNrZXQpIHtcbiAgICAgIHJldHVybiBjaGlsZC5fZmluZFBsYWNlKGhhc2hWYWx1ZSlcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgYnVja2V0OiB0aGlzLFxuICAgICAgcG9zOiBpbmRleCxcbiAgICAgIGhhc2g6IGhhc2hWYWx1ZSxcbiAgICAgIGV4aXN0aW5nQ2hpbGQ6IGNoaWxkXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7c3RyaW5nIHwgSW5maW5pdGVIYXNofSBrZXlcbiAgICogQHJldHVybnMge1Byb21pc2U8QnVja2V0UG9zaXRpb248VD4+fVxuICAgKi9cbiAgYXN5bmMgX2ZpbmROZXdCdWNrZXRBbmRQb3MgKGtleSkge1xuICAgIGNvbnN0IHBsYWNlID0gYXdhaXQgdGhpcy5fZmluZFBsYWNlKGtleSlcblxuICAgIGlmIChwbGFjZS5leGlzdGluZ0NoaWxkICYmIHBsYWNlLmV4aXN0aW5nQ2hpbGQua2V5ICE9PSBrZXkpIHtcbiAgICAgIC8vIGNvbmZsaWN0XG4gICAgICBjb25zdCBidWNrZXQgPSBuZXcgQnVja2V0KHRoaXMuX29wdGlvbnMsIHBsYWNlLmJ1Y2tldCwgcGxhY2UucG9zKVxuICAgICAgcGxhY2UuYnVja2V0Ll9wdXRPYmplY3RBdChwbGFjZS5wb3MsIGJ1Y2tldClcblxuICAgICAgLy8gcHV0IHRoZSBwcmV2aW91cyB2YWx1ZVxuICAgICAgY29uc3QgbmV3UGxhY2UgPSBhd2FpdCBidWNrZXQuX2ZpbmRQbGFjZShwbGFjZS5leGlzdGluZ0NoaWxkLmhhc2gpXG4gICAgICBuZXdQbGFjZS5idWNrZXQuX3B1dEF0KG5ld1BsYWNlLCBwbGFjZS5leGlzdGluZ0NoaWxkLmtleSwgcGxhY2UuZXhpc3RpbmdDaGlsZC52YWx1ZSlcblxuICAgICAgcmV0dXJuIGJ1Y2tldC5fZmluZE5ld0J1Y2tldEFuZFBvcyhwbGFjZS5oYXNoKVxuICAgIH1cblxuICAgIC8vIG5vIGNvbmZsaWN0LCB3ZSBmb3VuZCB0aGUgcGxhY2VcbiAgICByZXR1cm4gcGxhY2VcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge0J1Y2tldFBvc2l0aW9uPFQ+fSBwbGFjZVxuICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5XG4gICAqIEBwYXJhbSB7VH0gdmFsdWVcbiAgICovXG4gIF9wdXRBdCAocGxhY2UsIGtleSwgdmFsdWUpIHtcbiAgICB0aGlzLl9wdXRPYmplY3RBdChwbGFjZS5wb3MsIHtcbiAgICAgIGtleToga2V5LFxuICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgaGFzaDogcGxhY2UuaGFzaFxuICAgIH0pXG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtudW1iZXJ9IHBvc1xuICAgKiBAcGFyYW0ge0J1Y2tldDxUPiB8IEJ1Y2tldENoaWxkPFQ+fSBvYmplY3RcbiAgICovXG4gIF9wdXRPYmplY3RBdCAocG9zLCBvYmplY3QpIHtcbiAgICBpZiAoIXRoaXMuX2NoaWxkcmVuLmdldChwb3MpKSB7XG4gICAgICB0aGlzLl9wb3BDb3VudCsrXG4gICAgfVxuICAgIHRoaXMuX2NoaWxkcmVuLnNldChwb3MsIG9iamVjdClcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge251bWJlcn0gcG9zXG4gICAqL1xuICBfZGVsQXQgKHBvcykge1xuICAgIGlmIChwb3MgPT09IC0xKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgcG9zaXRpb24nKVxuICAgIH1cblxuICAgIGlmICh0aGlzLl9jaGlsZHJlbi5nZXQocG9zKSkge1xuICAgICAgdGhpcy5fcG9wQ291bnQtLVxuICAgIH1cbiAgICB0aGlzLl9jaGlsZHJlbi51bnNldChwb3MpXG4gICAgdGhpcy5fbGV2ZWwoKVxuICB9XG5cbiAgX2xldmVsICgpIHtcbiAgICBpZiAodGhpcy5fcGFyZW50ICYmIHRoaXMuX3BvcENvdW50IDw9IDEpIHtcbiAgICAgIGlmICh0aGlzLl9wb3BDb3VudCA9PT0gMSkge1xuICAgICAgICAvLyByZW1vdmUgbXlzZWxmIGZyb20gcGFyZW50LCByZXBsYWNpbmcgbWUgd2l0aCBteSBvbmx5IGNoaWxkXG4gICAgICAgIGNvbnN0IG9ubHlDaGlsZCA9IHRoaXMuX2NoaWxkcmVuLmZpbmQoZXhpc3RzKVxuXG4gICAgICAgIGlmIChvbmx5Q2hpbGQgJiYgIShvbmx5Q2hpbGQgaW5zdGFuY2VvZiBCdWNrZXQpKSB7XG4gICAgICAgICAgY29uc3QgaGFzaCA9IG9ubHlDaGlsZC5oYXNoXG4gICAgICAgICAgaGFzaC51bnRha2UodGhpcy5fb3B0aW9ucy5iaXRzKVxuICAgICAgICAgIGNvbnN0IHBsYWNlID0ge1xuICAgICAgICAgICAgcG9zOiB0aGlzLl9wb3NBdFBhcmVudCxcbiAgICAgICAgICAgIGhhc2g6IGhhc2gsXG4gICAgICAgICAgICBidWNrZXQ6IHRoaXMuX3BhcmVudFxuICAgICAgICAgIH1cbiAgICAgICAgICB0aGlzLl9wYXJlbnQuX3B1dEF0KHBsYWNlLCBvbmx5Q2hpbGQua2V5LCBvbmx5Q2hpbGQudmFsdWUpXG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuX3BhcmVudC5fZGVsQXQodGhpcy5fcG9zQXRQYXJlbnQpXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleFxuICAgKiBAcmV0dXJucyB7QnVja2V0Q2hpbGQ8VD4gfCBCdWNrZXQ8VD4gfCB1bmRlZmluZWR9XG4gICAqL1xuICBfYXQgKGluZGV4KSB7XG4gICAgcmV0dXJuIHRoaXMuX2NoaWxkcmVuLmdldChpbmRleClcbiAgfVxufVxuXG4vKipcbiAqIEBwYXJhbSB7YW55fSBvXG4gKi9cbmZ1bmN0aW9uIGV4aXN0cyAobykge1xuICByZXR1cm4gQm9vbGVhbihvKVxufVxuXG4vKipcbiAqXG4gKiBAcGFyYW0geyp9IG5vZGVcbiAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleFxuICovXG5mdW5jdGlvbiBtYXBOb2RlIChub2RlLCBpbmRleCkge1xuICByZXR1cm4gbm9kZS5rZXlcbn1cblxuLyoqXG4gKiBAcGFyYW0geyp9IG5vZGVzXG4gKi9cbmZ1bmN0aW9uIHJlZHVjZU5vZGVzIChub2Rlcykge1xuICByZXR1cm4gbm9kZXNcbn1cblxuLyoqXG4gKiBAdGVtcGxhdGUgVFxuICpcbiAqIEBwYXJhbSB7QnVja2V0PFQ+fSBidWNrZXRcbiAqIEBwYXJhbSB7KHZhbHVlOiBCdWNrZXRDaGlsZDxUPikgPT4gUHJvbWlzZTxUW10+fSBhc3luY01hcFxuICogQHBhcmFtIHsocmVkdWNlZDogYW55KSA9PiBQcm9taXNlPGFueT59IGFzeW5jUmVkdWNlXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIGFzeW5jVHJhbnNmb3JtQnVja2V0IChidWNrZXQsIGFzeW5jTWFwLCBhc3luY1JlZHVjZSkge1xuICBjb25zdCBvdXRwdXQgPSBbXVxuXG4gIGZvciAoY29uc3QgY2hpbGQgb2YgYnVja2V0Ll9jaGlsZHJlbi5jb21wYWN0QXJyYXkoKSkge1xuICAgIGlmIChjaGlsZCBpbnN0YW5jZW9mIEJ1Y2tldCkge1xuICAgICAgYXdhaXQgYXN5bmNUcmFuc2Zvcm1CdWNrZXQoY2hpbGQsIGFzeW5jTWFwLCBhc3luY1JlZHVjZSlcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgbWFwcGVkQ2hpbGRyZW4gPSBhd2FpdCBhc3luY01hcChjaGlsZClcblxuICAgICAgb3V0cHV0LnB1c2goe1xuICAgICAgICBiaXRGaWVsZDogYnVja2V0Ll9jaGlsZHJlbi5iaXRGaWVsZCgpLFxuICAgICAgICBjaGlsZHJlbjogbWFwcGVkQ2hpbGRyZW5cbiAgICAgIH0pXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGFzeW5jUmVkdWNlKG91dHB1dClcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBCdWNrZXRcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/hamt-sharding/src/bucket.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/hamt-sharding/src/consumable-buffer.js":
/*!*************************************************************!*\
  !*** ./node_modules/hamt-sharding/src/consumable-buffer.js ***!
  \*************************************************************/
/***/ ((module) => {

eval("\n\nconst START_MASKS = [\n  0b11111111,\n  0b11111110,\n  0b11111100,\n  0b11111000,\n  0b11110000,\n  0b11100000,\n  0b11000000,\n  0b10000000\n]\n\nconst STOP_MASKS = [\n  0b00000001,\n  0b00000011,\n  0b00000111,\n  0b00001111,\n  0b00011111,\n  0b00111111,\n  0b01111111,\n  0b11111111\n]\n\nmodule.exports = class ConsumableBuffer {\n  /**\n   * @param {Uint8Array} value\n   */\n  constructor (value) {\n    this._value = value\n    this._currentBytePos = value.length - 1\n    this._currentBitPos = 7\n  }\n\n  availableBits () {\n    return this._currentBitPos + 1 + this._currentBytePos * 8\n  }\n\n  totalBits () {\n    return this._value.length * 8\n  }\n\n  /**\n   * @param {number} bits\n   */\n  take (bits) {\n    let pendingBits = bits\n    let result = 0\n    while (pendingBits && this._haveBits()) {\n      const byte = this._value[this._currentBytePos]\n      const availableBits = this._currentBitPos + 1\n      const taking = Math.min(availableBits, pendingBits)\n      const value = byteBitsToInt(byte, availableBits - taking, taking)\n      result = (result << taking) + value\n\n      pendingBits -= taking\n\n      this._currentBitPos -= taking\n      if (this._currentBitPos < 0) {\n        this._currentBitPos = 7\n        this._currentBytePos--\n      }\n    }\n\n    return result\n  }\n\n  /**\n   * @param {number} bits\n   */\n  untake (bits) {\n    this._currentBitPos += bits\n    while (this._currentBitPos > 7) {\n      this._currentBitPos -= 8\n      this._currentBytePos += 1\n    }\n  }\n\n  _haveBits () {\n    return this._currentBytePos >= 0\n  }\n}\n\n/**\n * @param {number} byte\n * @param {number} start\n * @param {number} length\n */\nfunction byteBitsToInt (byte, start, length) {\n  const mask = maskFor(start, length)\n  return (byte & mask) >>> start\n}\n\n/**\n * @param {number} start\n * @param {number} length\n */\nfunction maskFor (start, length) {\n  return START_MASKS[start] & STOP_MASKS[Math.min(length + start - 1, 7)]\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvaGFtdC1zaGFyZGluZy9zcmMvY29uc3VtYWJsZS1idWZmZXIuanMiLCJtYXBwaW5ncyI6IkFBQVk7O0FBRVo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGFBQWEsWUFBWTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkI7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIi9ob21lL2FsdGNvaW4tZGFkZHkvRG93bmxvYWRzL293bmx5L25vZGVfbW9kdWxlcy9oYW10LXNoYXJkaW5nL3NyYy9jb25zdW1hYmxlLWJ1ZmZlci5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCdcblxuY29uc3QgU1RBUlRfTUFTS1MgPSBbXG4gIDBiMTExMTExMTEsXG4gIDBiMTExMTExMTAsXG4gIDBiMTExMTExMDAsXG4gIDBiMTExMTEwMDAsXG4gIDBiMTExMTAwMDAsXG4gIDBiMTExMDAwMDAsXG4gIDBiMTEwMDAwMDAsXG4gIDBiMTAwMDAwMDBcbl1cblxuY29uc3QgU1RPUF9NQVNLUyA9IFtcbiAgMGIwMDAwMDAwMSxcbiAgMGIwMDAwMDAxMSxcbiAgMGIwMDAwMDExMSxcbiAgMGIwMDAwMTExMSxcbiAgMGIwMDAxMTExMSxcbiAgMGIwMDExMTExMSxcbiAgMGIwMTExMTExMSxcbiAgMGIxMTExMTExMVxuXVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNsYXNzIENvbnN1bWFibGVCdWZmZXIge1xuICAvKipcbiAgICogQHBhcmFtIHtVaW50OEFycmF5fSB2YWx1ZVxuICAgKi9cbiAgY29uc3RydWN0b3IgKHZhbHVlKSB7XG4gICAgdGhpcy5fdmFsdWUgPSB2YWx1ZVxuICAgIHRoaXMuX2N1cnJlbnRCeXRlUG9zID0gdmFsdWUubGVuZ3RoIC0gMVxuICAgIHRoaXMuX2N1cnJlbnRCaXRQb3MgPSA3XG4gIH1cblxuICBhdmFpbGFibGVCaXRzICgpIHtcbiAgICByZXR1cm4gdGhpcy5fY3VycmVudEJpdFBvcyArIDEgKyB0aGlzLl9jdXJyZW50Qnl0ZVBvcyAqIDhcbiAgfVxuXG4gIHRvdGFsQml0cyAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3ZhbHVlLmxlbmd0aCAqIDhcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge251bWJlcn0gYml0c1xuICAgKi9cbiAgdGFrZSAoYml0cykge1xuICAgIGxldCBwZW5kaW5nQml0cyA9IGJpdHNcbiAgICBsZXQgcmVzdWx0ID0gMFxuICAgIHdoaWxlIChwZW5kaW5nQml0cyAmJiB0aGlzLl9oYXZlQml0cygpKSB7XG4gICAgICBjb25zdCBieXRlID0gdGhpcy5fdmFsdWVbdGhpcy5fY3VycmVudEJ5dGVQb3NdXG4gICAgICBjb25zdCBhdmFpbGFibGVCaXRzID0gdGhpcy5fY3VycmVudEJpdFBvcyArIDFcbiAgICAgIGNvbnN0IHRha2luZyA9IE1hdGgubWluKGF2YWlsYWJsZUJpdHMsIHBlbmRpbmdCaXRzKVxuICAgICAgY29uc3QgdmFsdWUgPSBieXRlQml0c1RvSW50KGJ5dGUsIGF2YWlsYWJsZUJpdHMgLSB0YWtpbmcsIHRha2luZylcbiAgICAgIHJlc3VsdCA9IChyZXN1bHQgPDwgdGFraW5nKSArIHZhbHVlXG5cbiAgICAgIHBlbmRpbmdCaXRzIC09IHRha2luZ1xuXG4gICAgICB0aGlzLl9jdXJyZW50Qml0UG9zIC09IHRha2luZ1xuICAgICAgaWYgKHRoaXMuX2N1cnJlbnRCaXRQb3MgPCAwKSB7XG4gICAgICAgIHRoaXMuX2N1cnJlbnRCaXRQb3MgPSA3XG4gICAgICAgIHRoaXMuX2N1cnJlbnRCeXRlUG9zLS1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gcmVzdWx0XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtudW1iZXJ9IGJpdHNcbiAgICovXG4gIHVudGFrZSAoYml0cykge1xuICAgIHRoaXMuX2N1cnJlbnRCaXRQb3MgKz0gYml0c1xuICAgIHdoaWxlICh0aGlzLl9jdXJyZW50Qml0UG9zID4gNykge1xuICAgICAgdGhpcy5fY3VycmVudEJpdFBvcyAtPSA4XG4gICAgICB0aGlzLl9jdXJyZW50Qnl0ZVBvcyArPSAxXG4gICAgfVxuICB9XG5cbiAgX2hhdmVCaXRzICgpIHtcbiAgICByZXR1cm4gdGhpcy5fY3VycmVudEJ5dGVQb3MgPj0gMFxuICB9XG59XG5cbi8qKlxuICogQHBhcmFtIHtudW1iZXJ9IGJ5dGVcbiAqIEBwYXJhbSB7bnVtYmVyfSBzdGFydFxuICogQHBhcmFtIHtudW1iZXJ9IGxlbmd0aFxuICovXG5mdW5jdGlvbiBieXRlQml0c1RvSW50IChieXRlLCBzdGFydCwgbGVuZ3RoKSB7XG4gIGNvbnN0IG1hc2sgPSBtYXNrRm9yKHN0YXJ0LCBsZW5ndGgpXG4gIHJldHVybiAoYnl0ZSAmIG1hc2spID4+PiBzdGFydFxufVxuXG4vKipcbiAqIEBwYXJhbSB7bnVtYmVyfSBzdGFydFxuICogQHBhcmFtIHtudW1iZXJ9IGxlbmd0aFxuICovXG5mdW5jdGlvbiBtYXNrRm9yIChzdGFydCwgbGVuZ3RoKSB7XG4gIHJldHVybiBTVEFSVF9NQVNLU1tzdGFydF0gJiBTVE9QX01BU0tTW01hdGgubWluKGxlbmd0aCArIHN0YXJ0IC0gMSwgNyldXG59XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/hamt-sharding/src/consumable-buffer.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/hamt-sharding/src/consumable-hash.js":
/*!***********************************************************!*\
  !*** ./node_modules/hamt-sharding/src/consumable-hash.js ***!
  \***********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nconst ConsumableBuffer = __webpack_require__(/*! ./consumable-buffer */ \"(ssr)/./node_modules/hamt-sharding/src/consumable-buffer.js\")\nconst { concat: uint8ArrayConcat } = __webpack_require__(/*! uint8arrays/concat */ \"(ssr)/./node_modules/uint8arrays/cjs/src/concat.js\")\n\n/**\n * @param {(value: Uint8Array) => Promise<Uint8Array>} hashFn\n */\nfunction wrapHash (hashFn) {\n  /**\n   * @param {InfiniteHash | Uint8Array} value\n   */\n  function hashing (value) {\n    if (value instanceof InfiniteHash) {\n      // already a hash. return it\n      return value\n    } else {\n      return new InfiniteHash(value, hashFn)\n    }\n  }\n\n  return hashing\n}\n\nclass InfiniteHash {\n  /**\n   *\n   * @param {Uint8Array} value\n   * @param {(value: Uint8Array) => Promise<Uint8Array>} hashFn\n   */\n  constructor (value, hashFn) {\n    if (!(value instanceof Uint8Array)) {\n      throw new Error('can only hash Uint8Arrays')\n    }\n\n    this._value = value\n    this._hashFn = hashFn\n    this._depth = -1\n    this._availableBits = 0\n    this._currentBufferIndex = 0\n\n    /** @type {ConsumableBuffer[]} */\n    this._buffers = []\n  }\n\n  /**\n   * @param {number} bits\n   */\n  async take (bits) {\n    let pendingBits = bits\n\n    while (this._availableBits < pendingBits) {\n      await this._produceMoreBits()\n    }\n\n    let result = 0\n\n    while (pendingBits > 0) {\n      const hash = this._buffers[this._currentBufferIndex]\n      const available = Math.min(hash.availableBits(), pendingBits)\n      const took = hash.take(available)\n      result = (result << available) + took\n      pendingBits -= available\n      this._availableBits -= available\n\n      if (hash.availableBits() === 0) {\n        this._currentBufferIndex++\n      }\n    }\n\n    return result\n  }\n\n  /**\n   * @param {number} bits\n   */\n  untake (bits) {\n    let pendingBits = bits\n\n    while (pendingBits > 0) {\n      const hash = this._buffers[this._currentBufferIndex]\n      const availableForUntake = Math.min(hash.totalBits() - hash.availableBits(), pendingBits)\n      hash.untake(availableForUntake)\n      pendingBits -= availableForUntake\n      this._availableBits += availableForUntake\n\n      if (this._currentBufferIndex > 0 && hash.totalBits() === hash.availableBits()) {\n        this._depth--\n        this._currentBufferIndex--\n      }\n    }\n  }\n\n  async _produceMoreBits () {\n    this._depth++\n\n    const value = this._depth ? uint8ArrayConcat([this._value, Uint8Array.from([this._depth])]) : this._value\n    const hashValue = await this._hashFn(value)\n    const buffer = new ConsumableBuffer(hashValue)\n\n    this._buffers.push(buffer)\n    this._availableBits += buffer.availableBits()\n  }\n}\n\nmodule.exports = wrapHash\nmodule.exports.InfiniteHash = InfiniteHash\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvaGFtdC1zaGFyZGluZy9zcmMvY29uc3VtYWJsZS1oYXNoLmpzIiwibWFwcGluZ3MiOiJBQUFZOztBQUVaLHlCQUF5QixtQkFBTyxDQUFDLHdGQUFxQjtBQUN0RCxRQUFRLDJCQUEyQixFQUFFLG1CQUFPLENBQUMsOEVBQW9COztBQUVqRTtBQUNBLFdBQVcsNENBQTRDO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBLGFBQWEsMkJBQTJCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYSxZQUFZO0FBQ3pCLGFBQWEsNENBQTRDO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxlQUFlLG9CQUFvQjtBQUNuQztBQUNBOztBQUVBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDJCQUEyQiIsInNvdXJjZXMiOlsiL2hvbWUvYWx0Y29pbi1kYWRkeS9Eb3dubG9hZHMvb3dubHkvbm9kZV9tb2R1bGVzL2hhbXQtc2hhcmRpbmcvc3JjL2NvbnN1bWFibGUtaGFzaC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCdcblxuY29uc3QgQ29uc3VtYWJsZUJ1ZmZlciA9IHJlcXVpcmUoJy4vY29uc3VtYWJsZS1idWZmZXInKVxuY29uc3QgeyBjb25jYXQ6IHVpbnQ4QXJyYXlDb25jYXQgfSA9IHJlcXVpcmUoJ3VpbnQ4YXJyYXlzL2NvbmNhdCcpXG5cbi8qKlxuICogQHBhcmFtIHsodmFsdWU6IFVpbnQ4QXJyYXkpID0+IFByb21pc2U8VWludDhBcnJheT59IGhhc2hGblxuICovXG5mdW5jdGlvbiB3cmFwSGFzaCAoaGFzaEZuKSB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge0luZmluaXRlSGFzaCB8IFVpbnQ4QXJyYXl9IHZhbHVlXG4gICAqL1xuICBmdW5jdGlvbiBoYXNoaW5nICh2YWx1ZSkge1xuICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIEluZmluaXRlSGFzaCkge1xuICAgICAgLy8gYWxyZWFkeSBhIGhhc2guIHJldHVybiBpdFxuICAgICAgcmV0dXJuIHZhbHVlXG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBuZXcgSW5maW5pdGVIYXNoKHZhbHVlLCBoYXNoRm4pXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGhhc2hpbmdcbn1cblxuY2xhc3MgSW5maW5pdGVIYXNoIHtcbiAgLyoqXG4gICAqXG4gICAqIEBwYXJhbSB7VWludDhBcnJheX0gdmFsdWVcbiAgICogQHBhcmFtIHsodmFsdWU6IFVpbnQ4QXJyYXkpID0+IFByb21pc2U8VWludDhBcnJheT59IGhhc2hGblxuICAgKi9cbiAgY29uc3RydWN0b3IgKHZhbHVlLCBoYXNoRm4pIHtcbiAgICBpZiAoISh2YWx1ZSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2NhbiBvbmx5IGhhc2ggVWludDhBcnJheXMnKVxuICAgIH1cblxuICAgIHRoaXMuX3ZhbHVlID0gdmFsdWVcbiAgICB0aGlzLl9oYXNoRm4gPSBoYXNoRm5cbiAgICB0aGlzLl9kZXB0aCA9IC0xXG4gICAgdGhpcy5fYXZhaWxhYmxlQml0cyA9IDBcbiAgICB0aGlzLl9jdXJyZW50QnVmZmVySW5kZXggPSAwXG5cbiAgICAvKiogQHR5cGUge0NvbnN1bWFibGVCdWZmZXJbXX0gKi9cbiAgICB0aGlzLl9idWZmZXJzID0gW11cbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge251bWJlcn0gYml0c1xuICAgKi9cbiAgYXN5bmMgdGFrZSAoYml0cykge1xuICAgIGxldCBwZW5kaW5nQml0cyA9IGJpdHNcblxuICAgIHdoaWxlICh0aGlzLl9hdmFpbGFibGVCaXRzIDwgcGVuZGluZ0JpdHMpIHtcbiAgICAgIGF3YWl0IHRoaXMuX3Byb2R1Y2VNb3JlQml0cygpXG4gICAgfVxuXG4gICAgbGV0IHJlc3VsdCA9IDBcblxuICAgIHdoaWxlIChwZW5kaW5nQml0cyA+IDApIHtcbiAgICAgIGNvbnN0IGhhc2ggPSB0aGlzLl9idWZmZXJzW3RoaXMuX2N1cnJlbnRCdWZmZXJJbmRleF1cbiAgICAgIGNvbnN0IGF2YWlsYWJsZSA9IE1hdGgubWluKGhhc2guYXZhaWxhYmxlQml0cygpLCBwZW5kaW5nQml0cylcbiAgICAgIGNvbnN0IHRvb2sgPSBoYXNoLnRha2UoYXZhaWxhYmxlKVxuICAgICAgcmVzdWx0ID0gKHJlc3VsdCA8PCBhdmFpbGFibGUpICsgdG9va1xuICAgICAgcGVuZGluZ0JpdHMgLT0gYXZhaWxhYmxlXG4gICAgICB0aGlzLl9hdmFpbGFibGVCaXRzIC09IGF2YWlsYWJsZVxuXG4gICAgICBpZiAoaGFzaC5hdmFpbGFibGVCaXRzKCkgPT09IDApIHtcbiAgICAgICAgdGhpcy5fY3VycmVudEJ1ZmZlckluZGV4KytcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gcmVzdWx0XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtudW1iZXJ9IGJpdHNcbiAgICovXG4gIHVudGFrZSAoYml0cykge1xuICAgIGxldCBwZW5kaW5nQml0cyA9IGJpdHNcblxuICAgIHdoaWxlIChwZW5kaW5nQml0cyA+IDApIHtcbiAgICAgIGNvbnN0IGhhc2ggPSB0aGlzLl9idWZmZXJzW3RoaXMuX2N1cnJlbnRCdWZmZXJJbmRleF1cbiAgICAgIGNvbnN0IGF2YWlsYWJsZUZvclVudGFrZSA9IE1hdGgubWluKGhhc2gudG90YWxCaXRzKCkgLSBoYXNoLmF2YWlsYWJsZUJpdHMoKSwgcGVuZGluZ0JpdHMpXG4gICAgICBoYXNoLnVudGFrZShhdmFpbGFibGVGb3JVbnRha2UpXG4gICAgICBwZW5kaW5nQml0cyAtPSBhdmFpbGFibGVGb3JVbnRha2VcbiAgICAgIHRoaXMuX2F2YWlsYWJsZUJpdHMgKz0gYXZhaWxhYmxlRm9yVW50YWtlXG5cbiAgICAgIGlmICh0aGlzLl9jdXJyZW50QnVmZmVySW5kZXggPiAwICYmIGhhc2gudG90YWxCaXRzKCkgPT09IGhhc2guYXZhaWxhYmxlQml0cygpKSB7XG4gICAgICAgIHRoaXMuX2RlcHRoLS1cbiAgICAgICAgdGhpcy5fY3VycmVudEJ1ZmZlckluZGV4LS1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBhc3luYyBfcHJvZHVjZU1vcmVCaXRzICgpIHtcbiAgICB0aGlzLl9kZXB0aCsrXG5cbiAgICBjb25zdCB2YWx1ZSA9IHRoaXMuX2RlcHRoID8gdWludDhBcnJheUNvbmNhdChbdGhpcy5fdmFsdWUsIFVpbnQ4QXJyYXkuZnJvbShbdGhpcy5fZGVwdGhdKV0pIDogdGhpcy5fdmFsdWVcbiAgICBjb25zdCBoYXNoVmFsdWUgPSBhd2FpdCB0aGlzLl9oYXNoRm4odmFsdWUpXG4gICAgY29uc3QgYnVmZmVyID0gbmV3IENvbnN1bWFibGVCdWZmZXIoaGFzaFZhbHVlKVxuXG4gICAgdGhpcy5fYnVmZmVycy5wdXNoKGJ1ZmZlcilcbiAgICB0aGlzLl9hdmFpbGFibGVCaXRzICs9IGJ1ZmZlci5hdmFpbGFibGVCaXRzKClcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHdyYXBIYXNoXG5tb2R1bGUuZXhwb3J0cy5JbmZpbml0ZUhhc2ggPSBJbmZpbml0ZUhhc2hcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/hamt-sharding/src/consumable-hash.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/hamt-sharding/src/index.js":
/*!*************************************************!*\
  !*** ./node_modules/hamt-sharding/src/index.js ***!
  \*************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nconst Bucket = __webpack_require__(/*! ./bucket */ \"(ssr)/./node_modules/hamt-sharding/src/bucket.js\")\nconst wrapHash = __webpack_require__(/*! ./consumable-hash */ \"(ssr)/./node_modules/hamt-sharding/src/consumable-hash.js\")\n\n/**\n * @typedef {object} UserBucketOptions\n * @property {(value: Uint8Array) => Promise<Uint8Array>} hashFn\n * @property {number} [bits=8]\n */\n\n/**\n * @param {UserBucketOptions} options\n */\nfunction createHAMT (options) {\n  if (!options || !options.hashFn) {\n    throw new Error('please define an options.hashFn')\n  }\n\n  const bucketOptions = {\n    bits: options.bits || 8,\n    hash: wrapHash(options.hashFn)\n  }\n\n  return new Bucket(bucketOptions)\n}\n\nmodule.exports = {\n  createHAMT,\n  Bucket\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvaGFtdC1zaGFyZGluZy9zcmMvaW5kZXguanMiLCJtYXBwaW5ncyI6IkFBQVk7O0FBRVosZUFBZSxtQkFBTyxDQUFDLGtFQUFVO0FBQ2pDLGlCQUFpQixtQkFBTyxDQUFDLG9GQUFtQjs7QUFFNUM7QUFDQSxhQUFhLFFBQVE7QUFDckIsY0FBYyw0Q0FBNEM7QUFDMUQsY0FBYyxRQUFRO0FBQ3RCOztBQUVBO0FBQ0EsV0FBVyxtQkFBbUI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyIvaG9tZS9hbHRjb2luLWRhZGR5L0Rvd25sb2Fkcy9vd25seS9ub2RlX21vZHVsZXMvaGFtdC1zaGFyZGluZy9zcmMvaW5kZXguanMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IEJ1Y2tldCA9IHJlcXVpcmUoJy4vYnVja2V0JylcbmNvbnN0IHdyYXBIYXNoID0gcmVxdWlyZSgnLi9jb25zdW1hYmxlLWhhc2gnKVxuXG4vKipcbiAqIEB0eXBlZGVmIHtvYmplY3R9IFVzZXJCdWNrZXRPcHRpb25zXG4gKiBAcHJvcGVydHkgeyh2YWx1ZTogVWludDhBcnJheSkgPT4gUHJvbWlzZTxVaW50OEFycmF5Pn0gaGFzaEZuXG4gKiBAcHJvcGVydHkge251bWJlcn0gW2JpdHM9OF1cbiAqL1xuXG4vKipcbiAqIEBwYXJhbSB7VXNlckJ1Y2tldE9wdGlvbnN9IG9wdGlvbnNcbiAqL1xuZnVuY3Rpb24gY3JlYXRlSEFNVCAob3B0aW9ucykge1xuICBpZiAoIW9wdGlvbnMgfHwgIW9wdGlvbnMuaGFzaEZuKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdwbGVhc2UgZGVmaW5lIGFuIG9wdGlvbnMuaGFzaEZuJylcbiAgfVxuXG4gIGNvbnN0IGJ1Y2tldE9wdGlvbnMgPSB7XG4gICAgYml0czogb3B0aW9ucy5iaXRzIHx8IDgsXG4gICAgaGFzaDogd3JhcEhhc2gob3B0aW9ucy5oYXNoRm4pXG4gIH1cblxuICByZXR1cm4gbmV3IEJ1Y2tldChidWNrZXRPcHRpb25zKVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgY3JlYXRlSEFNVCxcbiAgQnVja2V0XG59XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/hamt-sharding/src/index.js\n");

/***/ })

};
;