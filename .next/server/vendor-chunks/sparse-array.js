"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/sparse-array";
exports.ids = ["vendor-chunks/sparse-array"];
exports.modules = {

/***/ "(rsc)/./node_modules/sparse-array/index.js":
/*!********************************************!*\
  !*** ./node_modules/sparse-array/index.js ***!
  \********************************************/
/***/ ((module) => {

eval("\n\n// JS treats subjects of bitwise operators as SIGNED 32 bit numbers,\n// which means the maximum amount of bits we can store inside each byte\n// is 7..\nconst BITS_PER_BYTE = 7\n\nmodule.exports = class SparseArray {\n  constructor () {\n    this._bitArrays = []\n    this._data = []\n    this._length = 0\n    this._changedLength = false\n    this._changedData = false\n  }\n\n  set (index, value) {\n    let pos = this._internalPositionFor(index, false)\n    if (value === undefined) {\n      // unsetting\n      if (pos !== -1) {\n        // remove item from bit array and array itself\n        this._unsetInternalPos(pos)\n        this._unsetBit(index)\n        this._changedLength = true\n        this._changedData = true\n      }\n    } else {\n      let needsSort = false\n      if (pos === -1) {\n        pos = this._data.length\n        this._setBit(index)\n        this._changedData = true\n      } else {\n        needsSort = true\n      }\n      this._setInternalPos(pos, index, value, needsSort)\n      this._changedLength = true\n    }\n  }\n\n  unset (index) {\n    this.set(index, undefined)\n  }\n\n  get (index) {\n    this._sortData()\n    const pos = this._internalPositionFor(index, true)\n    if (pos === -1) {\n      return undefined\n    }\n    return this._data[pos][1]\n  }\n\n  push (value) {\n    this.set(this.length, value)\n    return this.length\n  }\n\n  get length () {\n    this._sortData()\n    if (this._changedLength) {\n      const last = this._data[this._data.length - 1]\n      this._length = last ? last[0] + 1 : 0\n      this._changedLength = false\n    }\n    return this._length\n  }\n\n  forEach (iterator) {\n    let i = 0\n    while(i < this.length) {\n      iterator(this.get(i), i, this)\n      i++\n    }\n  }\n\n  map (iterator) {\n    let i = 0\n    let mapped = new Array(this.length)\n    while(i < this.length) {\n      mapped[i] = iterator(this.get(i), i, this)\n      i++\n    }\n    return mapped\n  }\n\n  reduce (reducer, initialValue) {\n    let i = 0\n    let acc = initialValue\n    while(i < this.length) {\n      const value = this.get(i)\n      acc = reducer(acc, value, i)\n      i++\n    }\n    return acc\n  }\n\n  find (finder) {\n    let i = 0, found, last\n    while ((i < this.length) && !found) {\n      last = this.get(i)\n      found = finder(last)\n      i++\n    }\n    return found ? last : undefined\n  }\n\n  _internalPositionFor (index, noCreate) {\n    const bytePos = this._bytePosFor(index, noCreate)\n    if (bytePos >= this._bitArrays.length) {\n      return -1\n    }\n    const byte = this._bitArrays[bytePos]\n    const bitPos = index - bytePos * BITS_PER_BYTE\n    const exists = (byte & (1 << bitPos)) > 0\n    if (!exists) {\n      return -1\n    }\n    const previousPopCount = this._bitArrays.slice(0, bytePos).reduce(popCountReduce, 0)\n\n    const mask = ~(0xffffffff << (bitPos + 1))\n    const bytePopCount = popCount(byte & mask)\n    const arrayPos = previousPopCount + bytePopCount - 1\n    return arrayPos\n  }\n\n  _bytePosFor (index, noCreate) {\n    const bytePos = Math.floor(index / BITS_PER_BYTE)\n    const targetLength = bytePos + 1\n    while (!noCreate && this._bitArrays.length < targetLength) {\n      this._bitArrays.push(0)\n    }\n    return bytePos\n  }\n\n  _setBit (index) {\n    const bytePos = this._bytePosFor(index, false)\n    this._bitArrays[bytePos] |= (1 << (index - (bytePos * BITS_PER_BYTE)))\n  }\n\n  _unsetBit(index) {\n    const bytePos = this._bytePosFor(index, false)\n    this._bitArrays[bytePos] &= ~(1 << (index - (bytePos * BITS_PER_BYTE)))\n  }\n\n  _setInternalPos(pos, index, value, needsSort) {\n    const data =this._data\n    const elem = [index, value]\n    if (needsSort) {\n      this._sortData()\n      data[pos] = elem\n    } else {\n      // new element. just shove it into the array\n      // but be nice about where we shove it\n      // in order to make sorting it later easier\n      if (data.length) {\n        if (data[data.length - 1][0] >= index) {\n          data.push(elem)\n        } else if (data[0][0] <= index) {\n          data.unshift(elem)\n        } else {\n          const randomIndex = Math.round(data.length / 2)\n          this._data = data.slice(0, randomIndex).concat(elem).concat(data.slice(randomIndex))\n        }\n      } else {\n        this._data.push(elem)\n      }\n      this._changedData = true\n      this._changedLength = true\n    }\n  }\n\n  _unsetInternalPos (pos) {\n    this._data.splice(pos, 1)\n  }\n\n  _sortData () {\n    if (this._changedData) {\n      this._data.sort(sortInternal)\n    }\n\n    this._changedData = false\n  }\n\n  bitField () {\n    const bytes = []\n    let pendingBitsForResultingByte = 8\n    let pendingBitsForNewByte = 0\n    let resultingByte = 0\n    let newByte\n    const pending = this._bitArrays.slice()\n    while (pending.length || pendingBitsForNewByte) {\n      if (pendingBitsForNewByte === 0) {\n        newByte = pending.shift()\n        pendingBitsForNewByte = 7\n      }\n\n      const usingBits = Math.min(pendingBitsForNewByte, pendingBitsForResultingByte)\n      const mask = ~(0b11111111 << usingBits)\n      const masked = newByte & mask\n      resultingByte |= masked << (8 - pendingBitsForResultingByte)\n      newByte = newByte >>> usingBits\n      pendingBitsForNewByte -= usingBits\n      pendingBitsForResultingByte -= usingBits\n\n      if (!pendingBitsForResultingByte || (!pendingBitsForNewByte && !pending.length)) {\n        bytes.push(resultingByte)\n        resultingByte = 0\n        pendingBitsForResultingByte = 8\n      }\n    }\n\n    // remove trailing zeroes\n    for(var i = bytes.length - 1; i > 0; i--) {\n      const value = bytes[i]\n      if (value === 0) {\n        bytes.pop()\n      } else {\n        break\n      }\n    }\n\n    return bytes\n  }\n\n  compactArray () {\n    this._sortData()\n    return this._data.map(valueOnly)\n  }\n}\n\nfunction popCountReduce (count, byte) {\n  return count + popCount(byte)\n}\n\nfunction popCount(_v) {\n  let v = _v\n  v = v - ((v >> 1) & 0x55555555)                    // reuse input as temporary\n  v = (v & 0x33333333) + ((v >> 2) & 0x33333333)     // temp\n  return ((v + (v >> 4) & 0xF0F0F0F) * 0x1010101) >> 24\n}\n\nfunction sortInternal (a, b) {\n  return a[0] - b[0]\n}\n\nfunction valueOnly (elem) {\n  return elem[1]\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc3BhcnNlLWFycmF5L2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFZOztBQUVaO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esa0NBQWtDLE9BQU87QUFDekM7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBIiwic291cmNlcyI6WyIvaG9tZS9hbHRjb2luLWRhZGR5L0Rvd25sb2Fkcy9vd25seS9ub2RlX21vZHVsZXMvc3BhcnNlLWFycmF5L2luZGV4LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0J1xuXG4vLyBKUyB0cmVhdHMgc3ViamVjdHMgb2YgYml0d2lzZSBvcGVyYXRvcnMgYXMgU0lHTkVEIDMyIGJpdCBudW1iZXJzLFxuLy8gd2hpY2ggbWVhbnMgdGhlIG1heGltdW0gYW1vdW50IG9mIGJpdHMgd2UgY2FuIHN0b3JlIGluc2lkZSBlYWNoIGJ5dGVcbi8vIGlzIDcuLlxuY29uc3QgQklUU19QRVJfQllURSA9IDdcblxubW9kdWxlLmV4cG9ydHMgPSBjbGFzcyBTcGFyc2VBcnJheSB7XG4gIGNvbnN0cnVjdG9yICgpIHtcbiAgICB0aGlzLl9iaXRBcnJheXMgPSBbXVxuICAgIHRoaXMuX2RhdGEgPSBbXVxuICAgIHRoaXMuX2xlbmd0aCA9IDBcbiAgICB0aGlzLl9jaGFuZ2VkTGVuZ3RoID0gZmFsc2VcbiAgICB0aGlzLl9jaGFuZ2VkRGF0YSA9IGZhbHNlXG4gIH1cblxuICBzZXQgKGluZGV4LCB2YWx1ZSkge1xuICAgIGxldCBwb3MgPSB0aGlzLl9pbnRlcm5hbFBvc2l0aW9uRm9yKGluZGV4LCBmYWxzZSlcbiAgICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgLy8gdW5zZXR0aW5nXG4gICAgICBpZiAocG9zICE9PSAtMSkge1xuICAgICAgICAvLyByZW1vdmUgaXRlbSBmcm9tIGJpdCBhcnJheSBhbmQgYXJyYXkgaXRzZWxmXG4gICAgICAgIHRoaXMuX3Vuc2V0SW50ZXJuYWxQb3MocG9zKVxuICAgICAgICB0aGlzLl91bnNldEJpdChpbmRleClcbiAgICAgICAgdGhpcy5fY2hhbmdlZExlbmd0aCA9IHRydWVcbiAgICAgICAgdGhpcy5fY2hhbmdlZERhdGEgPSB0cnVlXG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGxldCBuZWVkc1NvcnQgPSBmYWxzZVxuICAgICAgaWYgKHBvcyA9PT0gLTEpIHtcbiAgICAgICAgcG9zID0gdGhpcy5fZGF0YS5sZW5ndGhcbiAgICAgICAgdGhpcy5fc2V0Qml0KGluZGV4KVxuICAgICAgICB0aGlzLl9jaGFuZ2VkRGF0YSA9IHRydWVcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG5lZWRzU29ydCA9IHRydWVcbiAgICAgIH1cbiAgICAgIHRoaXMuX3NldEludGVybmFsUG9zKHBvcywgaW5kZXgsIHZhbHVlLCBuZWVkc1NvcnQpXG4gICAgICB0aGlzLl9jaGFuZ2VkTGVuZ3RoID0gdHJ1ZVxuICAgIH1cbiAgfVxuXG4gIHVuc2V0IChpbmRleCkge1xuICAgIHRoaXMuc2V0KGluZGV4LCB1bmRlZmluZWQpXG4gIH1cblxuICBnZXQgKGluZGV4KSB7XG4gICAgdGhpcy5fc29ydERhdGEoKVxuICAgIGNvbnN0IHBvcyA9IHRoaXMuX2ludGVybmFsUG9zaXRpb25Gb3IoaW5kZXgsIHRydWUpXG4gICAgaWYgKHBvcyA9PT0gLTEpIHtcbiAgICAgIHJldHVybiB1bmRlZmluZWRcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX2RhdGFbcG9zXVsxXVxuICB9XG5cbiAgcHVzaCAodmFsdWUpIHtcbiAgICB0aGlzLnNldCh0aGlzLmxlbmd0aCwgdmFsdWUpXG4gICAgcmV0dXJuIHRoaXMubGVuZ3RoXG4gIH1cblxuICBnZXQgbGVuZ3RoICgpIHtcbiAgICB0aGlzLl9zb3J0RGF0YSgpXG4gICAgaWYgKHRoaXMuX2NoYW5nZWRMZW5ndGgpIHtcbiAgICAgIGNvbnN0IGxhc3QgPSB0aGlzLl9kYXRhW3RoaXMuX2RhdGEubGVuZ3RoIC0gMV1cbiAgICAgIHRoaXMuX2xlbmd0aCA9IGxhc3QgPyBsYXN0WzBdICsgMSA6IDBcbiAgICAgIHRoaXMuX2NoYW5nZWRMZW5ndGggPSBmYWxzZVxuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fbGVuZ3RoXG4gIH1cblxuICBmb3JFYWNoIChpdGVyYXRvcikge1xuICAgIGxldCBpID0gMFxuICAgIHdoaWxlKGkgPCB0aGlzLmxlbmd0aCkge1xuICAgICAgaXRlcmF0b3IodGhpcy5nZXQoaSksIGksIHRoaXMpXG4gICAgICBpKytcbiAgICB9XG4gIH1cblxuICBtYXAgKGl0ZXJhdG9yKSB7XG4gICAgbGV0IGkgPSAwXG4gICAgbGV0IG1hcHBlZCA9IG5ldyBBcnJheSh0aGlzLmxlbmd0aClcbiAgICB3aGlsZShpIDwgdGhpcy5sZW5ndGgpIHtcbiAgICAgIG1hcHBlZFtpXSA9IGl0ZXJhdG9yKHRoaXMuZ2V0KGkpLCBpLCB0aGlzKVxuICAgICAgaSsrXG4gICAgfVxuICAgIHJldHVybiBtYXBwZWRcbiAgfVxuXG4gIHJlZHVjZSAocmVkdWNlciwgaW5pdGlhbFZhbHVlKSB7XG4gICAgbGV0IGkgPSAwXG4gICAgbGV0IGFjYyA9IGluaXRpYWxWYWx1ZVxuICAgIHdoaWxlKGkgPCB0aGlzLmxlbmd0aCkge1xuICAgICAgY29uc3QgdmFsdWUgPSB0aGlzLmdldChpKVxuICAgICAgYWNjID0gcmVkdWNlcihhY2MsIHZhbHVlLCBpKVxuICAgICAgaSsrXG4gICAgfVxuICAgIHJldHVybiBhY2NcbiAgfVxuXG4gIGZpbmQgKGZpbmRlcikge1xuICAgIGxldCBpID0gMCwgZm91bmQsIGxhc3RcbiAgICB3aGlsZSAoKGkgPCB0aGlzLmxlbmd0aCkgJiYgIWZvdW5kKSB7XG4gICAgICBsYXN0ID0gdGhpcy5nZXQoaSlcbiAgICAgIGZvdW5kID0gZmluZGVyKGxhc3QpXG4gICAgICBpKytcbiAgICB9XG4gICAgcmV0dXJuIGZvdW5kID8gbGFzdCA6IHVuZGVmaW5lZFxuICB9XG5cbiAgX2ludGVybmFsUG9zaXRpb25Gb3IgKGluZGV4LCBub0NyZWF0ZSkge1xuICAgIGNvbnN0IGJ5dGVQb3MgPSB0aGlzLl9ieXRlUG9zRm9yKGluZGV4LCBub0NyZWF0ZSlcbiAgICBpZiAoYnl0ZVBvcyA+PSB0aGlzLl9iaXRBcnJheXMubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gLTFcbiAgICB9XG4gICAgY29uc3QgYnl0ZSA9IHRoaXMuX2JpdEFycmF5c1tieXRlUG9zXVxuICAgIGNvbnN0IGJpdFBvcyA9IGluZGV4IC0gYnl0ZVBvcyAqIEJJVFNfUEVSX0JZVEVcbiAgICBjb25zdCBleGlzdHMgPSAoYnl0ZSAmICgxIDw8IGJpdFBvcykpID4gMFxuICAgIGlmICghZXhpc3RzKSB7XG4gICAgICByZXR1cm4gLTFcbiAgICB9XG4gICAgY29uc3QgcHJldmlvdXNQb3BDb3VudCA9IHRoaXMuX2JpdEFycmF5cy5zbGljZSgwLCBieXRlUG9zKS5yZWR1Y2UocG9wQ291bnRSZWR1Y2UsIDApXG5cbiAgICBjb25zdCBtYXNrID0gfigweGZmZmZmZmZmIDw8IChiaXRQb3MgKyAxKSlcbiAgICBjb25zdCBieXRlUG9wQ291bnQgPSBwb3BDb3VudChieXRlICYgbWFzaylcbiAgICBjb25zdCBhcnJheVBvcyA9IHByZXZpb3VzUG9wQ291bnQgKyBieXRlUG9wQ291bnQgLSAxXG4gICAgcmV0dXJuIGFycmF5UG9zXG4gIH1cblxuICBfYnl0ZVBvc0ZvciAoaW5kZXgsIG5vQ3JlYXRlKSB7XG4gICAgY29uc3QgYnl0ZVBvcyA9IE1hdGguZmxvb3IoaW5kZXggLyBCSVRTX1BFUl9CWVRFKVxuICAgIGNvbnN0IHRhcmdldExlbmd0aCA9IGJ5dGVQb3MgKyAxXG4gICAgd2hpbGUgKCFub0NyZWF0ZSAmJiB0aGlzLl9iaXRBcnJheXMubGVuZ3RoIDwgdGFyZ2V0TGVuZ3RoKSB7XG4gICAgICB0aGlzLl9iaXRBcnJheXMucHVzaCgwKVxuICAgIH1cbiAgICByZXR1cm4gYnl0ZVBvc1xuICB9XG5cbiAgX3NldEJpdCAoaW5kZXgpIHtcbiAgICBjb25zdCBieXRlUG9zID0gdGhpcy5fYnl0ZVBvc0ZvcihpbmRleCwgZmFsc2UpXG4gICAgdGhpcy5fYml0QXJyYXlzW2J5dGVQb3NdIHw9ICgxIDw8IChpbmRleCAtIChieXRlUG9zICogQklUU19QRVJfQllURSkpKVxuICB9XG5cbiAgX3Vuc2V0Qml0KGluZGV4KSB7XG4gICAgY29uc3QgYnl0ZVBvcyA9IHRoaXMuX2J5dGVQb3NGb3IoaW5kZXgsIGZhbHNlKVxuICAgIHRoaXMuX2JpdEFycmF5c1tieXRlUG9zXSAmPSB+KDEgPDwgKGluZGV4IC0gKGJ5dGVQb3MgKiBCSVRTX1BFUl9CWVRFKSkpXG4gIH1cblxuICBfc2V0SW50ZXJuYWxQb3MocG9zLCBpbmRleCwgdmFsdWUsIG5lZWRzU29ydCkge1xuICAgIGNvbnN0IGRhdGEgPXRoaXMuX2RhdGFcbiAgICBjb25zdCBlbGVtID0gW2luZGV4LCB2YWx1ZV1cbiAgICBpZiAobmVlZHNTb3J0KSB7XG4gICAgICB0aGlzLl9zb3J0RGF0YSgpXG4gICAgICBkYXRhW3Bvc10gPSBlbGVtXG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIG5ldyBlbGVtZW50LiBqdXN0IHNob3ZlIGl0IGludG8gdGhlIGFycmF5XG4gICAgICAvLyBidXQgYmUgbmljZSBhYm91dCB3aGVyZSB3ZSBzaG92ZSBpdFxuICAgICAgLy8gaW4gb3JkZXIgdG8gbWFrZSBzb3J0aW5nIGl0IGxhdGVyIGVhc2llclxuICAgICAgaWYgKGRhdGEubGVuZ3RoKSB7XG4gICAgICAgIGlmIChkYXRhW2RhdGEubGVuZ3RoIC0gMV1bMF0gPj0gaW5kZXgpIHtcbiAgICAgICAgICBkYXRhLnB1c2goZWxlbSlcbiAgICAgICAgfSBlbHNlIGlmIChkYXRhWzBdWzBdIDw9IGluZGV4KSB7XG4gICAgICAgICAgZGF0YS51bnNoaWZ0KGVsZW0pXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY29uc3QgcmFuZG9tSW5kZXggPSBNYXRoLnJvdW5kKGRhdGEubGVuZ3RoIC8gMilcbiAgICAgICAgICB0aGlzLl9kYXRhID0gZGF0YS5zbGljZSgwLCByYW5kb21JbmRleCkuY29uY2F0KGVsZW0pLmNvbmNhdChkYXRhLnNsaWNlKHJhbmRvbUluZGV4KSlcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5fZGF0YS5wdXNoKGVsZW0pXG4gICAgICB9XG4gICAgICB0aGlzLl9jaGFuZ2VkRGF0YSA9IHRydWVcbiAgICAgIHRoaXMuX2NoYW5nZWRMZW5ndGggPSB0cnVlXG4gICAgfVxuICB9XG5cbiAgX3Vuc2V0SW50ZXJuYWxQb3MgKHBvcykge1xuICAgIHRoaXMuX2RhdGEuc3BsaWNlKHBvcywgMSlcbiAgfVxuXG4gIF9zb3J0RGF0YSAoKSB7XG4gICAgaWYgKHRoaXMuX2NoYW5nZWREYXRhKSB7XG4gICAgICB0aGlzLl9kYXRhLnNvcnQoc29ydEludGVybmFsKVxuICAgIH1cblxuICAgIHRoaXMuX2NoYW5nZWREYXRhID0gZmFsc2VcbiAgfVxuXG4gIGJpdEZpZWxkICgpIHtcbiAgICBjb25zdCBieXRlcyA9IFtdXG4gICAgbGV0IHBlbmRpbmdCaXRzRm9yUmVzdWx0aW5nQnl0ZSA9IDhcbiAgICBsZXQgcGVuZGluZ0JpdHNGb3JOZXdCeXRlID0gMFxuICAgIGxldCByZXN1bHRpbmdCeXRlID0gMFxuICAgIGxldCBuZXdCeXRlXG4gICAgY29uc3QgcGVuZGluZyA9IHRoaXMuX2JpdEFycmF5cy5zbGljZSgpXG4gICAgd2hpbGUgKHBlbmRpbmcubGVuZ3RoIHx8IHBlbmRpbmdCaXRzRm9yTmV3Qnl0ZSkge1xuICAgICAgaWYgKHBlbmRpbmdCaXRzRm9yTmV3Qnl0ZSA9PT0gMCkge1xuICAgICAgICBuZXdCeXRlID0gcGVuZGluZy5zaGlmdCgpXG4gICAgICAgIHBlbmRpbmdCaXRzRm9yTmV3Qnl0ZSA9IDdcbiAgICAgIH1cblxuICAgICAgY29uc3QgdXNpbmdCaXRzID0gTWF0aC5taW4ocGVuZGluZ0JpdHNGb3JOZXdCeXRlLCBwZW5kaW5nQml0c0ZvclJlc3VsdGluZ0J5dGUpXG4gICAgICBjb25zdCBtYXNrID0gfigwYjExMTExMTExIDw8IHVzaW5nQml0cylcbiAgICAgIGNvbnN0IG1hc2tlZCA9IG5ld0J5dGUgJiBtYXNrXG4gICAgICByZXN1bHRpbmdCeXRlIHw9IG1hc2tlZCA8PCAoOCAtIHBlbmRpbmdCaXRzRm9yUmVzdWx0aW5nQnl0ZSlcbiAgICAgIG5ld0J5dGUgPSBuZXdCeXRlID4+PiB1c2luZ0JpdHNcbiAgICAgIHBlbmRpbmdCaXRzRm9yTmV3Qnl0ZSAtPSB1c2luZ0JpdHNcbiAgICAgIHBlbmRpbmdCaXRzRm9yUmVzdWx0aW5nQnl0ZSAtPSB1c2luZ0JpdHNcblxuICAgICAgaWYgKCFwZW5kaW5nQml0c0ZvclJlc3VsdGluZ0J5dGUgfHwgKCFwZW5kaW5nQml0c0Zvck5ld0J5dGUgJiYgIXBlbmRpbmcubGVuZ3RoKSkge1xuICAgICAgICBieXRlcy5wdXNoKHJlc3VsdGluZ0J5dGUpXG4gICAgICAgIHJlc3VsdGluZ0J5dGUgPSAwXG4gICAgICAgIHBlbmRpbmdCaXRzRm9yUmVzdWx0aW5nQnl0ZSA9IDhcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyByZW1vdmUgdHJhaWxpbmcgemVyb2VzXG4gICAgZm9yKHZhciBpID0gYnl0ZXMubGVuZ3RoIC0gMTsgaSA+IDA7IGktLSkge1xuICAgICAgY29uc3QgdmFsdWUgPSBieXRlc1tpXVxuICAgICAgaWYgKHZhbHVlID09PSAwKSB7XG4gICAgICAgIGJ5dGVzLnBvcCgpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBicmVha1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBieXRlc1xuICB9XG5cbiAgY29tcGFjdEFycmF5ICgpIHtcbiAgICB0aGlzLl9zb3J0RGF0YSgpXG4gICAgcmV0dXJuIHRoaXMuX2RhdGEubWFwKHZhbHVlT25seSlcbiAgfVxufVxuXG5mdW5jdGlvbiBwb3BDb3VudFJlZHVjZSAoY291bnQsIGJ5dGUpIHtcbiAgcmV0dXJuIGNvdW50ICsgcG9wQ291bnQoYnl0ZSlcbn1cblxuZnVuY3Rpb24gcG9wQ291bnQoX3YpIHtcbiAgbGV0IHYgPSBfdlxuICB2ID0gdiAtICgodiA+PiAxKSAmIDB4NTU1NTU1NTUpICAgICAgICAgICAgICAgICAgICAvLyByZXVzZSBpbnB1dCBhcyB0ZW1wb3JhcnlcbiAgdiA9ICh2ICYgMHgzMzMzMzMzMykgKyAoKHYgPj4gMikgJiAweDMzMzMzMzMzKSAgICAgLy8gdGVtcFxuICByZXR1cm4gKCh2ICsgKHYgPj4gNCkgJiAweEYwRjBGMEYpICogMHgxMDEwMTAxKSA+PiAyNFxufVxuXG5mdW5jdGlvbiBzb3J0SW50ZXJuYWwgKGEsIGIpIHtcbiAgcmV0dXJuIGFbMF0gLSBiWzBdXG59XG5cbmZ1bmN0aW9uIHZhbHVlT25seSAoZWxlbSkge1xuICByZXR1cm4gZWxlbVsxXVxufSJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/sparse-array/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/sparse-array/index.js":
/*!********************************************!*\
  !*** ./node_modules/sparse-array/index.js ***!
  \********************************************/
/***/ ((module) => {

eval("\n\n// JS treats subjects of bitwise operators as SIGNED 32 bit numbers,\n// which means the maximum amount of bits we can store inside each byte\n// is 7..\nconst BITS_PER_BYTE = 7\n\nmodule.exports = class SparseArray {\n  constructor () {\n    this._bitArrays = []\n    this._data = []\n    this._length = 0\n    this._changedLength = false\n    this._changedData = false\n  }\n\n  set (index, value) {\n    let pos = this._internalPositionFor(index, false)\n    if (value === undefined) {\n      // unsetting\n      if (pos !== -1) {\n        // remove item from bit array and array itself\n        this._unsetInternalPos(pos)\n        this._unsetBit(index)\n        this._changedLength = true\n        this._changedData = true\n      }\n    } else {\n      let needsSort = false\n      if (pos === -1) {\n        pos = this._data.length\n        this._setBit(index)\n        this._changedData = true\n      } else {\n        needsSort = true\n      }\n      this._setInternalPos(pos, index, value, needsSort)\n      this._changedLength = true\n    }\n  }\n\n  unset (index) {\n    this.set(index, undefined)\n  }\n\n  get (index) {\n    this._sortData()\n    const pos = this._internalPositionFor(index, true)\n    if (pos === -1) {\n      return undefined\n    }\n    return this._data[pos][1]\n  }\n\n  push (value) {\n    this.set(this.length, value)\n    return this.length\n  }\n\n  get length () {\n    this._sortData()\n    if (this._changedLength) {\n      const last = this._data[this._data.length - 1]\n      this._length = last ? last[0] + 1 : 0\n      this._changedLength = false\n    }\n    return this._length\n  }\n\n  forEach (iterator) {\n    let i = 0\n    while(i < this.length) {\n      iterator(this.get(i), i, this)\n      i++\n    }\n  }\n\n  map (iterator) {\n    let i = 0\n    let mapped = new Array(this.length)\n    while(i < this.length) {\n      mapped[i] = iterator(this.get(i), i, this)\n      i++\n    }\n    return mapped\n  }\n\n  reduce (reducer, initialValue) {\n    let i = 0\n    let acc = initialValue\n    while(i < this.length) {\n      const value = this.get(i)\n      acc = reducer(acc, value, i)\n      i++\n    }\n    return acc\n  }\n\n  find (finder) {\n    let i = 0, found, last\n    while ((i < this.length) && !found) {\n      last = this.get(i)\n      found = finder(last)\n      i++\n    }\n    return found ? last : undefined\n  }\n\n  _internalPositionFor (index, noCreate) {\n    const bytePos = this._bytePosFor(index, noCreate)\n    if (bytePos >= this._bitArrays.length) {\n      return -1\n    }\n    const byte = this._bitArrays[bytePos]\n    const bitPos = index - bytePos * BITS_PER_BYTE\n    const exists = (byte & (1 << bitPos)) > 0\n    if (!exists) {\n      return -1\n    }\n    const previousPopCount = this._bitArrays.slice(0, bytePos).reduce(popCountReduce, 0)\n\n    const mask = ~(0xffffffff << (bitPos + 1))\n    const bytePopCount = popCount(byte & mask)\n    const arrayPos = previousPopCount + bytePopCount - 1\n    return arrayPos\n  }\n\n  _bytePosFor (index, noCreate) {\n    const bytePos = Math.floor(index / BITS_PER_BYTE)\n    const targetLength = bytePos + 1\n    while (!noCreate && this._bitArrays.length < targetLength) {\n      this._bitArrays.push(0)\n    }\n    return bytePos\n  }\n\n  _setBit (index) {\n    const bytePos = this._bytePosFor(index, false)\n    this._bitArrays[bytePos] |= (1 << (index - (bytePos * BITS_PER_BYTE)))\n  }\n\n  _unsetBit(index) {\n    const bytePos = this._bytePosFor(index, false)\n    this._bitArrays[bytePos] &= ~(1 << (index - (bytePos * BITS_PER_BYTE)))\n  }\n\n  _setInternalPos(pos, index, value, needsSort) {\n    const data =this._data\n    const elem = [index, value]\n    if (needsSort) {\n      this._sortData()\n      data[pos] = elem\n    } else {\n      // new element. just shove it into the array\n      // but be nice about where we shove it\n      // in order to make sorting it later easier\n      if (data.length) {\n        if (data[data.length - 1][0] >= index) {\n          data.push(elem)\n        } else if (data[0][0] <= index) {\n          data.unshift(elem)\n        } else {\n          const randomIndex = Math.round(data.length / 2)\n          this._data = data.slice(0, randomIndex).concat(elem).concat(data.slice(randomIndex))\n        }\n      } else {\n        this._data.push(elem)\n      }\n      this._changedData = true\n      this._changedLength = true\n    }\n  }\n\n  _unsetInternalPos (pos) {\n    this._data.splice(pos, 1)\n  }\n\n  _sortData () {\n    if (this._changedData) {\n      this._data.sort(sortInternal)\n    }\n\n    this._changedData = false\n  }\n\n  bitField () {\n    const bytes = []\n    let pendingBitsForResultingByte = 8\n    let pendingBitsForNewByte = 0\n    let resultingByte = 0\n    let newByte\n    const pending = this._bitArrays.slice()\n    while (pending.length || pendingBitsForNewByte) {\n      if (pendingBitsForNewByte === 0) {\n        newByte = pending.shift()\n        pendingBitsForNewByte = 7\n      }\n\n      const usingBits = Math.min(pendingBitsForNewByte, pendingBitsForResultingByte)\n      const mask = ~(0b11111111 << usingBits)\n      const masked = newByte & mask\n      resultingByte |= masked << (8 - pendingBitsForResultingByte)\n      newByte = newByte >>> usingBits\n      pendingBitsForNewByte -= usingBits\n      pendingBitsForResultingByte -= usingBits\n\n      if (!pendingBitsForResultingByte || (!pendingBitsForNewByte && !pending.length)) {\n        bytes.push(resultingByte)\n        resultingByte = 0\n        pendingBitsForResultingByte = 8\n      }\n    }\n\n    // remove trailing zeroes\n    for(var i = bytes.length - 1; i > 0; i--) {\n      const value = bytes[i]\n      if (value === 0) {\n        bytes.pop()\n      } else {\n        break\n      }\n    }\n\n    return bytes\n  }\n\n  compactArray () {\n    this._sortData()\n    return this._data.map(valueOnly)\n  }\n}\n\nfunction popCountReduce (count, byte) {\n  return count + popCount(byte)\n}\n\nfunction popCount(_v) {\n  let v = _v\n  v = v - ((v >> 1) & 0x55555555)                    // reuse input as temporary\n  v = (v & 0x33333333) + ((v >> 2) & 0x33333333)     // temp\n  return ((v + (v >> 4) & 0xF0F0F0F) * 0x1010101) >> 24\n}\n\nfunction sortInternal (a, b) {\n  return a[0] - b[0]\n}\n\nfunction valueOnly (elem) {\n  return elem[1]\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvc3BhcnNlLWFycmF5L2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFZOztBQUVaO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esa0NBQWtDLE9BQU87QUFDekM7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBIiwic291cmNlcyI6WyIvaG9tZS9hbHRjb2luLWRhZGR5L0Rvd25sb2Fkcy9vd25seS9ub2RlX21vZHVsZXMvc3BhcnNlLWFycmF5L2luZGV4LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0J1xuXG4vLyBKUyB0cmVhdHMgc3ViamVjdHMgb2YgYml0d2lzZSBvcGVyYXRvcnMgYXMgU0lHTkVEIDMyIGJpdCBudW1iZXJzLFxuLy8gd2hpY2ggbWVhbnMgdGhlIG1heGltdW0gYW1vdW50IG9mIGJpdHMgd2UgY2FuIHN0b3JlIGluc2lkZSBlYWNoIGJ5dGVcbi8vIGlzIDcuLlxuY29uc3QgQklUU19QRVJfQllURSA9IDdcblxubW9kdWxlLmV4cG9ydHMgPSBjbGFzcyBTcGFyc2VBcnJheSB7XG4gIGNvbnN0cnVjdG9yICgpIHtcbiAgICB0aGlzLl9iaXRBcnJheXMgPSBbXVxuICAgIHRoaXMuX2RhdGEgPSBbXVxuICAgIHRoaXMuX2xlbmd0aCA9IDBcbiAgICB0aGlzLl9jaGFuZ2VkTGVuZ3RoID0gZmFsc2VcbiAgICB0aGlzLl9jaGFuZ2VkRGF0YSA9IGZhbHNlXG4gIH1cblxuICBzZXQgKGluZGV4LCB2YWx1ZSkge1xuICAgIGxldCBwb3MgPSB0aGlzLl9pbnRlcm5hbFBvc2l0aW9uRm9yKGluZGV4LCBmYWxzZSlcbiAgICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgLy8gdW5zZXR0aW5nXG4gICAgICBpZiAocG9zICE9PSAtMSkge1xuICAgICAgICAvLyByZW1vdmUgaXRlbSBmcm9tIGJpdCBhcnJheSBhbmQgYXJyYXkgaXRzZWxmXG4gICAgICAgIHRoaXMuX3Vuc2V0SW50ZXJuYWxQb3MocG9zKVxuICAgICAgICB0aGlzLl91bnNldEJpdChpbmRleClcbiAgICAgICAgdGhpcy5fY2hhbmdlZExlbmd0aCA9IHRydWVcbiAgICAgICAgdGhpcy5fY2hhbmdlZERhdGEgPSB0cnVlXG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGxldCBuZWVkc1NvcnQgPSBmYWxzZVxuICAgICAgaWYgKHBvcyA9PT0gLTEpIHtcbiAgICAgICAgcG9zID0gdGhpcy5fZGF0YS5sZW5ndGhcbiAgICAgICAgdGhpcy5fc2V0Qml0KGluZGV4KVxuICAgICAgICB0aGlzLl9jaGFuZ2VkRGF0YSA9IHRydWVcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG5lZWRzU29ydCA9IHRydWVcbiAgICAgIH1cbiAgICAgIHRoaXMuX3NldEludGVybmFsUG9zKHBvcywgaW5kZXgsIHZhbHVlLCBuZWVkc1NvcnQpXG4gICAgICB0aGlzLl9jaGFuZ2VkTGVuZ3RoID0gdHJ1ZVxuICAgIH1cbiAgfVxuXG4gIHVuc2V0IChpbmRleCkge1xuICAgIHRoaXMuc2V0KGluZGV4LCB1bmRlZmluZWQpXG4gIH1cblxuICBnZXQgKGluZGV4KSB7XG4gICAgdGhpcy5fc29ydERhdGEoKVxuICAgIGNvbnN0IHBvcyA9IHRoaXMuX2ludGVybmFsUG9zaXRpb25Gb3IoaW5kZXgsIHRydWUpXG4gICAgaWYgKHBvcyA9PT0gLTEpIHtcbiAgICAgIHJldHVybiB1bmRlZmluZWRcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX2RhdGFbcG9zXVsxXVxuICB9XG5cbiAgcHVzaCAodmFsdWUpIHtcbiAgICB0aGlzLnNldCh0aGlzLmxlbmd0aCwgdmFsdWUpXG4gICAgcmV0dXJuIHRoaXMubGVuZ3RoXG4gIH1cblxuICBnZXQgbGVuZ3RoICgpIHtcbiAgICB0aGlzLl9zb3J0RGF0YSgpXG4gICAgaWYgKHRoaXMuX2NoYW5nZWRMZW5ndGgpIHtcbiAgICAgIGNvbnN0IGxhc3QgPSB0aGlzLl9kYXRhW3RoaXMuX2RhdGEubGVuZ3RoIC0gMV1cbiAgICAgIHRoaXMuX2xlbmd0aCA9IGxhc3QgPyBsYXN0WzBdICsgMSA6IDBcbiAgICAgIHRoaXMuX2NoYW5nZWRMZW5ndGggPSBmYWxzZVxuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fbGVuZ3RoXG4gIH1cblxuICBmb3JFYWNoIChpdGVyYXRvcikge1xuICAgIGxldCBpID0gMFxuICAgIHdoaWxlKGkgPCB0aGlzLmxlbmd0aCkge1xuICAgICAgaXRlcmF0b3IodGhpcy5nZXQoaSksIGksIHRoaXMpXG4gICAgICBpKytcbiAgICB9XG4gIH1cblxuICBtYXAgKGl0ZXJhdG9yKSB7XG4gICAgbGV0IGkgPSAwXG4gICAgbGV0IG1hcHBlZCA9IG5ldyBBcnJheSh0aGlzLmxlbmd0aClcbiAgICB3aGlsZShpIDwgdGhpcy5sZW5ndGgpIHtcbiAgICAgIG1hcHBlZFtpXSA9IGl0ZXJhdG9yKHRoaXMuZ2V0KGkpLCBpLCB0aGlzKVxuICAgICAgaSsrXG4gICAgfVxuICAgIHJldHVybiBtYXBwZWRcbiAgfVxuXG4gIHJlZHVjZSAocmVkdWNlciwgaW5pdGlhbFZhbHVlKSB7XG4gICAgbGV0IGkgPSAwXG4gICAgbGV0IGFjYyA9IGluaXRpYWxWYWx1ZVxuICAgIHdoaWxlKGkgPCB0aGlzLmxlbmd0aCkge1xuICAgICAgY29uc3QgdmFsdWUgPSB0aGlzLmdldChpKVxuICAgICAgYWNjID0gcmVkdWNlcihhY2MsIHZhbHVlLCBpKVxuICAgICAgaSsrXG4gICAgfVxuICAgIHJldHVybiBhY2NcbiAgfVxuXG4gIGZpbmQgKGZpbmRlcikge1xuICAgIGxldCBpID0gMCwgZm91bmQsIGxhc3RcbiAgICB3aGlsZSAoKGkgPCB0aGlzLmxlbmd0aCkgJiYgIWZvdW5kKSB7XG4gICAgICBsYXN0ID0gdGhpcy5nZXQoaSlcbiAgICAgIGZvdW5kID0gZmluZGVyKGxhc3QpXG4gICAgICBpKytcbiAgICB9XG4gICAgcmV0dXJuIGZvdW5kID8gbGFzdCA6IHVuZGVmaW5lZFxuICB9XG5cbiAgX2ludGVybmFsUG9zaXRpb25Gb3IgKGluZGV4LCBub0NyZWF0ZSkge1xuICAgIGNvbnN0IGJ5dGVQb3MgPSB0aGlzLl9ieXRlUG9zRm9yKGluZGV4LCBub0NyZWF0ZSlcbiAgICBpZiAoYnl0ZVBvcyA+PSB0aGlzLl9iaXRBcnJheXMubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gLTFcbiAgICB9XG4gICAgY29uc3QgYnl0ZSA9IHRoaXMuX2JpdEFycmF5c1tieXRlUG9zXVxuICAgIGNvbnN0IGJpdFBvcyA9IGluZGV4IC0gYnl0ZVBvcyAqIEJJVFNfUEVSX0JZVEVcbiAgICBjb25zdCBleGlzdHMgPSAoYnl0ZSAmICgxIDw8IGJpdFBvcykpID4gMFxuICAgIGlmICghZXhpc3RzKSB7XG4gICAgICByZXR1cm4gLTFcbiAgICB9XG4gICAgY29uc3QgcHJldmlvdXNQb3BDb3VudCA9IHRoaXMuX2JpdEFycmF5cy5zbGljZSgwLCBieXRlUG9zKS5yZWR1Y2UocG9wQ291bnRSZWR1Y2UsIDApXG5cbiAgICBjb25zdCBtYXNrID0gfigweGZmZmZmZmZmIDw8IChiaXRQb3MgKyAxKSlcbiAgICBjb25zdCBieXRlUG9wQ291bnQgPSBwb3BDb3VudChieXRlICYgbWFzaylcbiAgICBjb25zdCBhcnJheVBvcyA9IHByZXZpb3VzUG9wQ291bnQgKyBieXRlUG9wQ291bnQgLSAxXG4gICAgcmV0dXJuIGFycmF5UG9zXG4gIH1cblxuICBfYnl0ZVBvc0ZvciAoaW5kZXgsIG5vQ3JlYXRlKSB7XG4gICAgY29uc3QgYnl0ZVBvcyA9IE1hdGguZmxvb3IoaW5kZXggLyBCSVRTX1BFUl9CWVRFKVxuICAgIGNvbnN0IHRhcmdldExlbmd0aCA9IGJ5dGVQb3MgKyAxXG4gICAgd2hpbGUgKCFub0NyZWF0ZSAmJiB0aGlzLl9iaXRBcnJheXMubGVuZ3RoIDwgdGFyZ2V0TGVuZ3RoKSB7XG4gICAgICB0aGlzLl9iaXRBcnJheXMucHVzaCgwKVxuICAgIH1cbiAgICByZXR1cm4gYnl0ZVBvc1xuICB9XG5cbiAgX3NldEJpdCAoaW5kZXgpIHtcbiAgICBjb25zdCBieXRlUG9zID0gdGhpcy5fYnl0ZVBvc0ZvcihpbmRleCwgZmFsc2UpXG4gICAgdGhpcy5fYml0QXJyYXlzW2J5dGVQb3NdIHw9ICgxIDw8IChpbmRleCAtIChieXRlUG9zICogQklUU19QRVJfQllURSkpKVxuICB9XG5cbiAgX3Vuc2V0Qml0KGluZGV4KSB7XG4gICAgY29uc3QgYnl0ZVBvcyA9IHRoaXMuX2J5dGVQb3NGb3IoaW5kZXgsIGZhbHNlKVxuICAgIHRoaXMuX2JpdEFycmF5c1tieXRlUG9zXSAmPSB+KDEgPDwgKGluZGV4IC0gKGJ5dGVQb3MgKiBCSVRTX1BFUl9CWVRFKSkpXG4gIH1cblxuICBfc2V0SW50ZXJuYWxQb3MocG9zLCBpbmRleCwgdmFsdWUsIG5lZWRzU29ydCkge1xuICAgIGNvbnN0IGRhdGEgPXRoaXMuX2RhdGFcbiAgICBjb25zdCBlbGVtID0gW2luZGV4LCB2YWx1ZV1cbiAgICBpZiAobmVlZHNTb3J0KSB7XG4gICAgICB0aGlzLl9zb3J0RGF0YSgpXG4gICAgICBkYXRhW3Bvc10gPSBlbGVtXG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIG5ldyBlbGVtZW50LiBqdXN0IHNob3ZlIGl0IGludG8gdGhlIGFycmF5XG4gICAgICAvLyBidXQgYmUgbmljZSBhYm91dCB3aGVyZSB3ZSBzaG92ZSBpdFxuICAgICAgLy8gaW4gb3JkZXIgdG8gbWFrZSBzb3J0aW5nIGl0IGxhdGVyIGVhc2llclxuICAgICAgaWYgKGRhdGEubGVuZ3RoKSB7XG4gICAgICAgIGlmIChkYXRhW2RhdGEubGVuZ3RoIC0gMV1bMF0gPj0gaW5kZXgpIHtcbiAgICAgICAgICBkYXRhLnB1c2goZWxlbSlcbiAgICAgICAgfSBlbHNlIGlmIChkYXRhWzBdWzBdIDw9IGluZGV4KSB7XG4gICAgICAgICAgZGF0YS51bnNoaWZ0KGVsZW0pXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY29uc3QgcmFuZG9tSW5kZXggPSBNYXRoLnJvdW5kKGRhdGEubGVuZ3RoIC8gMilcbiAgICAgICAgICB0aGlzLl9kYXRhID0gZGF0YS5zbGljZSgwLCByYW5kb21JbmRleCkuY29uY2F0KGVsZW0pLmNvbmNhdChkYXRhLnNsaWNlKHJhbmRvbUluZGV4KSlcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5fZGF0YS5wdXNoKGVsZW0pXG4gICAgICB9XG4gICAgICB0aGlzLl9jaGFuZ2VkRGF0YSA9IHRydWVcbiAgICAgIHRoaXMuX2NoYW5nZWRMZW5ndGggPSB0cnVlXG4gICAgfVxuICB9XG5cbiAgX3Vuc2V0SW50ZXJuYWxQb3MgKHBvcykge1xuICAgIHRoaXMuX2RhdGEuc3BsaWNlKHBvcywgMSlcbiAgfVxuXG4gIF9zb3J0RGF0YSAoKSB7XG4gICAgaWYgKHRoaXMuX2NoYW5nZWREYXRhKSB7XG4gICAgICB0aGlzLl9kYXRhLnNvcnQoc29ydEludGVybmFsKVxuICAgIH1cblxuICAgIHRoaXMuX2NoYW5nZWREYXRhID0gZmFsc2VcbiAgfVxuXG4gIGJpdEZpZWxkICgpIHtcbiAgICBjb25zdCBieXRlcyA9IFtdXG4gICAgbGV0IHBlbmRpbmdCaXRzRm9yUmVzdWx0aW5nQnl0ZSA9IDhcbiAgICBsZXQgcGVuZGluZ0JpdHNGb3JOZXdCeXRlID0gMFxuICAgIGxldCByZXN1bHRpbmdCeXRlID0gMFxuICAgIGxldCBuZXdCeXRlXG4gICAgY29uc3QgcGVuZGluZyA9IHRoaXMuX2JpdEFycmF5cy5zbGljZSgpXG4gICAgd2hpbGUgKHBlbmRpbmcubGVuZ3RoIHx8IHBlbmRpbmdCaXRzRm9yTmV3Qnl0ZSkge1xuICAgICAgaWYgKHBlbmRpbmdCaXRzRm9yTmV3Qnl0ZSA9PT0gMCkge1xuICAgICAgICBuZXdCeXRlID0gcGVuZGluZy5zaGlmdCgpXG4gICAgICAgIHBlbmRpbmdCaXRzRm9yTmV3Qnl0ZSA9IDdcbiAgICAgIH1cblxuICAgICAgY29uc3QgdXNpbmdCaXRzID0gTWF0aC5taW4ocGVuZGluZ0JpdHNGb3JOZXdCeXRlLCBwZW5kaW5nQml0c0ZvclJlc3VsdGluZ0J5dGUpXG4gICAgICBjb25zdCBtYXNrID0gfigwYjExMTExMTExIDw8IHVzaW5nQml0cylcbiAgICAgIGNvbnN0IG1hc2tlZCA9IG5ld0J5dGUgJiBtYXNrXG4gICAgICByZXN1bHRpbmdCeXRlIHw9IG1hc2tlZCA8PCAoOCAtIHBlbmRpbmdCaXRzRm9yUmVzdWx0aW5nQnl0ZSlcbiAgICAgIG5ld0J5dGUgPSBuZXdCeXRlID4+PiB1c2luZ0JpdHNcbiAgICAgIHBlbmRpbmdCaXRzRm9yTmV3Qnl0ZSAtPSB1c2luZ0JpdHNcbiAgICAgIHBlbmRpbmdCaXRzRm9yUmVzdWx0aW5nQnl0ZSAtPSB1c2luZ0JpdHNcblxuICAgICAgaWYgKCFwZW5kaW5nQml0c0ZvclJlc3VsdGluZ0J5dGUgfHwgKCFwZW5kaW5nQml0c0Zvck5ld0J5dGUgJiYgIXBlbmRpbmcubGVuZ3RoKSkge1xuICAgICAgICBieXRlcy5wdXNoKHJlc3VsdGluZ0J5dGUpXG4gICAgICAgIHJlc3VsdGluZ0J5dGUgPSAwXG4gICAgICAgIHBlbmRpbmdCaXRzRm9yUmVzdWx0aW5nQnl0ZSA9IDhcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyByZW1vdmUgdHJhaWxpbmcgemVyb2VzXG4gICAgZm9yKHZhciBpID0gYnl0ZXMubGVuZ3RoIC0gMTsgaSA+IDA7IGktLSkge1xuICAgICAgY29uc3QgdmFsdWUgPSBieXRlc1tpXVxuICAgICAgaWYgKHZhbHVlID09PSAwKSB7XG4gICAgICAgIGJ5dGVzLnBvcCgpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBicmVha1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBieXRlc1xuICB9XG5cbiAgY29tcGFjdEFycmF5ICgpIHtcbiAgICB0aGlzLl9zb3J0RGF0YSgpXG4gICAgcmV0dXJuIHRoaXMuX2RhdGEubWFwKHZhbHVlT25seSlcbiAgfVxufVxuXG5mdW5jdGlvbiBwb3BDb3VudFJlZHVjZSAoY291bnQsIGJ5dGUpIHtcbiAgcmV0dXJuIGNvdW50ICsgcG9wQ291bnQoYnl0ZSlcbn1cblxuZnVuY3Rpb24gcG9wQ291bnQoX3YpIHtcbiAgbGV0IHYgPSBfdlxuICB2ID0gdiAtICgodiA+PiAxKSAmIDB4NTU1NTU1NTUpICAgICAgICAgICAgICAgICAgICAvLyByZXVzZSBpbnB1dCBhcyB0ZW1wb3JhcnlcbiAgdiA9ICh2ICYgMHgzMzMzMzMzMykgKyAoKHYgPj4gMikgJiAweDMzMzMzMzMzKSAgICAgLy8gdGVtcFxuICByZXR1cm4gKCh2ICsgKHYgPj4gNCkgJiAweEYwRjBGMEYpICogMHgxMDEwMTAxKSA+PiAyNFxufVxuXG5mdW5jdGlvbiBzb3J0SW50ZXJuYWwgKGEsIGIpIHtcbiAgcmV0dXJuIGFbMF0gLSBiWzBdXG59XG5cbmZ1bmN0aW9uIHZhbHVlT25seSAoZWxlbSkge1xuICByZXR1cm4gZWxlbVsxXVxufSJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/sparse-array/index.js\n");

/***/ })

};
;