exports.id=482,exports.ids=[482],exports.modules={4515:(e,t,r)=>{"use strict";r.d(t,{WalletProvider:()=>a,v:()=>l});var n=r(6662),s=r(82407),i=r(2651);r(43055);let o=(0,s.createContext)(void 0);function a({children:e}){let[t,r]=(0,s.useState)(!1),[a,l]=(0,s.useState)(null),[c,d]=(0,s.useState)(null),[u,p]=(0,s.useState)(null),h=async()=>{try{console.log("[v0] Initiating FCL authentication..."),await i.authenticate()}catch(e){throw console.error("[v0] Wallet connection error:",e),e}};return(0,n.jsx)(o.Provider,{value:{isConnected:t,user:a,flowUser:c,connect:h,disconnect:()=>{console.log("[v0] Disconnecting wallet..."),i.unauthenticate(),l(null),r(!1),p(null),localStorage.removeItem("ownly_user")},address:u},children:e})}function l(){let e=(0,s.useContext)(o);if(void 0===e)throw Error("useWallet must be used within a WalletProvider");return e}},8063:(e,t,r)=>{"use strict";r.d(t,{eventHandlerRegistry:()=>c,uS:()=>d});var n=r(26892);class s{async handle(e){if(e.type===n.Ru.COLLECTIBLE_MINTED){console.log("[CollectibleMintedHandler] Processing mint event:",e);try{let{nftId:t,recipient:r,collectionId:n,metadataUrl:s,creator:i}=e.data;if(!t||!r){console.error("[CollectibleMintedHandler] Missing required data:",e.data);return}await this.processMintEvent({nftId:t,recipient:r,collectionId:n,metadataUrl:s,creator:i,transactionId:e.transactionId,blockHeight:e.blockHeight,timestamp:e.timestamp}),console.log("[CollectibleMintedHandler] Successfully processed mint event for NFT:",t)}catch(e){throw console.error("[CollectibleMintedHandler] Error processing mint event:",e),e}}}async processMintEvent(e){console.log("[CollectibleMintedHandler] New NFT minted:",{id:e.nftId,owner:e.recipient,collection:e.collectionId,metadata:e.metadataUrl,creator:e.creator,mintedAt:e.timestamp}),this.notifyUIUpdate("mint",{nftId:e.nftId,owner:e.recipient,type:"mint",transactionId:e.transactionId}),"ownly_collectibles"===e.collectionId&&await this.updateOwnlyCollectionCache(e)}async updateOwnlyCollectionCache(e){console.log("[CollectibleMintedHandler] Updating Ownly collection cache for NFT:",e.nftId)}notifyUIUpdate(e,t){}}class i{async handle(e){if(e.type===n.Ru.COLLECTIBLE_TRANSFERRED){console.log("[CollectibleTransferredHandler] Processing transfer event:",e);try{let{nftId:t,from:r,to:n,collectionId:s}=e.data;if(!t||!r||!n){console.error("[CollectibleTransferredHandler] Missing required data:",e.data);return}await this.processTransferEvent({nftId:t,from:r,to:n,collectionId:s,transactionId:e.transactionId,blockHeight:e.blockHeight,timestamp:e.timestamp}),console.log("[CollectibleTransferredHandler] Successfully processed transfer event for NFT:",t)}catch(e){throw console.error("[CollectibleTransferredHandler] Error processing transfer event:",e),e}}}async processTransferEvent(e){console.log("[CollectibleTransferredHandler] NFT transferred:",{id:e.nftId,from:e.from,to:e.to,collection:e.collectionId,transferredAt:e.timestamp}),await this.updateOwnershipCache(e.nftId,e.from,e.to),this.notifyUIUpdate("transfer",{nftId:e.nftId,from:e.from,to:e.to,type:"transfer",transactionId:e.transactionId}),await this.updateUserCollections(e.from,e.to,e.nftId)}async updateOwnershipCache(e,t,r){console.log("[CollectibleTransferredHandler] Updating ownership cache:",{nftId:e,from:t,to:r})}async updateUserCollections(e,t,r){console.log("[CollectibleTransferredHandler] Updating user collections:",{from:e,to:t,nftId:r})}notifyUIUpdate(e,t){}}class o{async handle(e){if(e.type===n.Ru.SALE_COMPLETED){console.log("[MarketplaceSaleHandler] Processing sale event:",e);try{let{nftId:t,seller:r,buyer:n,price:s,currency:i}=e.data;if(!t||!r||!n||!s){console.error("[MarketplaceSaleHandler] Missing required data:",e.data);return}await this.processSaleEvent({nftId:t,seller:r,buyer:n,price:s,currency:i||"FLOW",transactionId:e.transactionId,blockHeight:e.blockHeight,timestamp:e.timestamp}),console.log("[MarketplaceSaleHandler] Successfully processed sale event for NFT:",t)}catch(e){throw console.error("[MarketplaceSaleHandler] Error processing sale event:",e),e}}}async processSaleEvent(e){console.log("[MarketplaceSaleHandler] NFT sale completed:",{id:e.nftId,seller:e.seller,buyer:e.buyer,price:e.price,currency:e.currency,soldAt:e.timestamp}),await this.updateMarketplaceListings(e.nftId),await this.updateOwnershipRecords(e.nftId,e.seller,e.buyer),await this.recordTransactionHistory(e),this.notifyUIUpdate("sale",{nftId:e.nftId,seller:e.seller,buyer:e.buyer,price:e.price,currency:e.currency,type:"sale",transactionId:e.transactionId})}async updateMarketplaceListings(e){console.log("[MarketplaceSaleHandler] Removing NFT from marketplace listings:",e)}async updateOwnershipRecords(e,t,r){console.log("[MarketplaceSaleHandler] Updating ownership records:",{nftId:e,seller:t,buyer:r})}async recordTransactionHistory(e){console.log("[MarketplaceSaleHandler] Recording transaction history:",e)}notifyUIUpdate(e,t){}}class a{async handle(e){if(e.type===n.Ru.LISTING_CREATED){console.log("[MarketplaceListingHandler] Processing listing event:",e);try{let{nftId:t,seller:r,price:n,currency:s,listingId:i}=e.data;if(!t||!r||!n){console.error("[MarketplaceListingHandler] Missing required data:",e.data);return}await this.processListingEvent({nftId:t,seller:r,price:n,currency:s||"FLOW",listingId:i,transactionId:e.transactionId,blockHeight:e.blockHeight,timestamp:e.timestamp}),console.log("[MarketplaceListingHandler] Successfully processed listing event for NFT:",t)}catch(e){throw console.error("[MarketplaceListingHandler] Error processing listing event:",e),e}}}async processListingEvent(e){console.log("[MarketplaceListingHandler] New NFT listing created:",{id:e.nftId,seller:e.seller,price:e.price,currency:e.currency,listingId:e.listingId,listedAt:e.timestamp}),await this.addToMarketplaceListings(e),await this.updateNFTStatus(e.nftId,"for_sale"),this.notifyUIUpdate("listing",{nftId:e.nftId,seller:e.seller,price:e.price,currency:e.currency,listingId:e.listingId,type:"listing",transactionId:e.transactionId})}async addToMarketplaceListings(e){console.log("[MarketplaceListingHandler] Adding NFT to marketplace listings:",e.nftId)}async updateNFTStatus(e,t){console.log("[MarketplaceListingHandler] Updating NFT status:",{nftId:e,status:t})}notifyUIUpdate(e,t){}}class l{registerHandler(e,t){this.handlers.has(e)||this.handlers.set(e,[]),this.handlers.get(e).push(t),console.log(`[EventHandlerRegistry] Registered handler for ${e}`)}async processEvent(e){let t=this.handlers.get(e.type)||[];if(0===t.length){console.warn(`[EventHandlerRegistry] No handlers registered for event type: ${e.type}`);return}console.log(`[EventHandlerRegistry] Processing event ${e.type} with ${t.length} handlers`);let r=t.map(t=>t.handle(e));try{await Promise.all(r),console.log(`[EventHandlerRegistry] Successfully processed event ${e.type}`)}catch(t){throw console.error(`[EventHandlerRegistry] Error processing event ${e.type}:`,t),t}}getRegisteredEventTypes(){return Array.from(this.handlers.keys())}getHandlerCount(e){return this.handlers.get(e)?.length||0}constructor(){this.handlers=new Map}}let c=new l;function d(){console.log("[EventHandlers] Initializing default event handlers"),c.registerHandler(n.Ru.COLLECTIBLE_MINTED,new s),c.registerHandler(n.Ru.COLLECTIBLE_TRANSFERRED,new i),c.registerHandler(n.Ru.SALE_COMPLETED,new o),c.registerHandler(n.Ru.LISTING_CREATED,new a),console.log("[EventHandlers] Default event handlers initialized")}},10596:()=>{},13293:()=>{},13757:(e,t,r)=>{Promise.resolve().then(r.t.bind(r,2617,23)),Promise.resolve().then(r.t.bind(r,18273,23)),Promise.resolve().then(r.t.bind(r,50985,23)),Promise.resolve().then(r.t.bind(r,75544,23)),Promise.resolve().then(r.t.bind(r,5384,23)),Promise.resolve().then(r.t.bind(r,43724,23)),Promise.resolve().then(r.t.bind(r,52322,23)),Promise.resolve().then(r.t.bind(r,93148,23))},19180:(e,t,r)=>{"use strict";r.d(t,{PerformanceInit:()=>n});let n=(0,r(71104).registerClientReference)(function(){throw Error("Attempted to call PerformanceInit() from the server but PerformanceInit is on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component.")},"/home/altcoin-daddy/Downloads/ownly/components/performance-init.tsx","PerformanceInit")},26892:(e,t,r)=>{"use strict";r.d(t,{Ru:()=>o,gL:()=>m,rY:()=>h,yx:()=>l});var n=r(2651),s=r(43055),i=r(97446);let o={COLLECTIBLE_MINTED:"CollectibleMinted",COLLECTIBLE_TRANSFERRED:"CollectibleTransferred",SALE_COMPLETED:"SaleCompleted",LISTING_CREATED:"ListingCreated",LISTING_REMOVED:"ListingRemoved"};class a{addProcessor(e,t){this.processors.set(e,t)}removeProcessor(e){this.processors.delete(e)}async enqueue(e){let t=this.queue.length;this.queue.push(e),await i.Y5.recordEventMetric({eventType:"queue_enqueue",processingTime:0,queueSize:t+1,eventSource:"internal",tags:{event_type:e.type,operation:"enqueue"}}),this.processing||await this.processQueue()}async processQueue(){for(this.processing=!0;this.queue.length>0;){let e=this.queue.shift();if(e){let t=this.processors.get(e.type);if(t){let r=performance.now();try{await t(e);let n=performance.now()-r;await i.Y5.recordEventMetric({eventType:e.type,processingTime:n,queueSize:this.queue.length,eventSource:this.getEventSource(e),blockHeight:e.blockHeight,transactionId:e.transactionId,tags:{success:"true",processor:e.type}})}catch(n){let t=performance.now()-r;await i.Y5.recordEventMetric({eventType:e.type,processingTime:t,queueSize:this.queue.length,eventSource:this.getEventSource(e),blockHeight:e.blockHeight,transactionId:e.transactionId,tags:{success:"false",processor:e.type,error:n instanceof Error?n.message:"unknown"}}),console.error(`[EventQueue] Error processing event ${e.type}:`,n)}}}}this.processing=!1}getEventSource(e){return e.transactionId?"flow":e.type.includes("Dapper")?"dapper":"internal"}getQueueSize(){return this.queue.length}constructor(){this.queue=[],this.processing=!1,this.processors=new Map}}let l=new a,c=null;async function d(){if(!c){let{eventHandlerRegistry:e}=await Promise.resolve().then(r.bind(r,8063));c=e}return c}async function u(e){try{let t=await d();await t.processEvent(e)}catch(e){console.error("[FlowEvents] Error processing event through handlers:",e)}}class p{subscribeToMintEvents(e){let t=(0,s.RZ)("DapperCollectibles"),r=`A.${t.replace("0x","")}.DapperCollectibles.CollectibleMinted`;console.log("[FlowEventListener] Subscribing to mint events:",r);let i=n.events(r).subscribe({next:t=>{console.log("[FlowEventListener] Mint event received:",t);let r={type:o.COLLECTIBLE_MINTED,transactionId:t.transactionId,blockHeight:t.blockHeight,eventIndex:t.eventIndex,data:this.parseMintEventData(t.data),timestamp:new Date};l.enqueue(r),u(r),e(r)},error:t=>{console.error("[FlowEventListener] Mint event subscription error:",t),this.handleSubscriptionError("mint",()=>this.subscribeToMintEvents(e))}});return this.subscriptions.set("mint",i),this.reconnectAttempts=0,i}subscribeToTransferEvents(e){let t=(0,s.RZ)("DapperCollectibles"),r=`A.${t.replace("0x","")}.DapperCollectibles.CollectibleTransferred`;console.log("[FlowEventListener] Subscribing to transfer events:",r);let i=n.events(r).subscribe({next:t=>{console.log("[FlowEventListener] Transfer event received:",t);let r={type:o.COLLECTIBLE_TRANSFERRED,transactionId:t.transactionId,blockHeight:t.blockHeight,eventIndex:t.eventIndex,data:this.parseTransferEventData(t.data),timestamp:new Date};l.enqueue(r),u(r),e(r)},error:t=>{console.error("[FlowEventListener] Transfer event subscription error:",t),this.handleSubscriptionError("transfer",()=>this.subscribeToTransferEvents(e))}});return this.subscriptions.set("transfer",i),this.reconnectAttempts=0,i}parseMintEventData(e){try{return{nftId:e.id?.value||e.id,recipient:e.to?.value||e.to,collectionId:e.collectionId?.value||e.collectionId,metadataUrl:e.metadataUrl?.value||e.metadataUrl,creator:e.creator?.value||e.creator,rawData:e}}catch(t){return console.error("[FlowEventListener] Error parsing mint event data:",t),{rawData:e}}}parseTransferEventData(e){try{return{nftId:e.id?.value||e.id,from:e.from?.value||e.from,to:e.to?.value||e.to,collectionId:e.collectionId?.value||e.collectionId,rawData:e}}catch(t){return console.error("[FlowEventListener] Error parsing transfer event data:",t),{rawData:e}}}handleSubscriptionError(e,t){if(this.reconnectAttempts>=this.maxReconnectAttempts){console.error(`[FlowEventListener] Max reconnection attempts reached for ${e} events`);return}this.reconnectAttempts++;let r=this.reconnectDelay*Math.pow(2,this.reconnectAttempts-1);console.log(`[FlowEventListener] Attempting to reconnect ${e} events in ${r}ms (attempt ${this.reconnectAttempts})`),setTimeout(()=>{try{t()}catch(t){console.error(`[FlowEventListener] Reconnection failed for ${e}:`,t)}},r)}unsubscribeAll(){console.log("[FlowEventListener] Unsubscribing from all events"),this.subscriptions.forEach((e,t)=>{try{e(),console.log(`[FlowEventListener] Unsubscribed from ${t} events`)}catch(e){console.error(`[FlowEventListener] Error unsubscribing from ${t} events:`,e)}}),this.subscriptions.clear(),this.reconnectAttempts=0}getActiveSubscriptions(){return Array.from(this.subscriptions.keys())}constructor(){this.subscriptions=new Map,this.reconnectAttempts=0,this.maxReconnectAttempts=5,this.reconnectDelay=1e3}}let h=new p;function g(e,t){try{if("sale"===t)return{nftId:e.nftId?.value||e.nftId,seller:e.seller?.value||e.seller,buyer:e.buyer?.value||e.buyer,price:e.price?.value||e.price,currency:e.currency?.value||e.currency||"FLOW",rawData:e};return{nftId:e.nftId?.value||e.nftId,seller:e.seller?.value||e.seller,price:e.price?.value||e.price,currency:e.currency?.value||e.currency||"FLOW",listingId:e.listingId?.value||e.listingId,rawData:e}}catch(r){return console.error(`[FlowEventListener] Error parsing ${t} event data:`,r),{rawData:e}}}function m(e){let t=[];return console.log("[FlowEventListener] Setting up comprehensive event subscriptions"),e.onMint&&t.push(h.subscribeToMintEvents(e.onMint)),e.onTransfer&&t.push(h.subscribeToTransferEvents(e.onTransfer)),(e.onSale||e.onListing)&&t.push(function(e){let t=(0,s.RZ)("DapperMarket"),r=[];if(e.onSale){let s=`A.${t.replace("0x","")}.DapperMarket.SaleCompleted`;console.log("[FlowEventListener] Subscribing to marketplace sale events:",s);let i=n.events(s).subscribe({next:t=>{console.log("[FlowEventListener] Sale event received:",t);let r={type:o.SALE_COMPLETED,transactionId:t.transactionId,blockHeight:t.blockHeight,eventIndex:t.eventIndex,data:g(t.data,"sale"),timestamp:new Date};l.enqueue(r),u(r),e.onSale(r)},error:e=>{console.error("[FlowEventListener] Sale event subscription error:",e)}});r.push(i)}if(e.onListing){let s=`A.${t.replace("0x","")}.DapperMarket.ListingCreated`;console.log("[FlowEventListener] Subscribing to marketplace listing events:",s);let i=n.events(s).subscribe({next:t=>{console.log("[FlowEventListener] Listing event received:",t);let r={type:o.LISTING_CREATED,transactionId:t.transactionId,blockHeight:t.blockHeight,eventIndex:t.eventIndex,data:g(t.data,"listing"),timestamp:new Date};l.enqueue(r),u(r),e.onListing(r)},error:e=>{console.error("[FlowEventListener] Listing event subscription error:",e)}});r.push(i)}return()=>{console.log("[FlowEventListener] Unsubscribing from marketplace events"),r.forEach(e=>e())}}({onSale:e.onSale,onListing:e.onListing})),e.onMint&&l.addProcessor(o.COLLECTIBLE_MINTED,e.onMint),e.onTransfer&&l.addProcessor(o.COLLECTIBLE_TRANSFERRED,e.onTransfer),e.onSale&&l.addProcessor(o.SALE_COMPLETED,e.onSale),e.onListing&&l.addProcessor(o.LISTING_CREATED,e.onListing),()=>{console.log("[FlowEventListener] Unsubscribing from all events and clearing processors"),t.forEach(e=>{try{e()}catch(e){console.error("[FlowEventListener] Error during unsubscribe:",e)}}),Object.values(o).forEach(e=>{l.removeProcessor(e)})}}},28687:(e,t,r)=>{"use strict";r.d(t,{PerformanceInit:()=>l}),r(82407);var n=r(97446),s=r(26892);class i{constructor(e){this.processingTimes=new Map,this.originalQueue=e,this.wrapQueueMethods()}wrapQueueMethods(){let e=this.originalQueue.enqueue.bind(this.originalQueue);this.originalQueue.enqueue=async t=>{let r=this.originalQueue.getQueueSize();return await n.Y5.recordEventMetric({eventType:"queue_size",processingTime:0,queueSize:r+1,eventSource:"internal",tags:{operation:"enqueue",event_type:t.type}}),e(t)};let t=this.originalQueue.addProcessor.bind(this.originalQueue);this.originalQueue.addProcessor=(e,r)=>{let s=async t=>{let s=performance.now();try{await r(t);let i=performance.now()-s;await n.Y5.recordEventMetric({eventType:t.type,processingTime:i,queueSize:this.originalQueue.getQueueSize(),eventSource:this.getEventSource(t),blockHeight:t.blockHeight,transactionId:t.transactionId,tags:{processor:e,success:"true"}}),this.processingTimes.set(t.type,i)}catch(i){let r=performance.now()-s;throw await n.Y5.recordEventMetric({eventType:t.type,processingTime:r,queueSize:this.originalQueue.getQueueSize(),eventSource:this.getEventSource(t),blockHeight:t.blockHeight,transactionId:t.transactionId,tags:{processor:e,success:"false",error:i instanceof Error?i.message:"unknown"}}),i}};return t(e,s)}}getEventSource(e){return e.transactionId?"flow":e.type.includes("Dapper")?"dapper":"internal"}getAverageProcessingTime(e){return this.processingTimes.get(e)}getAllProcessingTimes(){return new Map(this.processingTimes)}clearProcessingTimes(){this.processingTimes.clear()}}class o{markEventStart(e,t){this.eventStartTimes.set(e,performance.now())}async markEventEnd(e,t){let r=this.eventStartTimes.get(e);if(!r)return null;let s=performance.now()-r;return this.eventStartTimes.delete(e),this.latencyHistory.push({eventType:t,latency:s,timestamp:new Date}),this.latencyHistory.length>1e3&&this.latencyHistory.shift(),await n.Y5.recordEventMetric({eventType:`${t}_latency`,processingTime:s,queueSize:0,eventSource:"internal",tags:{metric_type:"latency",event_id:e}}),s}getLatencyStats(e){let t=this.latencyHistory.filter(t=>t.eventType===e);if(0===t.length)return null;let r=t.map(e=>e.latency).sort((e,t)=>e-t),n=r.length,s=r.reduce((e,t)=>e+t,0),i=r[0],o=r[r.length-1],a=Math.floor(.95*n),l=Math.floor(.99*n),c=r[Math.min(a,n-1)],d=r[Math.min(l,n-1)];return{count:n,average:Math.round(s/n*100)/100,min:i,max:o,p95:c,p99:d}}getRecentLatency(e,t=100){let r=this.latencyHistory;return e&&(r=r.filter(t=>t.eventType===e)),r.sort((e,t)=>t.timestamp.getTime()-e.timestamp.getTime()).slice(0,t)}clearHistory(){this.latencyHistory=[],this.eventStartTimes.clear()}constructor(){this.eventStartTimes=new Map,this.latencyHistory=[]}}class a{subscribeWithPerformanceTracking(e,t,s="unknown"){let i=performance.now();this.subscriptionMetrics.set(s,{subscriptionTime:i,eventCount:0,errorCount:0});let o=null;return(async()=>(await Promise.resolve().then(r.bind(r,2651))).events(e).subscribe({next:async r=>{let i=`${r.transactionId}_${r.eventIndex||0}`,o=this.extractEventType(e);this.latencyMonitor.markEventStart(i,o);let a=this.subscriptionMetrics.get(s);a.eventCount++,a.lastEventTime=performance.now();try{let e={type:o,transactionId:r.transactionId,blockHeight:r.blockHeight,eventIndex:r.eventIndex,data:r.data,timestamp:new Date};await t(e),await this.latencyMonitor.markEventEnd(i,o),await n.Y5.recordEventMetric({eventType:o,processingTime:0,queueSize:0,eventSource:"flow",blockHeight:r.blockHeight,transactionId:r.transactionId,tags:{subscription_type:s,success:"true"}})}catch(e){a.errorCount++,await this.latencyMonitor.markEventEnd(i,o),await n.Y5.recordEventMetric({eventType:o,processingTime:0,queueSize:0,eventSource:"flow",blockHeight:r.blockHeight,transactionId:r.transactionId,tags:{subscription_type:s,success:"false",error:e instanceof Error?e.message:"unknown"}}),console.error(`[PerformanceAwareFlowEventListener] Error processing ${o}:`,e)}},error:async t=>{let r=this.subscriptionMetrics.get(s);r&&r.errorCount++,await n.Y5.recordEventMetric({eventType:"subscription_error",processingTime:0,queueSize:0,eventSource:"flow",tags:{subscription_type:s,event_name:e,error:t instanceof Error?t.message:"unknown"}}),console.error(`[PerformanceAwareFlowEventListener] Subscription error for ${e}:`,t)}}))().then(e=>{o=e}).catch(e=>{console.error("[PerformanceAwareFlowEventListener] Failed to setup subscription:",e)}),()=>{o&&o(),this.subscriptionMetrics.delete(s)}}extractEventType(e){let t=e.split(".");return t[t.length-1]||"unknown"}getSubscriptionMetrics(e){let t=performance.now(),r=new Map;for(let[n,s]of this.subscriptionMetrics.entries()){if(e&&n!==e)continue;let i=t-s.subscriptionTime,o=s.eventCount>0?s.errorCount/s.eventCount*100:0;r.set(n,{...s,uptime:i,errorRate:Math.round(100*o)/100})}return r}getLatencyMonitor(){return this.latencyMonitor}clearMetrics(){this.subscriptionMetrics.clear(),this.latencyMonitor.clearHistory()}constructor(){this.latencyMonitor=new o,this.subscriptionMetrics=new Map}}function l(){return null}new i(s.yx),new a,new o,console.log("[Performance] Initializing performance monitoring..."),n.Y5.onAlert(e=>{console.warn(`[Performance Alert] ${e.type.toUpperCase()}: ${e.message}`)}),setInterval(()=>{n.Y5.cleanup()},36e5),console.log("[Performance] Performance monitoring initialized")},43055:(e,t,r)=>{"use strict";r.d(t,{RZ:()=>o,i7:()=>a});var n=r(2651);let s="testnet";n.config().put("app.detail.title","Ownly").put("app.detail.icon","https://ownly.app/icon.png").put("flow.network",s).put("accessNode.api","https://rest-testnet.onflow.org").put("discovery.wallet","https://fcl-discovery.onflow.org/testnet/authn").put("discovery.wallet.method","IFRAME/RPC");let i={testnet:{NonFungibleToken:"0x631e88ae7f1d7c20",MetadataViews:"0x631e88ae7f1d7c20",DapperCollectibles:"0x82ec283f88a62e65",DapperMarket:"0x94b06cfca1d8a476",NFTStorefront:"0x94b06cfca1d8a476",FungibleToken:"0x9a0766d93b6608b7",FlowToken:"0x7e60df042a9c0868"},mainnet:{NonFungibleToken:"0x1d7e57aa55817448",MetadataViews:"0x1d7e57aa55817448",DapperCollectibles:"0x82ec283f88a62e65",DapperMarket:"0x4eb8a10cb9f87357",NFTStorefront:"0x4eb8a10cb9f87357",FungibleToken:"0xf233dcee88fe0abe",FlowToken:"0x1654653399040a61"}},o=e=>i[s][e],a=process.env.NEXT_PUBLIC_NFT_STORAGE_KEY||""},43613:(e,t,r)=>{Promise.resolve().then(r.t.bind(r,4203,23)),Promise.resolve().then(r.t.bind(r,103,23)),Promise.resolve().then(r.t.bind(r,84299,23)),Promise.resolve().then(r.t.bind(r,80522,23)),Promise.resolve().then(r.t.bind(r,13022,23)),Promise.resolve().then(r.t.bind(r,17426,23)),Promise.resolve().then(r.t.bind(r,60904,23)),Promise.resolve().then(r.t.bind(r,79034,23))},45590:()=>{},47293:(e,t,r)=>{"use strict";r.d(t,{WalletProvider:()=>s});var n=r(71104);let s=(0,n.registerClientReference)(function(){throw Error("Attempted to call WalletProvider() from the server but WalletProvider is on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component.")},"/home/altcoin-daddy/Downloads/ownly/lib/wallet-context.tsx","WalletProvider");(0,n.registerClientReference)(function(){throw Error("Attempted to call useWallet() from the server but useWallet is on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component.")},"/home/altcoin-daddy/Downloads/ownly/lib/wallet-context.tsx","useWallet")},52367:()=>{},57098:(e,t,r)=>{"use strict";r.r(t),r.d(t,{default:()=>g,metadata:()=>h});var n=r(78828),s=r(75467),i=r.n(s),o=r(39363),a=r.n(o),l=r(36501),c=r(47293),d=r(91151),u=r(19180);r(13293);var p=r(19733);let h={title:"Ownly - NFT Marketplace on Flow",description:"Mint, trade, and showcase authentic digital collectibles on Flow blockchain",generator:"v0.app"};function g({children:e}){return(0,n.jsx)("html",{lang:"en",children:(0,n.jsxs)("body",{className:`font-sans ${i().variable} ${a().variable}`,children:[(0,n.jsx)(p.Suspense,{fallback:(0,n.jsx)("div",{children:"Loading..."}),children:(0,n.jsx)(c.WalletProvider,{children:(0,n.jsxs)(d.EventProvider,{children:[(0,n.jsx)(u.PerformanceInit,{}),e]})})}),(0,n.jsx)(l.Analytics,{})]})})}},60169:(e,t,r)=>{"use strict";r.d(t,{Aq:()=>a,JL:()=>c,ec:()=>u,s1:()=>l,t9:()=>d});var n=r(82407);r(2651);var s=r(74133),i=r(4515),o=r(26892);function a(){let{address:e}=(0,i.v)(),[t,r]=(0,n.useState)([]),[o,a]=(0,n.useState)(!1),[l,c]=(0,n.useState)(null);return{nfts:t,loading:o,error:l,refetch:async()=>{if(!e){r([]);return}a(!0),c(null);try{console.log("[v0] Fetching NFTs for address:",e);let t=await (0,s.HG)(s.GET_NFTS_SCRIPT,[e]);console.log("[v0] NFTs fetched:",t),r(t)}catch(e){console.error("[v0] Error fetching NFTs:",e),c(e)}finally{a(!1)}}}}function l(){let{address:e}=(0,i.v)(),[t,r]=(0,n.useState)("0"),[s,o]=(0,n.useState)(!1);return{balance:t,loading:s}}function c(e){let[t,r]=(0,n.useState)([]),[s,a]=(0,n.useState)(null),[l,c]=(0,n.useState)(!1),{address:d}=(0,i.v)();return(0,n.useRef)(!1),{events:t,latestEvent:s,isConnected:l,eventCount:t.length,activeSubscriptions:o.rY.getActiveSubscriptions()}}function d(){let{address:e}=(0,i.v)(),{nfts:t,loading:r,error:s,refetch:o}=a(),[l,d]=(0,n.useState)(0),{latestEvent:u}=c({onMint:t=>{e&&t.data.recipient===e&&(console.log("[useRealTimeNFTGallery] User minted NFT, refreshing gallery"),o(),d(e=>e+1))},onTransfer:t=>{e&&(t.data.to===e||t.data.from===e)&&(console.log("[useRealTimeNFTGallery] User involved in transfer, refreshing gallery"),o(),d(e=>e+1))},onSale:t=>{e&&(t.data.buyer===e||t.data.seller===e)&&(console.log("[useRealTimeNFTGallery] User involved in sale, refreshing gallery"),o(),d(e=>e+1))}});return{nfts:t,loading:r,error:s,refetch:o,realTimeUpdates:l,lastUpdate:u?.timestamp}}function u(){let[e,t]=(0,n.useState)([]),{latestEvent:r}=c({onMint:e=>{let r={id:`mint-${e.transactionId}`,type:"mint",message:`New NFT minted: ${e.data.nftId}`,timestamp:e.timestamp,read:!1};t(e=>[r,...e].slice(0,50))},onTransfer:e=>{let r={id:`transfer-${e.transactionId}`,type:"transfer",message:`NFT ${e.data.nftId} transferred from ${e.data.from} to ${e.data.to}`,timestamp:e.timestamp,read:!1};t(e=>[r,...e].slice(0,50))},onSale:e=>{let r={id:`sale-${e.transactionId}`,type:"sale",message:`NFT ${e.data.nftId} sold for ${e.data.price} ${e.data.currency}`,timestamp:e.timestamp,read:!1};t(e=>[r,...e].slice(0,50))},onListing:e=>{let r={id:`listing-${e.transactionId}`,type:"listing",message:`NFT ${e.data.nftId} listed for ${e.data.price} ${e.data.currency}`,timestamp:e.timestamp,read:!1};t(e=>[r,...e].slice(0,50))}}),s=(0,n.useCallback)(e=>{t(t=>t.map(t=>t.id===e?{...t,read:!0}:t))},[]),i=(0,n.useCallback)(()=>{t(e=>e.map(e=>({...e,read:!0})))},[]),o=(0,n.useCallback)(()=>{t([])},[]),a=e.filter(e=>!e.read).length;return{notifications:e,unreadCount:a,markAsRead:s,markAllAsRead:i,clearNotifications:o}}r(8063)},63881:(e,t,r)=>{"use strict";r.d(t,{EventProvider:()=>l,F0:()=>c});var n=r(6662),s=r(82407),i=r(4515),o=r(60169);let a=(0,s.createContext)(void 0);function l({children:e}){let{address:t,isConnected:r}=(0,i.v)(),[l,c]=(0,s.useState)(0),[d,u]=(0,s.useState)(0),{events:p,latestEvent:h,isConnected:g}=(0,o.JL)({onMint:e=>{console.log("[EventProvider] Mint event received:",e),t&&e.data.recipient===t&&c(e=>e+1)},onTransfer:e=>{console.log("[EventProvider] Transfer event received:",e),t&&(e.data.to===t||e.data.from===t)&&c(e=>e+1)},onSale:e=>{console.log("[EventProvider] Sale event received:",e),u(e=>e+1),t&&(e.data.buyer===t||e.data.seller===t)&&c(e=>e+1)},onListing:e=>{console.log("[EventProvider] Listing event received:",e),u(e=>e+1)}}),{notifications:m,unreadCount:f,markAsRead:v,markAllAsRead:y,clearNotifications:b}=(0,o.ec)();return(0,n.jsx)(a.Provider,{value:{latestEvent:h,events:p,isConnected:g,notifications:m,unreadCount:f,markAsRead:v,markAllAsRead:y,clearNotifications:b,galleryUpdateCount:l,marketplaceUpdateCount:d,onNFTMinted:(e,r)=>{console.log("[EventProvider] NFT minted notification:",{nftId:e,recipient:r}),t===r&&c(e=>e+1)},onNFTTransferred:(e,r,n)=>{console.log("[EventProvider] NFT transferred notification:",{nftId:e,from:r,to:n}),(t===r||t===n)&&c(e=>e+1)},onNFTSold:(e,r,n,s)=>{console.log("[EventProvider] NFT sold notification:",{nftId:e,seller:r,buyer:n,price:s}),u(e=>e+1),(t===r||t===n)&&c(e=>e+1)},onNFTListed:(e,t,r)=>{console.log("[EventProvider] NFT listed notification:",{nftId:e,seller:t,price:r}),u(e=>e+1)}},children:e})}function c(){let{latestEvent:e,galleryUpdateCount:t}=function(){let e=(0,s.useContext)(a);if(void 0===e)throw Error("useEvents must be used within an EventProvider");return e}();return{latestNFTEvent:e,galleryUpdateCount:t,isNFTEvent:e?.type.includes("COLLECTIBLE")||!1}}},64242:(e,t,r)=>{Promise.resolve().then(r.bind(r,19180)),Promise.resolve().then(r.bind(r,91151)),Promise.resolve().then(r.bind(r,47293)),Promise.resolve().then(r.bind(r,36501))},64397:()=>{},74133:(e,t,r)=>{"use strict";r.d(t,{HG:()=>c,Rf:()=>h,h8:()=>d,j$:()=>u,s5:()=>p});var n=r(2651),s=r(43055);let i=`
import NonFungibleToken from 0x${(0,s.RZ)("NonFungibleToken").replace("0x","")}
import DapperCollectibles from 0x${(0,s.RZ)("DapperCollectibles").replace("0x","")}
import MetadataViews from 0x${(0,s.RZ)("MetadataViews").replace("0x","")}

pub fun main(address: Address): [NFTData] {
  let account = getAccount(address)
  
  // Get reference to the user's DapperCollectibles collection
  let collectionRef = account.getCapability(/public/DapperCollectiblesCollection)
    .borrow<&{DapperCollectibles.CollectionPublic}>()
  
  if collectionRef == nil {
    return []
  }
  
  let ids = collectionRef!.getIDs()
  let nftData: [NFTData] = []
  
  for id in ids {
    if let nft = collectionRef!.borrowCollectible(id: id) {
      if let display = nft.resolveView(Type<MetadataViews.Display>()) as? MetadataViews.Display {
        nftData.append(NFTData(
          id: id,
          name: display.name,
          description: display.description,
          thumbnail: display.thumbnail.uri(),
          owner: address,
          collectionId: "ownly_collectibles"
        ))
      }
    }
  }
  
  return nftData
}

pub struct NFTData {
  pub let id: UInt64
  pub let name: String
  pub let description: String
  pub let thumbnail: String
  pub let owner: Address
  pub let collectionId: String
  
  init(id: UInt64, name: String, description: String, thumbnail: String, owner: Address, collectionId: String) {
    self.id = id
    self.name = name
    self.description = description
    self.thumbnail = thumbnail
    self.owner = owner
    self.collectionId = collectionId
  }
}
`,o=`
import NonFungibleToken from 0x${(0,s.RZ)("NonFungibleToken").replace("0x","")}
import DapperCollectibles from 0x${(0,s.RZ)("DapperCollectibles").replace("0x","")}
import MetadataViews from 0x${(0,s.RZ)("MetadataViews").replace("0x","")}

pub fun main(address: Address, nftID: UInt64): NFTDetails? {
  let account = getAccount(address)
  
  // Get reference to the user's DapperCollectibles collection
  let collectionRef = account.getCapability(/public/DapperCollectiblesCollection)
    .borrow<&{DapperCollectibles.CollectionPublic}>()
  
  if collectionRef == nil {
    return nil
  }
  
  if let nft = collectionRef!.borrowCollectible(id: nftID) {
    var name = ""
    var description = ""
    var thumbnail = ""
    var externalURL = ""
    var royalties: [MetadataViews.Royalty] = []
    var traits: {String: AnyStruct} = {}
    
    // Get Display metadata
    if let display = nft.resolveView(Type<MetadataViews.Display>()) as? MetadataViews.Display {
      name = display.name
      description = display.description
      thumbnail = display.thumbnail.uri()
    }
    
    // Get ExternalURL metadata
    if let extURL = nft.resolveView(Type<MetadataViews.ExternalURL>()) as? MetadataViews.ExternalURL {
      externalURL = extURL.url
    }
    
    // Get Royalties metadata
    if let royaltiesView = nft.resolveView(Type<MetadataViews.Royalties>()) as? MetadataViews.Royalties {
      royalties = royaltiesView.getRoyalties()
    }
    
    // Get Traits metadata
    if let traitsView = nft.resolveView(Type<MetadataViews.Traits>()) as? MetadataViews.Traits {
      for trait in traitsView.traits {
        traits[trait.name] = trait.value
      }
    }
    
    return NFTDetails(
      id: nftID,
      name: name,
      description: description,
      thumbnail: thumbnail,
      externalURL: externalURL,
      owner: address,
      royalties: royalties,
      traits: traits,
      collectionId: "ownly_collectibles"
    )
  }
  
  return nil
}

pub struct NFTDetails {
  pub let id: UInt64
  pub let name: String
  pub let description: String
  pub let thumbnail: String
  pub let externalURL: String
  pub let owner: Address
  pub let royalties: [MetadataViews.Royalty]
  pub let traits: {String: AnyStruct}
  pub let collectionId: String
  
  init(
    id: UInt64, 
    name: String, 
    description: String, 
    thumbnail: String, 
    externalURL: String,
    owner: Address, 
    royalties: [MetadataViews.Royalty],
    traits: {String: AnyStruct},
    collectionId: String
  ) {
    self.id = id
    self.name = name
    self.description = description
    self.thumbnail = thumbnail
    self.externalURL = externalURL
    self.owner = owner
    self.royalties = royalties
    self.traits = traits
    self.collectionId = collectionId
  }
}
`,a=`
import DapperCollectibles from 0x${(0,s.RZ)("DapperCollectibles").replace("0x","")}

pub fun main(address: Address): Bool {
  let account = getAccount(address)
  
  return account.getCapability(/public/DapperCollectiblesCollection)
    .borrow<&{DapperCollectibles.CollectionPublic}>() != nil
}
`,l=`
import DapperCollectibles from 0x${(0,s.RZ)("DapperCollectibles").replace("0x","")}

pub fun main(address: Address): CollectionInfo? {
  let account = getAccount(address)
  
  if let collectionRef = account.getCapability(/public/DapperCollectiblesCollection)
    .borrow<&{DapperCollectibles.CollectionPublic}>() {
    
    let ids = collectionRef.getIDs()
    
    return CollectionInfo(
      address: address,
      totalNFTs: UInt64(ids.length),
      nftIDs: ids
    )
  }
  
  return nil
}

pub struct CollectionInfo {
  pub let address: Address
  pub let totalNFTs: UInt64
  pub let nftIDs: [UInt64]
  
  init(address: Address, totalNFTs: UInt64, nftIDs: [UInt64]) {
    self.address = address
    self.totalNFTs = totalNFTs
    self.nftIDs = nftIDs
  }
}
`;async function c(e,t=[]){try{return await n.query({cadence:e,args:t})}catch(e){throw console.error("Script execution error:",e),e}}async function d(e){return c(i,[n.arg(e,n.t.Address)])}async function u(e,t){return c(o,[n.arg(e,n.t.Address),n.arg(t,n.t.UInt64)])}async function p(e){return c(a,[n.arg(e,n.t.Address)])}async function h(e){return c(l,[n.arg(e,n.t.Address)])}},87802:(e,t,r)=>{Promise.resolve().then(r.bind(r,28687)),Promise.resolve().then(r.bind(r,63881)),Promise.resolve().then(r.bind(r,4515)),Promise.resolve().then(r.bind(r,89411))},91151:(e,t,r)=>{"use strict";r.d(t,{EventProvider:()=>s});var n=r(71104);let s=(0,n.registerClientReference)(function(){throw Error("Attempted to call EventProvider() from the server but EventProvider is on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component.")},"/home/altcoin-daddy/Downloads/ownly/lib/flow/event-context.tsx","EventProvider");(0,n.registerClientReference)(function(){throw Error("Attempted to call useEvents() from the server but useEvents is on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component.")},"/home/altcoin-daddy/Downloads/ownly/lib/flow/event-context.tsx","useEvents"),(0,n.registerClientReference)(function(){throw Error("Attempted to call useNFTEvents() from the server but useNFTEvents is on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component.")},"/home/altcoin-daddy/Downloads/ownly/lib/flow/event-context.tsx","useNFTEvents"),(0,n.registerClientReference)(function(){throw Error("Attempted to call useMarketplaceEvents() from the server but useMarketplaceEvents is on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component.")},"/home/altcoin-daddy/Downloads/ownly/lib/flow/event-context.tsx","useMarketplaceEvents"),(0,n.registerClientReference)(function(){throw Error("Attempted to call useNotificationEvents() from the server but useNotificationEvents is on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component.")},"/home/altcoin-daddy/Downloads/ownly/lib/flow/event-context.tsx","useNotificationEvents")},91689:(e,t,r)=>{"use strict";r.d(t,{$:()=>o,cn:()=>i});var n=r(59054),s=r(26679);function i(...e){return(0,s.QP)((0,n.$)(e))}function o(){return`${Date.now()}-${Math.random().toString(36).substr(2,9)}`}},97446:(e,t,r)=>{"use strict";r.d(t,{Y5:()=>a});class n{constructor(e=1e4){this.metrics=[],this.maxEntries=e}async store(e){if(this.metrics.push(e),this.metrics.length>this.maxEntries){let e=this.metrics.length-this.maxEntries;this.metrics.splice(0,e)}}async query(e){let t=this.metrics;return e.category&&(t=t.filter(t=>t.category===e.category)),e.startTime&&(t=t.filter(t=>t.timestamp>=e.startTime)),e.endTime&&(t=t.filter(t=>t.timestamp<=e.endTime)),e.tags&&(t=t.filter(t=>!!t.tags&&Object.entries(e.tags).every(([e,r])=>t.tags[e]===r))),t.sort((e,t)=>t.timestamp.getTime()-e.timestamp.getTime()),e.limit&&(t=t.slice(0,e.limit)),t}async getAggregated(e,t,r){let n=this.metrics.filter(r=>r.category===e&&r.timestamp>=t.start&&r.timestamp<=t.end);if(0===n.length)return[];let s=new Map;n.forEach(e=>{let t="all";if(r)switch(r){case"endpoint":t=e.endpoint||"unknown";break;case"eventType":t=e.eventType||"unknown";break;case"operation":t=e.operation||"unknown";break;case"component":t=e.component||"unknown";break;case"hour":t=e.timestamp.toISOString().slice(0,13)+":00:00";break;case"day":t=e.timestamp.toISOString().slice(0,10);break;default:t="all"}s.has(t)||s.set(t,[]),s.get(t).push(e)});let i=Array.from(s.entries()).map(([e,t])=>{let r=t.map(e=>e.value).sort((e,t)=>e-t),n=r.length,s=r.reduce((e,t)=>e+t,0),i=r[0],o=r[r.length-1],a=Math.floor(.95*n),l=Math.floor(.99*n),c=r[Math.min(a,n-1)],d=r[Math.min(l,n-1)];return{group:e,count:n,average:Math.round(s/n*100)/100,min:i,max:o,p95:c,p99:d}});return i.sort((e,t)=>e.group.localeCompare(t.group)),i}async cleanup(e){let t=this.metrics.length;return this.metrics=this.metrics.filter(t=>t.timestamp>e),t-this.metrics.length}getStorageStats(){let e,t;let r=this.metrics.length,n=JSON.stringify(this.metrics).length;if(r>0){let r=this.metrics.map(e=>e.timestamp).sort();e=r[0],t=r[r.length-1]}return{totalMetrics:r,memoryUsage:n,oldestMetric:e,newestMetric:t}}clear(){this.metrics=[]}}var s=r(91689);let i={enabled:!0,sampleRate:1,retentionDays:7,thresholds:{api:{responseTime:{warning:1e3,critical:3e3},errorRate:{warning:5,critical:10}},events:{processingTime:{warning:500,critical:2e3},queueSize:{warning:100,critical:500}},blockchain:{queryTime:{warning:2e3,critical:5e3},transactionTime:{warning:1e4,critical:3e4}}},alerting:{enabled:!0},storage:{type:"memory",maxMemoryEntries:1e4}};class o{constructor(e){this.alerts=[],this.alertCallbacks=[],this.config={...i,...e},this.storage=this.createStorage()}createStorage(){return this.config.storage.type,new n(this.config.storage.maxMemoryEntries||1e4)}shouldCollect(){return!!this.config.enabled&&Math.random()<this.config.sampleRate}async recordAPIMetric(e){if(!this.shouldCollect())return;let t={id:(0,s.$)(),name:`api_${e.method.toLowerCase()}_${e.endpoint.replace(/[^a-zA-Z0-9]/g,"_")}`,value:e.responseTime,unit:"ms",timestamp:new Date,category:"api",endpoint:e.endpoint,method:e.method,statusCode:e.statusCode,responseTime:e.responseTime,requestSize:e.requestSize,responseSize:e.responseSize,userAgent:e.userAgent,ip:e.ip,tags:e.tags};await this.storage.store(t),await this.checkAPIThresholds(t)}async recordEventMetric(e){if(!this.shouldCollect())return;let t={id:(0,s.$)(),name:`event_${e.eventType.toLowerCase().replace(/[^a-zA-Z0-9]/g,"_")}`,value:e.processingTime,unit:"ms",timestamp:new Date,category:"event",eventType:e.eventType,processingTime:e.processingTime,queueSize:e.queueSize,eventSource:e.eventSource,blockHeight:e.blockHeight,transactionId:e.transactionId,tags:e.tags};await this.storage.store(t),await this.checkEventThresholds(t)}async recordBlockchainMetric(e){if(!this.shouldCollect())return;let t={id:(0,s.$)(),name:`blockchain_${e.operation}_${e.network}`,value:e.responseTime,unit:"ms",timestamp:new Date,category:"blockchain",operation:e.operation,network:e.network,contractAddress:e.contractAddress,gasUsed:e.gasUsed,blockHeight:e.blockHeight,tags:{...e.tags,success:e.success.toString()}};await this.storage.store(t),await this.checkBlockchainThresholds(t)}async recordUIMetric(e){if(!this.shouldCollect())return;let t={id:(0,s.$)(),name:`ui_${e.component.toLowerCase().replace(/[^a-zA-Z0-9]/g,"_")}`,value:e.renderTime,unit:"ms",timestamp:new Date,category:"ui",component:e.component,renderTime:e.renderTime,interactionType:e.interactionType,route:e.route,tags:e.tags};await this.storage.store(t)}async checkAPIThresholds(e){let t=this.config.thresholds.api;if(e.responseTime>t.responseTime.critical?await this.createAlert({type:"critical",category:"api",message:`API response time critical: ${e.endpoint} took ${e.responseTime}ms`,metric:e,threshold:t.responseTime.critical}):e.responseTime>t.responseTime.warning&&await this.createAlert({type:"warning",category:"api",message:`API response time warning: ${e.endpoint} took ${e.responseTime}ms`,metric:e,threshold:t.responseTime.warning}),e.statusCode>=400){let r=await this.storage.query({category:"api",startTime:new Date(Date.now()-3e5),tags:{endpoint:e.endpoint}}),n=r.filter(e=>e.statusCode>=400).length,s=r.length,i=s>0?n/s*100:0;i>t.errorRate.critical?await this.createAlert({type:"critical",category:"api",message:`API error rate critical: ${e.endpoint} has ${i.toFixed(1)}% error rate`,metric:e,threshold:t.errorRate.critical}):i>t.errorRate.warning&&await this.createAlert({type:"warning",category:"api",message:`API error rate warning: ${e.endpoint} has ${i.toFixed(1)}% error rate`,metric:e,threshold:t.errorRate.warning})}}async checkEventThresholds(e){let t=this.config.thresholds.events;e.processingTime>t.processingTime.critical?await this.createAlert({type:"critical",category:"event",message:`Event processing time critical: ${e.eventType} took ${e.processingTime}ms`,metric:e,threshold:t.processingTime.critical}):e.processingTime>t.processingTime.warning&&await this.createAlert({type:"warning",category:"event",message:`Event processing time warning: ${e.eventType} took ${e.processingTime}ms`,metric:e,threshold:t.processingTime.warning}),e.queueSize>t.queueSize.critical?await this.createAlert({type:"critical",category:"event",message:`Event queue size critical: ${e.queueSize} events in queue`,metric:e,threshold:t.queueSize.critical}):e.queueSize>t.queueSize.warning&&await this.createAlert({type:"warning",category:"event",message:`Event queue size warning: ${e.queueSize} events in queue`,metric:e,threshold:t.queueSize.warning})}async checkBlockchainThresholds(e){let t=this.config.thresholds.blockchain["transaction"===e.operation?"transactionTime":"queryTime"];e.value>t.critical?await this.createAlert({type:"critical",category:"blockchain",message:`Blockchain ${e.operation} time critical: ${e.value}ms on ${e.network}`,metric:e,threshold:t.critical}):e.value>t.warning&&await this.createAlert({type:"warning",category:"blockchain",message:`Blockchain ${e.operation} time warning: ${e.value}ms on ${e.network}`,metric:e,threshold:t.warning})}async createAlert(e){let t={id:(0,s.$)(),type:e.type,category:e.category,message:e.message,metric:e.metric,threshold:e.threshold,timestamp:new Date,resolved:!1};this.alerts.push(t),this.alertCallbacks.forEach(e=>{try{e(t)}catch(e){console.error("[PerformanceCollector] Error in alert callback:",e)}}),console.warn(`[PerformanceCollector] ${e.type.toUpperCase()} ALERT: ${e.message}`)}onAlert(e){return this.alertCallbacks.push(e),()=>{let t=this.alertCallbacks.indexOf(e);t>-1&&this.alertCallbacks.splice(t,1)}}async getMetrics(e){return this.storage.query(e)}async getAggregatedMetrics(e,t,r){return this.storage.getAggregated(e,t,r)}getActiveAlerts(){return this.alerts.filter(e=>!e.resolved)}resolveAlert(e){let t=this.alerts.find(t=>t.id===e);t&&(t.resolved=!0,t.resolvedAt=new Date)}async cleanup(){let e=new Date(Date.now()-864e5*this.config.retentionDays),t=await this.storage.cleanup(e);console.log(`[PerformanceCollector] Cleaned up ${t} old metrics`);let r=new Date(Date.now()-2592e6),n=this.alerts.length;this.alerts=this.alerts.filter(e=>e.timestamp>r);let s=n-this.alerts.length;s>0&&console.log(`[PerformanceCollector] Cleaned up ${s} old alerts`)}updateConfig(e){this.config={...this.config,...e}}getConfig(){return{...this.config}}}let a=new o}};